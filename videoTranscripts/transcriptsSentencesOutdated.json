{"IRxsjPGh1oQ": ["So we're going to do one last example in this sequence", " We've been looking at approximation algorithms", " We've been looking at guess and check, exhaustive enumeration", " We saw when we wanted to move to floating point, we needed to be a little more clever, and that led us to the idea of bisection as a smart way of reducing the computation at each stage, especially when we have functions or problems where there's a monotonic relationship between the value we're looking for and the guesses we're making", " There's one other, very powerful, algorithm for doing approximations, due to Sir Isaac Newton, often called the Newton-Raphson algorithm because it was found at the same time by Newton and by Raphson", " Here's the basic idea behind it", " We want to find the root of a polynomial", " I'll remind you a polynomial, p(x), is some sequence of coefficients and powers, so it's a_n * x to the n-th power + a_n - 1 * x to the n minus first power and so on", " It's just a sequence of numbers times powers of x, and what we often want to do is find a value r such that p(r) is equal to 0", " We want to find the root, the place where, on that x-axis, that graph crosses 0", " Now, that sounds like a lot of math", " Let's make it a little simpler", " A simple way to think about this is if we want to define, for example, the square root of 24, we just need to find the root of the polynomial x^2 - 24", " Makes sense, if we combine the value of x such that x^2 - 24 is equal to 0, we're done because that's the thing we want", " Now, what Newton showed was that for things like polynomials, if g is an approximation to the root, the place where it's equal to 0, then g - p(g) / p'(g) is a better approximation, where p' is just the derivative of p", " And if you haven't done calculus, don't worry about it", " We'll show you in a second what that means, but this is a powerful tool", " Newton proved this, that given an approximation, g - p(g) / p'(g) is a much better approximation", " OK, so what does this have to do with things? Well, let's look at an example, a really simple case", " Suppose our polynomial is just some coefficient c times x^2 + k, then its first derivative is just 2cx", " And in particular, if the polynomial is just something simple, like x^2 + k, then the derivative is just 2x", " Why is that nice? Well, Newton-Raphson says that given a guess g for the root, a better guess is just shown right here, is g - g^2 - k, all divided by 2g", " And remember, we were using this form to find square roots, because it says if k is the value of the square root I want to find, then that's the polynomial I want to use", " So this little formula says here's a better way of finding a guess for the square root of k", " All right, let's put that together", " We can now have another way of generating guesses, which we can check, which turns out to be very efficient, so here's some code that would do it", " Again, I've got a little epsilon that tells me how close I want to get", " Let's assume I'm looking for the square root of 24", " We'll try some other examples in a second", " I'm going to give an initial guess, which will just be y / 2", " It's not a very good guess, but it's reasonable place to go", " And look at the code", " Very crisp, very clean, very efficient", " It basically says check to see am I close enough", " Is the difference between the guess^2 and y less than or equal to the epsilon", " If it's bigger than that, I'm not close enough", " And then Newton says get a new guess by taking the old value of guess, taking guess^2 - 1, divide it by 2 * guess, which is the derivative, and use that to create a new binding for guess", " You just keep updating", " Do that until I get close enough, and when I'm done, just print out the result", " Nice and crisp", " What's this doing? It's generating guesses", " There's the generation", " But it's not doing it exhaustively", " It's using this property of mathematics together, and then it's testing, right here, to see if I'm done", " So it's another example of a generate and test kind of algorithm, and let's look at what happens if we run it", " So in my IDLE, I've got just a version of that", " I'm going to do it with 24 to start with", " And if I evaluate this, it prints out its guesses, starts with a value of 14, and then goes to 7, 5", " And you see, in just 4 guesses, it gets a pretty good answer", " Let's try a different example", " Let's try our good old example of 25", " Again, if I evaluate that one, you'll see again, in basically five steps because the first one was using 12 and a half, it gets to a quite good approximation of it", " Let's try something even bigger", " I'll go back over here", " Let's do my example of 12345 and let's evaluate that", " And if we do that-- huh", " What did it take me? 1, 2, 3, 4, 5, 6, 7, 8, 9-- in 10 steps, it got to a really good solution", " So this is what? This is another way of simply figuring out how to generate good guesses and then testing them", " So we've now seen several examples", " We've got this idea of iterative algorithms", " We're using the same piece of code over and over again", " We're using that to build up this idea of a guess and check method where we guess solutions and then check them", " We use a looping construct to generate the guesses, and then we just check and keep going", " And what have we seen? We've seen we could do exhaustive enumeration, where we just do a whole bunch of trials", " We could cut down on the search in a clever way by simply using bisection, bisecting the range of places where we're looking for guesses until we get to something close enough", " Or for the group finding case, which it turns out to be a very general case, we can be really efficient by taking advantage of a mathematical property to very quickly cut down on where the solution lies", " Those are examples of iterative algorithms, and they're examples, in particular, of guess and check methods that turned out to be really powerful", " And we're going to give you a chance to explore those as we move through the class", ""], "cHpto4Yc45o": ["John Guttag: In the last segment, we talked about simulation models in enormous generality", " Today, I want to get more specific, look at an example of how a simulation model can be built, and get some practice in designing classes along the way", " So let's start by looking at the notion of Brownian motion, as shown by these red and blue dots moving on your screen", " In 1827, the Scottish botanist Robert Brown observed that pollen particles suspended in water seemed to float around at random", " He had no plausible explanation for this so-called Brownian motion, and made no attempts to model it mathematically", " A clear mathematical model of the phenomenon was first presented in 1900 in Louis Bachelier's doctoral thesis, the theory of speculation", " However, unfortunately for Louis, since this thesis dealt with it the then very disreputable problem of understanding financial markets, it was largely ignored by respectable academics", " And in fact, he struggled to even get a job", " Five years later, however, in 1905, Albert Einstein, then a young man, brought this kind of stochastic thinking to the world of physics, with a mathematical model almost the same as Bachelier's and a description of how that model could be used to confirm the existence of atoms", " For reasons certainly lost on me, people seemed to think that understanding physics was more important than making money", " I guess the times were different", " Brownian motion is example of something that has come to be called a random walk", " Random walks are widely used to model physical processes, e", "g", " heat diffusion, biological processes, for example, the kinetic displacement of RNA from heteroduplexes by DNA -- I hope some of you know what that means, I'm not sure I do -- and social processes", " For example, getting back to Bachelier, the movements of the stock market", " What I want to do now, though, is look at an example of a random walk that's actually a walk", " Imagine, if you can, a drunken farmer standing in the middle of the field", " And every second he takes one step in a random direction", " Now I want you to ponder the question, what is the expected distance from the origin in, say 1,000 seconds", " More generally, if the farmer takes many steps, is he likely to move ever further from the origin, or is he more likely to wander back to the origin, over and over again, and end up not far from where he started? Let's write a simulation to find out", " Before we do that, before we build any complicated computation, it's always a good idea to develop some intuition about the situation the program is intended to model", " Let's start by sketching the simple model of the situation using Cartesian coordinates", " Assume that the farmer is standing in the field where the grass has mysteriously been cut to resemble a piece of graph paper", " Let's assume further-- put the farmer right here in the middle-- assume further that each steps the farmer takes is of length 1, and is parallel to either the x or y-axis", " Clearly this is an oversimplification", " But it's a common approach to building simulation models", " We start with something simple, and then add complexity a little bit at a time", " All right, after one step the farmer will be either here, or here, or here, or here", " So we see that after one step, the farmer is exactly one unit away from where he started", " Let's look at the second step", " Without loss of generality, we'll assume that he took this first step eastward", " It'll be symmetric if we went in a different direction", " After the second step, he could be right back where you started, that is to say zero units away", " Or he could be another step east, two units away, each of those a quarter of the time", " And half the time, he'll be there or there", " How far away is that? Well that's the square root of 2 units away", " How do we know that? Let's look at old friend the Pythagorean theorem", " We can look at it here", " And we know that a^2 + b^2 = c^2 ", " Therefore c = sqrt(a^2 + b^2) If we go back here, we look at say, that x", " We see that a = 1 and b=1 ", " And therefore this distance here is going to be sqrt(2) ", " All right, I could now look at the third step and keep drawing circles all over the place, but it's starting to get pretty complicated", " And that suggests to me that it's time to stop drawing pictures-- and you'll probably be relieved, given my drawing ability-- and instead start writing code", " Build a simulation that will actually give us the answer we want", " OK, let's give it a shot", " Before we do, what's your intuition? Give it a minute, think about it", " My intuition is that since more than half the time here, after two steps the farmer is further away from the origin than after one step, maybe the longer he walks, the further he'll be", " I'm not positive", " But that's my guess going into the simulation", " All right, onto the coding", " But before we write the simulation, as usual, we want to try to invent some classes that correspond to the types of things that appear in the situation we're attempting to model", " Three classes seem potentially useful", " We probably want a class Location, because after all, it's mostly what we've been talking about is the location of the drunken farmer", " We probably want a class Field, corresponding to the graph paper we drew", " And surely we're going to need something corresponding to a Drunk, because that's going to have to model the movements", " Now let's look at each of those classes", " Come over to the code, and look at class location", " It's very simple", " It's got initialization", " But even here, we see that a decision has been made, as simple as it is", " We see that a location is going to have only x and y coordinates", " That tells us that it's going to be a two dimensional field", " We're modeling a farmer not, oh, say, a pigeon", " There is no ability for the farmer to fly up into z-coordinate", " Also, it looks like perhaps we're ready to generalize our notion of moving due east, west, north, or south, because we're allowing x and y to be floats", " We've got move, which takes a self with deltaX and deltaY , and returns a new location, in which we've implemented x and y by the delta", " Note that deltas could be negative", " So this isn't saying that we're always moving in one or another direction", " We can get x", " We can get y", " And here we're using the good old Pythagorean theorem, as we've just seen, to find the distance", " And finally we have a way to print the location", " So reviewing, the notable aspects of Location are two dimensions, no x and no y, no built in assumptions about directions", " That's because our delta x and delta y are floats", " All right, moving on, let's look at our next interesting type", " That's going to be Field", " Fields, like Locations, are also quite simple", " We can initialize them", " We can add a Drunk to the field", " We can move the Drunk", " This is probably the only really interesting function we have here in fields, interesting method", " So we say if the Drunk is not already there, then we will raise an exception", " Otherwise, we'll take a step", " What does that mean? We don't know yet", " That depends upon the kind of Drunk we're looking at", " And that will allow us to take a step", " And that will return a distance along the x direction and the y direction", " We'll get the current Location", " And then we'll update the current Location with whatever we got from Drunk", "takeStep() So what are the notable aspects of class Field that we might look at? Well one thing we see about Fields is that there can be many Drunks", " We might or might not choose to use that", " There can be many Drunks in the Field", " And furthermore, it seems to be that the Drunks can be at the same Location", " We've not put in any restrictions about where the Drunks are relative to each other", " The final thing we'll notice is the Field seems to be unbounded", " We've said nothing about the Drunk falling off the edge of the Field, or running into a fence", " Again, these are simplifications, which we may choose to remove later", " The final class is actually two classes", " And since it's a little bit complicated, and I want to show you things about it, I'm going to look at them over here on the PowerPoint, rather than on the IDLE window", " As we guessed, I had a class Drunk", " But look how simple it is", " The only thing the Drunk does is it has a name, and it can print the name", " What we see here is really drunk is what we before called an abstract class", " It's not intended to do anything useful by itself", " It's intended to be sub-classed to give us different kinds of Drunks", " And as we'll see-- not in this segment, but in a future segment-- we can use it to create some rather interesting and divergent behaviors, depending upon the predilection of individual Drunks", " This segment, we'll look at only one Drunk, one class of Drunk", " And I'm going to call that the UsualDrunk", " That's the kind of Drunk we've been talking about so far", " The most important thing to see here is that I'm importing class random", " Most programming languages, including Python, include simple ways to write programs that use randomness", " When we need randomness in a Python program, we import the class random, and that supplies us with a whole variety of useful functions", " Here we're only using one", " We are using the function random", "choice() ", " random", "choice() has its argument, a sequence, and at random chooses a single element of that sequence", " With equal probability, it might choose any element", " So for example, if I were to look at something like random", "choice(range(3)) , it would at random return an integer and the range what? 0 to 3, because we know that's the sequence range(3) generates", " Here, it will return a random element of stepChoices , which we define to be a list of tuples corresponding to the steps in the north, south, east, and west direction", " So for example, 0,0 is a step north", " 0, - 1 is a step south, a step east, and a step west", " With that, I'll stop", " And in the next segment we'll use these classes to start building our first interesting simulation", ""], "BWBUXxyRILw": ["PROFESSOR W", " ERIC L", " GRIMSON: Welcome back", " We're almost done with this course and, if you think about it, you've seen, actually, a surprising amount of information-- knowledge, tools, techniques-- that really help you not only think about how to program in Python but more importantly to think about how to attack problems computationally", " In this penultimate lecture, we're going to have a set of cameo appearances, because we want to show you how the tools that you've been developing-- the tools you've been thinking about-- are the basis for a great variety of really interesting applications", " Now, in fairness, you'll need some more sophisticated tools in some cases to really get to the kinds of applications you see here", " But I hope you see, through these cameo appearances, a thread of the kinds of ideas you've been using showing up", " We're going to feature videos from five different MIT computer science professors-- Fredo Durand, Sam Madden, Dana Moshkovitz, Collin Stultz, and Russ Tedrake-- all talking about different applications-- of cutting edge research-- that use the kinds of tools you've been seeing here", " So you're going to see examples-- from graphics, from big data and databases, from computational theory, from medical applications, and from robotics-- that really demonstrate how what you're learning is incredibly important", " Enjoy", ""], "hPnWQRQAEko": ["NTA"], "jx0WwCGCh-0": ["ERIC GRIMSON: We've now added tuples, generalization of strengths, an ordered sequence of elements, where the elements can be any structure", " And we've already seen that a lot of the operations we wanted on strings, we're going to have on tuples", " We're going to add another kind of structure called a list", " And it looks a lot like tuples", " And again, lists are ordered sequences of values", " Each one's identified by an index, so it's going to support all the same kinds of operations I saw before", " The difference here is we're going to use these square brackets rather than the parentheses to distinguish a list or to create a list, as opposed to a tuple", " So they are a little different in terms of how they're going to look", " And as a consequence, and one nice thing, is that singletons are now pretty straightforward", " It's just a square bracket, the entry, and another square bracket", " I don't have to put that annoying comma in that I had to do with tuples in order to distinguish between an arithmetic expression and a tuple with just one element", " Looks much the same", " So what's the big deal? Well, there's one very big difference, and it's a really important one", " Which is that lists are mutable", " And what does that mean? It means we can change them", " What does that mean? Well, things like ints, floats, strings, and tuples are immutable", " And that means that we can't go in and change an element inside of them", " Now for ints and floats, that's obvious", " And tuples, we just introduced, so we sort of have to accept that on faith", " But if you think about strings, you can get elements of strings out-- you can slice into strings-- but you can't go in and directly change one character in a string", " They're not mutable", " They're immutable", " They don't change", " On the other hand, lists can be modified after they're created", " And why would we want to do that? Well, in part because there are going to be some problems where that's really valuable", " So what does that mean? Some data objects, we really want to treat as if fixed", " It says we create new versions of them, we combine variables to them, but we don't want to change them", " And this is usually valuable when those data objects are going to be frequently referenced, but where the pieces inside of them don't change", " Why would we want to support having ability to change them, because that could just lead to bugs? On the other hand, there's going to be some instances where the data objects may want to support modifications to elements inside of them", " Why might that happen? Imagine you've got a really large database of personnel information and you want to do things like change salaries", " You don't want to have to make an entirely new copy of the database just to add in a new salary", " You'd like to be able to go inside and change a piece of that", " So lists are going to support that kind of operation by enabling us to go in and mutate, or alter, elements of the pieces", " One issue to keep in mind is that, while mutable structures give us more flexibility, they also are more prone to programming errors", " If I've got two different pieces of code both pointing to the same list, and I have one piece of code change or mutate a portion of the list, I want to make sure that that other piece of code is aware of that", " If not, I can get myself into some really interesting bugs", " So there's a cost, but there's a bonus", " Let's look at an example of what this means", " So let's create a couple of lists", " And in fact, over here in my IDLE shell, I'm going to do that", " Let me just create a couple of lists", " And I'm going to call Techs as a name for a couple of great technical schools", " And notice the angle braces to get them for me", " And I'm going to create Ivys", " I'm not going to do all of them, but I will again create a list of some great schools", " We'll do Harvard", " We'll do Yale", " And we'll do Brown", " And if I print them out, I can say, what is the value of Techs? And it just gives me that list", " On my slide, I've given you a visualization of that", " So think of this as Techs and Ivys sitting up in that global environment", " After all, I just typed them into the shell for Python", " And what do they do? Well, they point to a structure in memory somewhere that has that sequence of elements inside of it", " As I've said, I can treat this as if they were just an order of sequences", " So I could say something like, what is the first element of the Ivys? Remember, we start indexing at 0, so that gives me back Yale, which is nice", " And I could slice if I wanted to", " I could say give me back the Ivys, everything up to the second one", " And that gives me the zeroth and first elements", " I can do things I'd expect to do on that", " Let's see what happens when we start putting things together", " So I've got two lists-- a list of tech schools", " I've got a list of Ivys", " Let's now create what looks like two different lists of universities", " So the first one, I'm going to call Univs, for universities", " And it's going to be a list of the Techs and the Ivys", " And I'm going to create what looks like the same thing", " I'm going to call it Univs1, and I'm simply going to re-create that sequence", " Cal Tech was the first one", " And since I'm creating a list of these lists, I'm going to put a comma in there, and then I'm going to do Harvard, Yale, and Brown", " Are these the same thing? Well, let's print them out", " If I look at Univs, yeah, nice", " It's a list of two elements, the first of which is a list of two elements", " Second of which is a list of three elements", " And if I look at Univs1, it looks exactly the same", " They certainly print the same", " So it is easy to think that these might, in fact, be the same thing", " But they're not", " And let me show how I can test that", " Let's evaluate the following little command up here", " An append is a method associated with lists", " We'll come back to methods later on", " That dot notation basically says, if I type in Techs, it's a list", " The dot says get the method append associated with it", " Don't worry what a method is, but basically think of it as a function that is going to take an argument-- in this case, a single element, RPI-- and it is going to attach that element to the end of the list text", " So, what does it do? It's an important thing here", " It doesn't create a new list", " It mutates the existing one", " It takes Techs as a list and changes it", " It mutates it to add a new element to the end, extending the list by one", " Now, as a consequence, if we print out Univs, notice we now have in that first element MIT, Cal Tech, and RPI", " We have changed what's inside of there", " We have mutated Techs, not Univs", " In fact, let's just check it", " Let's go look at Techs, and there's Techs", " But again, if I go back to Univs, there it is", " And now what happened to Univs1? Aha! It didn't change", " And that's an important point", " Look at the form of Univs1", " It has just the first two pieces to it", " And, in fact, if I go to the next slide, we've captured that", " If I print out Univs, I get out MIT, Cal Tech, RPI, followed by Harvard, Yale, Brown", " But for Univs1, I just get MIT, Cal Tech, and then Harvard, Yale, Brown", " Why? Well, this is where the mutability comes in", " So let's think carefully about what we had", " Before I did that append, I'd had a binding for Techs, and I had a binding for Ivys", " We created those", " They said we're lists", " And then what did I do? I said, let Univs equal-- and in fact, let me just write it out here-- I bound Univs to Techs and Ivys", " And what does that say? It says make a list", " So there's Univs", " It's going to make a list", " And it says the value of the first element is going to be the value of Techs", " So aha", " It's just a pointer to that list", " And the value of the second argument, or the second element, is just the value of Ivys", " So aha, it's just pointing to there", " So Univs is a list whose elements are just pointers to other lists", " On the other hand, what did I do when I created Univs1? If you look back, you'll see that, in fact, I created it by actually typing out lists", " I said Univs1-- just to say a little bit of it-- I said Univs1 was going to be, and then I said quote MIT, quote Cal Tech, comma", " And then I did a bunch of other things", " I'm not going to do all of it", " But this is telling Python, create a list with those strings inside of it", " So in fact, that's exactly what it did", " Univs1 is going to create a list, but it creates it with a new version", " Right there", " Notice Techs is not pointing to this", " There's a new version right there", " Ivys is not pointing to this because I created them and inserted them inside of this larger list", " That's important, because now when I did that append on Techs, what did it do? It went over here and changed that", " It added that into the end of it", " That means that Univs changes because it sees that", " But what about Univs1? This is a completely different list", " Nothing changed there", " Let's make some observations out of this", " The elements of Univs are not copies of the list to which Ivys and Techs are bound, but are the lists themselves", " I got the value of Techs, which pointed to the list", " And this effect is something we call aliasing", " Basically what does aliasing says? It says we have two distinct paths to a data object", " One is through the variable Techs, in this case", " There's a second one through the first element of the list object to which Univs is bound", " And one of the effects of that is that I can mutate an object through either path, but the effect will be visible to both", " And I just saw that back here when I mutated Techs, but Univs changed", " That sharing of data is really important", " And that mutation, that ability to change things, is really important", " This is very convenient, but it also can be really dangerous", " It can be treacherous", " Because if I had something that was changing Techs and I didn't realize that Univs inherited the Techs structure, I've now changed something inside of Univs", " And if you think back to the code I just typed in there, you saw nothing that said make a change to Univs", " But changing a part of it had that effect", " So aliasing is a valuable tool, but it is going to occasionally lead to some problems, and we have to be careful about it", " Now what else can we do? Well, we can certainly change elements directly", " So if I go back, for example, and I look at Techs", " Here's my list of tech schools, MIT, Cal Tech, RPI", " I might decide I want to change the list", " So I can literally say, change the second element of Techs", " And I do it just with an assignment statement", " I'm going to pick up WPI", " And now if I look at Techs, that element is changed", " I've mutated it", " By the way, if I go back and look at Univs, it has also changed", " I've now got WPI in the first portion of that element", " Just to remind you, it says I can mutate elements of this", " I cannot do the same things with tuples", " So if I do an example where I create a tuple-- we can look at temp", " But if I now say, and I could certainly get out, for example, the first element of temp", " But if I attempt to change that, as I just did above here by putting in something new, it's going to complain", " And it says you can't do it because these things are not things that can be mutated", " So now we've got lists", " Let's see what we can do with them", " As I just said, stressing it, I can't do that with tuples", ""], "ADB7EXNTVqs": ["This coin just came up tails twice in a row", " How many more tails in a row would it take for me to convince you that the coin has tails on both sides? If I were to flip it 12 times and got eight tails and four heads, would you be convinced that is was weighted, so that tails would typically come up twice as often as heads? Suppose I flipped it 1,200 times and got 800 tails and 400 heads", " In the next sequence of lecture segments we'll look at this and related questions", " We'll cover the law of large numbers and the gambler's fallacy", " More generally, we'll talk about what happens when we draw samples from different kinds of distributions", " We'll conclude by looking at normal distributions", " And how one can use the standard deviation of a normal distribution to understand how confident one should be in the accuracy of inferences based on sampling", ""], "Rjk7yfFQCPI": ["ERIC GRIMSON: So far, in this course, we've been building up a lot of really powerful tools", " We've seen different kinds of data structures", " We've seen different classes of algorithms", " We've seen ways of putting those together to do interesting things, solving problems", " And one of the things we might want to do now is just step back for second and ask, so what are we trying to accomplish when we design program, a piece of code? What are our goals? And typically, there are 2", " The first and most important one is we want our program to return correct answers on all legal inputs, all legal inputs", " So if we're defining a function that is to apply to integers, we want to work on all values of integers", " Or if there's a particular range, we want to specify that as part of the specs", " So our first goal is to have code that does the right thing", " It computes the right answer", " Second goal can often also be, though, that we want it to perform its computation efficiently", " Typically, 1 is more important, but there are times when that second point is also critical", " For example, we've got a program to detect collisions in aircraft, or to do real time control of traffic signals", " We need it to be very efficient to ensure that it can respond before something happens in the world", " As a consequence, sometimes 2 is really crucial", " But even in cases when 1 is most important, it is still valuable to understand and optimize efficiency", " So even if we've got code that computes the right answer, if we've got alternatives that are going to give the same answer, but one's more efficient than another, we'd like to know about that", " So that leads us to this question of what we call computational complexity", " And here we're going to do a somewhat informal version of this, but to give you a sense of how you begin thinking about computational complexity", " So what does it mean to say, how efficient is an algorithm? There are 2 questions we can ask", " We can ask how much time is it going to take for the program to run, and we can ask how much memory is it going to need, inside of the machine, in order to do the computation it wants to do", " Again, typically, we're going to be most interested in this one, the amount of time", " We'll see that we can also worry about memory, and for some really big problems, memory's crucial", " But in general, we're going to worry about time", " How long does it take for the program to run? Even there, when we start thinking about that, we want to be careful", " We want to balance minimizing computational complexity with conceptual complexity", " And what do I mean by that? I'd like to keep my code clean, simple, easy to understand", " So if I come back to it a month from now, a year from now, I still understand what the code was written to do", " If somebody else looks at it, they can understand what the code was intending to do", " And I say that because sometimes one can find interesting tricks one can play to get a little bit more efficiency in the code, but it makes the code much harder to understand", " And we need to balance that", " There's no perfect balance, but in general, I'd prefer to have code that's still easy to understand", " And, having done that, have it be as efficient as possible than to jeopardize the code just to give a little bit of efficiency", " I want to make sure that our code is still clean, but we do want to worry about how do we minimize complexity? And that complexity is typically going to be in terms of how long does it take something to run? OK, so now we could say, given a function, we'd like to answer the question, how long will this take to run? So what are our choices? Well, a simple choice would just be run it on some input and time it", " That, of course, has several problems", " The first one is, it depends on the speed of the computer", " The second one is, it actually depends on the specifics of the Python implementation", " Depending on which version you're using, you may get slightly different answers", " Both those aren't great", " And the third one is, of course, it will depend on the value of the input", " Now if I've got something that's a recursive function, changing the input will lead to different amounts of time", " So how do I get rid of these factors? I want to be able to make general statements about complexity", " Well, for points 1 and 2, I can avoid those by measuring time, not in terms of actual elapsed time, but in terms of the number of basic steps that the computer executes", " We'll come back to 3 in a second, but we're going to start with thinking about how do we avoid 1 and 2? And for that, we use what's called a random access machine model", " We're going to use that as our model of computation", " What does that say? It says the steps are executed sequentially", " We're not running in parallel", " And the second assumption that model makes is that a step is an operation that takes a constant amount of time", " And for that, we're going to assume assignment, comparison, arithmetic operations, and accessing an object in memory, all take a constant amount of time", " You might quibble a little bit", " You say, well, maybe multiplication's a little bit more expensive than addition", " But as a first pass, this is a pretty good approximation, that all arithmetic operations are roughly the same amount of time, comparisons, assignments", " This last one here might surprise, and we'll come back to that later", " But in fact, we can set up our system so that, indeed, getting any point in memory is going to take a constant amount of time", " The advantage of this model is it says, I'm removing the aspects of the machine", " How fast is my machine? What kind of Python am I running? And I'm able to just focus on counting the number of basic steps that I have to execute in order to compute a function", " So that removes the first two points where I had some concerns", " For the third point, the third point, I'll remind you, is it depends on the value of the input", " Here we're going to measure time, not in terms of a specific input, but in terms of the size of the input", " And that'll make sense in a second as we walk through it", " Now, you first say, well, OK, even if I'm talking about the size of the input, might the complexity not still depend on the value? Let's take a little example", " Here's a piece of code to linearly search a list", " This is trying to see if a particular element is in a list", " So what does it do? It iterates over the list, for e in the list", " And for each one of those elements of the list, it checks to see is it equal to the thing I'm looking for? If it is, I'll return True", " If it isn't, I'll return False", " All right", " Nice simple piece of code", " Here's the problem", " And the problem is that I could try and measure the complexity of this code in terms of the size of the list L, which makes sense", " That's the thing that's most likely change", " But the problem is that if x happens to be near the front of L, it's going to return True almost immediately", " On the other hand, if x is not in L, then the code is going to have to go through all the elements of L before it can return False", " And so it's going to give us dense, different answers depending on the specific choice", " And that's not what we want", " We need a general way of measuring complexity", " So what we're going to do, as a consequence, is, we're going to think about what are the different cases under which we can measure complexity? Well the first one will be what we could call best case", " It's the minimum running time over all possible inputs of a given size", " So for all possible lists of some length, for example, what's the best case I could see? Well, for linear search, the answer will be constant", " It would be independent of the size of the inputs, in the best case, because to be the first thing I'd look at", " That's not very helpful", " An alternative is to look at the worst case", " What's the maximum running time over all possible inputs of a given list? And there, what we see for linear search is this going to be linear in the size of the list", " So it's going to take some number of steps that depends on how long the list is", " If I double the list, the worst case is going to double as well", " That may be more useful to me", " There's a third possibility which is to use the average case or expected case, that is, just average the running time over all possible inputs of a given size", " And that might be more effective in terms of thinking, on average, what do I expect to see? I could even be clever", " If I know that my inputs don't come uniformly distributed, they're not all equally likely, if I have some knowledge about how likely an input is, I could even take advantage of that to do my averaging", " So an average case, some sense for practical purposes, is kind of nice", " But in fact, what we're going to focus on is the worst case, sort of an upper bound on the running time", " And it gives us a sense of what happens in the worst possible case for different kinds of algorithms", " And in particular, it's going to allow us to compare different classes of algorithms in a kind of nice way", " OK, so now I'm saying I want to measure basic steps and I'm going to do it in the worst case", " Let's see how we might try and do that", " And let's look at an example", " Here's our old friend factorial, a little procedure that's going to compute factorial of n", " It's a little iterative loop, sets answer initially to 1, and then it runs through a while loop", " As long as n is bigger than 1, it multiplies n by answer and binds answer to that new value", " It decreases n by 1", " And it keeps going through the loop until it's done and then it returns an answer", " You've seen this before", " Let's think about how do we measure the complexity here", " So we want to count the number of steps, right? So what have we got? Well here's the first one and that's basically one step, that assignment statement we said that was one of our pieces of our model", " Now inside the loop, what do we have? Well, for each time in the loop, I've got to do a test", " And this *= = is actually 2 operations", " It's a multiplication and an assignment", " And this -= is actually 2 operations", " It's subtraction and an assignment", " So inside of the loop I go through 5 steps", " And then what do I do? Well, I go through that loop multiple times", " So I do it 5 steps and then I do 5 steps, then I do 5 steps", " And in fact, we know we'll go through that loop n times, whatever the value of n is", " So there are 5n steps", " Go through the loop, and then, finally, I've got one for the return", " So I could write a little expression for this", " It says that the number of basic steps execute here is 5n + 2", " Do we really care about the 2? Well, clearly not because, as n gets large, it gets irrelevant", " This really turns into an expression that says it's 5n steps", " And again, I'm not worried about tiny differences in terms of milliseconds of something", " I want to know how does this algorithm behave I make my argument arbitrarily large", " And so basically, this has 5n steps that we need to execute", " All right", " I got rid of the 2, but what about the 5? Do I really care about the 5? And I'm going to argue that, in general, we don't, that those multiplicative constants are not relevant when comparing algorithms", " To see that let's look at a different example", " Here's something we saw before", " This is trying to find square roots, the square root of x within some accuracy epsilon", " I'm not going to go through the code in detail", " We simply set up a step size", " We get an answer and we've got a little while loop that runs through, looking at different values of answers", " So it starts at 0, increases by a small amount, a small amount, a small amount and it keeps trying until it finds an answer that's close enough, in which case it returns it", " If we were to call this procedure with x equal to 100 and an epsilon of 0", "0001, it's going to take about 1,000,000,000 iterations to get through the loop", " Now inside the loop, there are actually about 8 steps if we count them carefully", " So you could say it's about 8,000,000,000 operations", " But it's 8 times the number of times through the loop", " In this case, the number of times through the loop is about 1,000,000,000 ", " Now let's compare that to bisection search", " We saw this before", " This is a bisection way of trying to find the square root", " Remember what it said we do", " Given a number, we look at a low value of 0 and a high value, let's assume it's big enough, of x", " We pick the middle point, we check it", " If it's close enough to the answer, we're done", " If not, we decide whether the real answer lies between that midpoint and the high number, or between the low number and that midpoint, and then we do the same thing", " And we keep chopping it down", " If we call this procedure on the same argument, 100, and that same epsilon 0", "0001, it's only going to take 30 iterations through the loop", " Now it turns out, in this case, there are about 10 steps within each iteration as opposed to what I had the previous case, which was eight, so a few more steps in the iteration", " But it's really the number of iterations that matter, 1,000,000,000 versus 30", " Hey, I'll take 30 any day", " So what we're really saying is do we care whether it's 1,000,000,000 or 8,000,000,000 when we're comparing it to whether it's 30 or 300, and the answer is no", " What we really care about is the growth in the size of the problem", " It's the size that matters and so those multiplicative factors don't concern us very much", " And what that, then, says is, given that it's the difference in the iterations through the loop that matter, we're going to drop the multiplication factor", " It's probably not particularly relevant", " And so we're going to focus on measuring complexity as a function of the input size", " We'll focus on the largest factor in whatever expression we write that captures the number of basic steps, and we're going to be mostly concerned with the worst case scenario", ""], "ky6rSZOoBws": ["NTA"], "Mdxr2ooxLfA": ["NTA"], "-VjpRFaz5f4": ["Eric Grimson: I want to show you a visualization that gives you an idea of bisection search", " Just to give you a way of thinking about how this actually works", " So imagine I have a sequence of sorted items, like these right here", " What does bisection search say? It says I'm going to start by looking at the middle element", " If I'm lucky, it's the thing I'm looking for", " If not, I can use the difference between what I'm looking for and that element to decide that it has to be in the lower half", " And so I can instantly take these things and ignore them", " Having done that, I'm now going to look at the middle element of what's left, and say is the thing I'm looking for there? If I'm lucky, it is", " If not, I'll use again the difference between what I'm looking for and that element to decide which half I can throw away", " For example, might be able to toss those away", " And then I can look here and eventually decide whether I've got the thing I'm looking for or not", " The idea is that on each stage, I can take half of the remaining things and ignore them", " Throw them away, which makes this a very efficient way of doing the search", ""], "j9as5xwUwA8": ["In this eighth lecture we're going to talk about how to measure the complexity of different algorithms", " We'll give you a model of what we mean by complexity, how to estimate how much time a computation will take for an arbitrarily large input argument", " Our goal is not to estimate actual time, but rather to reason about different classes of algorithms and their inherent complexity", " We'll use this idea to introduce a range of classes of algorithms from constant to linear, to more complex classes, such as polynomial and exponential", " At the end of this lecture, you will be able to categorize the complexity of algorithms, and especially to compare the costs of decisions you make in designing an algorithm", ""], "SQUNkr4bQyQ": ["Well, what we have is a bunch of observations that we made with our experiment", " You can see them here plotted as the blue points", " And what we'd like to do is to somehow discover the most likely line that represents the theory that we hypothesized that explains how the spring works given the observations that we have", " So what we did is that, for a particular force that's being applied, we have the notion of adjusting the parameters of our prediction to come up with a particular prediction", " And what we'd like to do is to adjust those parameters so that the prediction is the most likely one given the observation that we made", " And we discover that the difference between the two of those observations and the prediction we described as the error", " So the likelihood that the prediction is the right one is sort of determined by the size of the error", " So we take the i-th observation and we compute the error by subtracting off the i-th prediction", " And so this is the likelihood here of such an error occurring", " And the likelihood gets bigger the smaller the error is", " And we saw that on the previous slide, that small errors are much more likely than large errors", " And what we'd like to do is to now say, OK, well, I have many such observations that I've made", " And the likelihood of making all those observations will be, like with probabilities, the product of all the individual likelihoods", " So if I'm going to go off and look at the likelihood of each observation, what I'm going to do is to then multiply all those together", " And here's what my job is going to be", " I want to choose the parameters of my prediction", " So in this case, it would be the constant 1 over k", " That's the slope of the line", " I want to choose the slope and then the intercept at the line such that that particular choice of parameters maximizes the likelihood", " So I want to maximize this product", " So we want to maximize the product of the likelihoods of the errors", " So that will actually be the same as minimizing 1 over the product", " So if we want to minimize this product of the likelihood of the error, so 1 over the product", " So let's work on that a little bit", " Let's actually start by taking the log", " It turns out that whatever parameters will minimize the 1 over the product will also minimize the log of that expression", " So let's take the natural log, natural log Ln", " And so the natural log of 1 over this product of-- well, let's see", " So the natural log of 1 over something is minus the natural log of the product", " And the log of the product is the sum of the log", " So we basically all do the same summation here", " And now what we want is the natural log of this error", " And I'll write it out this time", " Observations minus the predictions", " OK", " So the likelihood of the error", " So we're still trying to minimize this", " That's our goal", " And now what we're going to do is take advantage of our knowledge about what this error, the likelihood looks like", " So we're going to use our knowledge to expand this further on the next slide", " So just carrying on from the previous slide, we're going to want to minimize this sum, which is the natural log", " And now I'm going to go off and write it in the likelihood of the error", " So it's, 1 over 2 pi sigma squared", " And I'm just using the formula here for the normal distribution", " So this will be e and this will be minus", " And now the error itself here was the observed value minus the predicted value squared, all over the variance of the errors", " OK", " So that seems pretty straightforward", " Let's go ahead and simplify that", " So I'm going to take care of the minus sign here as I do the simplification", " So let's see", " The natural log of a product is the same as the sum of the natural logs", " And the natural log of 1 over something is minus the natural log of the something", " So we'll use that minus to cancel out some of this", " So this will be the same as the natural log of the square root of 2 pi sigma squared, plus-- I'm going to move this minus sign again in-- minus the natural log of this guy, which the natural log of e to the something is something", " I'll take care of that minus sign", " And so this will be observation minus the prediction squared, all over sigma squared", " OK", " And we're going to be wanting to sum all those up", " So this is the same sum as before", " And we've just used the minus sign and expanded out the log a little bit", " Now let's observe that some of these terms are constant", " This is a constant, as is this guy", " He doesn't change", " The error processes are sort of stable and their statistics are stable as we're making our measurements", " And so what we discover is that this guy here, particularly if we're doing a minimization problem, this is all proportional", " And I can just get rid of the constants", " They won't affect the minimization at all", " The same choices for the parameters of the prediction that minimize this equation will also minimize this equation", " So I'm just taking out all the constants", " We don't need them here to help us with our minimization problem", " And I end up with that, which is sort of a magic result in the business of processing data points", " This is what's called the Sum of the Square of the Errors, or SSE for short, Sum of the Square of the Errors", " And if we minimize that, then we'll have made the most likely choice of the parameters", " If we choose parameters such that we minimize the sum of the square of the observed errors, then that will be the most likely predictor for the observations that we have", " And we actually have sort of a nickname for this guy", " We often call this sort of as shorthand, the least squares", " Finding the values of the parameters for the prediction that minimize the sum of the square of the errors is a very common thing to want to do to data points", " And in fact, pylab has a built-in procedure that will do that for us", " It's called polyfit", " Let me show you how to use it", " The first example here is finding the parameters for a linear predictor", " So we're making the assumption that the prediction in this case of the extension of the spring is based on a linear relationship between the mass and the observation that we make", " So we're asking polyfit to find us the parameters a and b", " So it's going to find us those given in our case a bunch of forces that we applied to the spring and a bunch of observations that we made", " And its job is to find the best such set of parameters that minimizes the sum of the square of the errors", " We can also asked for fits with higher degree polynomials", " Here's one that does a parabolic fit", " So this would be a second-degree equation", " Here we're assuming that the relationship between the prediction and the observation, or the basic parameters and the observation is governed by a second-order equation, so ax squared plus bx plus c", " So given, again, the forces that we've applied and the observations we made of the extensions, we could get a second-order fit", " And in fact, if we set this parameter to 3, we would be fitting a cubic equation, so forth and so on", " So our next step is to actually use these routines and try to find those parameters given the observations that we made", ""], "2e6pE07JJ8M": ["ERIC GRIMSON: We've now seen a bunch of examples of recursive functions", " Seen some of the power of them", " We keep coming back to this idea of break a problem down into smaller versions of the same problem", " Really great way of trying to tackle a problem", " We're going to do one last thing", " And that goes back to when we ran fib", " When we ran Fibonacci, we might have noticed that as we made the arguments larger and larger, it slowed down", " Which is not surprising", " It's calling itself multiple times", " But suppose we wanted to actually count the number of times that fib called itself recursively", " Multiple ways of doing it, but one of the ways in which we can do this is to use what's called a global variable", " What does that mean? Well, so far, all the functions have communicated with their environment strictly through their parameters and their return values", " If it's when we call a new function, it creates an environment with some parameters passed in", " It does some work internally, and it returns a value as the value of its response", " We can make a variable or declare a variable to be global", " And what this means is that the name is defined at the outermost scope of the program, rather than the scope of the function within which it appears", " It's global because it's going to appear up at the top level", " It's going to be part of what we want to deal with when we're interacting with, for example, the Python shell", " As it notes here, this can be a bit dangerous", " And we'll talk about that in a second", " But let's just look at how we might do this", " So, here's the idea", " We're going to call this a metered version of Fibonacci", " It has much the same form as before", " There is the recursive call, just as we had before, using a different name, of course", " But we do two things", " Right here, we make a declaration that says the variable numCalls is global", " That means it's going to be bound way up at the top, at the highest-level environment", " Inside of fibMetered, we're going to actually change numCalls", " This says every time we call fibMetered, we're going to increase that global variable by one", " Great", " So that's going to count how many times it's called", " We can test this with a little test script here", " I'm going to run fib for some number", " I'm going to have i roll over from 0 up to n", " And notice what I'm going to do", " Each time I go through the loop, I'm going to again say numCalls is a global variable", " It's defined up in that top-level place", " And I'm going to set it to zero", " That is going to have the effect of in the global environment changing numCalls to zero", " And then I'm going to actually do some work and print up some results", " I'm going to do the work of figuring out what Fibonacci is", " The call to fibMeter will, every time it calls it, change numCalls by one", " And when I'm done and when it returns, I can print out how many times was that actually called", " OK", " Let's see what happens if we do this", " I'm going to go over and start up over here inside of my IDLE environment", " And if I load that in, let's actually do a test on fib", " And this put means we're going to do up to five", " And it now tells us, oh cool", " When I call a fib on zero, the answer is one", " It was called one time", " Makes sense", " When I call fib on one, the answer is one", " It was also called one time", " We knew those were the base cases", " And then you can see the responses as we move up", " So let's make this a little bit bigger", " Let's do testFib-- oh, let's make it up to 20", " Then we'll see what it does here", " You see it's moving pretty quickly", " It's starting to slow down a little bit", " But we're actually now calling testFib in that metered form", " And it's showing us how many times it's called", " Also notice, if you look at the numbers, it's clear that we're resetting numCalls each time around", " And that, if we go back to our slides, came from right here", " Each time through the loop and testFib, we reset numCalls to zero up in that top environment", " So that when we go ahead and call fibMetered, it is starting from zero and doing a count for each time it calls recursively within itself", " A nice tool", " A tool that's really kind of handy, and something that we'll come back to, because it is a way of being able to keep track of some things", " But I want to finish with a couple of comments", " First one is use it with care", " Putting a variable as a global variable is destroying the locality of the code", " One of the beautiful pieces about recursive code is all of the function call contains within it all the information it needs", " The parameter's passed in, it does all the work internally, locally, and it simply returns a value back out", " That is an elegant way of being able to not only think about what's going on, but to be able to deal with the code", " Once we have global variables, they can be modified or read in a wide range of places", " And that's going to make it really easy to break the locality, especially if someplace outside of the function we're dealing with makes a change for global variable and that affects the computation inside that local call to a procedure", " This is going to allow the potential for introducing bugs", " And most computer scientists will be very strong about arguing that one should not use global variables if at all possible", " It is much better to encapsulate the computation locally", " But here's an example where we're metering things, where having a global variable can be really handy", ""], "CJh-mscFZgU": ["ERIC GRIMSON: So now we have lists-- ordered sequences of arbitrary elements, but they can be mutable", " We've already seen some operations on them", " But there's a lot of other operations that we'd like to have and we do have on lists", " So for example, we can iterate over them", " What does that mean? It says inside of a for loop or a while loop, but certainly inside of a for loop, I can have a call with a loop variable that's iterating over that structure", " And let's look at an example of it", " So I've already bound that variable Univs", " And so this says I'm going to let e, in turn, be each element in Univs", " And I can do things like print up some information about them", " And since each of those elements is itself a list, I can have another loop, where I loop over e, letting u be each element inside of there", " Then I print something out", " And if we just go over to my idle screen here, I'm just printing out-- so what's the value of Univs, what's the value of Univs 1", " And then, at the bottom, you can see that loop, where, in fact, I print some information and I loop through each of the pieces inside of that structure", " As with tuples, what that iteration is doing is it's setting up an internal index, starting at 0, and walking down each element of the list till it gets to the end of the list, with the index pointing to each element in turn, letting me extract and do something with it", " And that something might be, in fact, printing or looping over that interior structure", " So I've got iteration", " This sounds pretty nice", " What else do I have? Well, we've already seen that I can add things to lists", " And I did that with append", " Now again, if I go over to my idle shell, I can do Techs", "append", " In fact, before I do that, let's just remind you", " Techs is a list of MIT, Caltech, and RPI", " And suppose I say I'm going to do Techs, and I'm going to append to it the Ivys", " If I now look at the value of Techs-- a-ha-- as I would have expected", " Remember what we said about append", " It's a method, which is why we've got that funky little period there", " And it's a method that, in fact, has a side effect", " It mutates", " It causes a side effect in which, in particular, I'm going to take Techs as a list, and I'm going to change the end of it to add a new element in", " And this new element, in this case, was itself a list", " So the structure is now a list four-long, the first three elements of which are just strings, the fourth element of which is a list", " And that's what got printed out there", " Now, suppose I said, that's nice, but I don't want to have a whole list hanging off as appendage", " I'd like to have a list with everything at the same element", " I'd like to flatten them", " In that case, what I'd really like to do is to take two lists and concatenate them together", " It's called flattening", " And we can do that using the plus operator", " So I'm going to reevaluate these pieces again", " Let me just bring them back into my environment", " And I'm running through that loop, because now what I'd like to do is just go back to where I have with Techs before", " There's Techs", " And I'm now going to ask flat to be a name for what I get by concatenating Techs and Ivys together", " The plus sign's saying just do a concatenation", " And if I look at flat-- ah, nice-- it is a sequence, a list of elements, all at the same level", " So append sticks something in at the end of the list", " Addition or concatenation puts copies of two lists together", " And notice it creates a new list", " And to see that, let's see what happened with Techs", " Ah, yes", " It has not changed, and neither has Ivys", " That's actually important", " And so to look at that, what that's really saying is that in the case of append, I am mutating", " I'm changing one of the lists", " In the case of concatenation, I'm creating a new version of those lists", " I'm literally creating a copy of it and then adding a copy, if you like, of the second list to it, as well, which allows me to separate out different ways of thinking about how I might want to manipulate lists", " So I can mutate when I need to, but I might want to just make copies when I need to", " And I can do that", " Let's look at one last example", " And this is going to look at an example of both where things go wrong when I'm iterating over lists and how I get around that", " And for that, I'm going to bring up a new piece of code", " And the piece of code here is going to be something that's going to look at removing duplicates in a list", " So the idea is I want to have two lists", " And I'd like to get back a list with just those elements that only appear once inside of the list", " So I could write a little loop to do it", " Here it is", " I'm going to remove duplicates", " Now I have two lists, L1 and L2", " I'm going to loop over L1", " And I'm going to say, for each element in L1, if it's in L2, let's just remove it from L1", " And again, remove is a method", " There's the dot", " Don't worry about the details of it", " But it basically takes the list L1, takes the first instance of that element e1, and takes it out of the list by mutating", " So let's look at what happens if we do this", " And in fact, we can load this up into our idle shell", " And if I do that, let's look at what happened here", " In fact, let's look at it in a little bit more detail", " L1 I'm going to start off as the list 1,2,3,4", " 3, 4", " L2 is the list 1,2,5,6", " And I'm going to remove the duplicates between L1 and L2", " Ideally, I would like that to be just having the list L1 be those elements that are not duplicated in L2", " But if I, in fact, look at what L1 is, printing it out, I get the list 2, 3, 4", " So why does that happen? Well, let's look at that in a little bit more detail, as well", " The problem is that inside of the loop, Python is keeping track of where it is in the list using this internal counter", " We already said, as it iterates over L1, it's keeping a little index that says where it is", " When I decide to remove something from L1, I'm going in and changing the list", " But I don't adapt the counter", " So I can literally change the list by one, which means the counter is now pointing to a different place in the list, because if I shorten the list by one by removing something from the front, the counter, if it was pointing, for example, at a second point in the list, is now pointing at the third point in the list", " So when we mutate a list, we change its length", " But Python cannot adapt to that", " And obviously, that's a problem, because it doesn't do what we'd like", " So when we are doing mutation on lists while iterating over them, that's probably not a good idea, at least not on the list we started with", " So how could we do this better? Well, let's clone", " And what does clone say? It says, let's make a copy of the list", " And I can do that with this very simple form here", " If I take the list L1 and I say, in square brackets, just a simple colon, it says, give me all the elements from the first to the last, but make me a copy", " And now I can loop over L1Start, but mutate L1", " So this is changing L1, but this is looping over a copy of L1", " And if I do that, which was the second piece of code I had there, that's why, in fact, it will print out just 3, 4", " It removes the 1 and 2 from L1 because those are duplicates, but it does it without getting confused about where it is inside of pieces", " And so what this says is that we want to use a copy of L1 as L1Start", " And notice, by the way, I actually have to make a copy", " If I were simply up here to have said instead, let's use L1Start just to be L1 rather than L1 with that funky thing at the end, it would not have worked", " Why? Because if I say this form, L1Start points to the value pointed to by L1, which is the list itself", " And I'm back to the first state", " By using L1 with the colons, I literally make a copy", " And now I can walk down a copy checking for duplicates while changing the original list itself", " So now we've seen properties on lists", " We can iterate over them", " And we can do it while mutating them", " And when we need to, we'll want to use clones to make copies of lists so that we make sure that we keep track of where we are inside of that structure", ""], "ftu1cc1A8q8": ["ERIC GRIMSON: I want to look now at one last example on doing some interesting things with graphs", " Part of what we've been trying to show you is how graphs capture a range of problems and some ways in which we can explore them", " We're doing it quickly", " We don't expect you to fully grasp everything about graph theory, but we wanted to give you a flavor of how graphs can be really valuable in solving certain kinds of optimization problems", " The last example I want to look at is something called a clique", " And you may remember this from middle school", " It has some of the same flavors", " There are some problems for which finding subgraphs or subsections of a graph can be important, especially subgraphs that are complete", " And what does complete mean? Complete means that for every node in that subgraph, it has an edge to every other node in that subgraph", " It's called complete because it has a complete set of edges", " Now that doesn't say the whole graph is complete", " It says, given a graph with some edges in it, we'd like to find what are the places in it that have portions that are complete", " Now there are lots of places where this is valuable", " Finding, for example, sets of people in a social network that all know each other is a simple example of this", " Finding subjects in an infected population that all have had contact with one another can also be really important-- for example, in disease control or in checking the spread of a disease", " Network traffic, network flow, can often be analyzed by using clique problems", " So this idea of finding a clique can be really valuable", " Just to show you an example", " Let's think about users in a social network", " For a given user, we'd like to say things like-- can I find the set of all other users that know this person and that also know everyone else in the group? What's the largest set of users like that? Or, having found the largest set, can I pull that maximal clique out and then find the next largest set? And in essence, partition the graph up into clusters or components of people that all know one another", " How might I do that? Well, we're going to get to that in a second", " But I want to stress this idea of using cliques actually is very valuable", " It's used, for example, in analyzing communications networks", " It's used to design circuits, doing layout", " It's used in computational biology to analyze gene expression data", " It's used by places like Google and others to analyze social networks", " And it's used by the Centers for Disease Control and other such places to do things like analyzing disease networks among infected populations", " So all of these are examples of places were cliques are of value", " And as I said, or hinted, already, for cliques we're particularly going to be interested in finding a maximum clique or a max clique", " A clique-- set of nodes in a graph that has a complete set of edges", " Every node is connected to every other one", " And I want to find the largest such subgraph", " Now there are some wonderful algorithms for doing this, some very efficient ones, but they're fairly complex", " And so for our purposes, we're just going to use the brute force method-- going way back to the beginning of this class where we talked about straightforward methods for generate and test if you like methods for doing that", " And what we can do here is the following", " We're going to first find all the subgraphs of a graph, all the different partial collections of nodes, if you like, in a graph", " For each one, we're going to test to see if it's complete, and then we'll just keep track of the largest one", " That will give us the maximum clique", " And we could then, of course, extend that recursively", " Once we've done that, we could pull those nodes out of the graph, remove them from the graph, and go ahead to find the next largest clique and keep on doing it", " Let's do that in the next segment", ""], "pflzzK47wEo": ["While the meat of the course is in this Courseware section, we have some other resources for you to access in the header at the very top of the page", " You are currently in the Courseware section, where most of the instructions and assignments will be located", " The Course Info section contains any announcements that the course staff would like you to see", " It also has all of the handouts associated with the course, including the syllabus and calendar", " If your course uses a textbook, you should be able to find an online version of the textbook in the Textbook section", " The Discussion section has a question and answer forum, where you can ask questions have them answered by the course staff or your fellow students", " The Wiki section is where all of the students in the course can keep their collective course notes", " Finally, you can see how you're doing in the course in the Progress section", " You can see your overall edX profile, including your current enrollment if you click on your username in the top right corner of the page", " You should also be able to change your personal information from this dashboard", " The next several videos will go into more depth on Discussion Forum usage, Wiki usage, and any course-specific features that you may need", ""], "pv1TnTohJo8": ["NTA"], "fwEyyCo5dxo": ["JOHN GUTTAG: Hello, and welcome back to 600", " We're about to move away from probability, but before I do, I can't resist looking at a probability question that has stumped many supposedly clever people, the so-called Monty Hall problem", " The problem is based on a television game show called Let's Make A Deal", " The show was popular in the 1960s and '70s", " Imagine that you're on that show, and you're given the choice of three doors, one, two, or three", " By the way, the people who were on the show dressed up in silly costumes in the hope it would attract the idea of the host, Monty Hall, who would invite them up front to play", " Behind one of the doors is a car", " Now, OK, maybe it wasn't this car in the 1960s", " And behind the other two doors are goats", " The contestant is asked to choose a door", " After-- let's assume you're the contestant-- after you have chosen a door, the door remains closed", " Monty Hall, who knows what is behind the door, now has to open one of the two remaining doors, and the door he opens must have a goat behind it", " After Monty opens a door with a goat, he will ask you, the contestant, to decide whether you want to stay with your first choice, say door number one, or switch to the last remaining door, in this case, door number two", " What should you do? Well, the audience will shout all sorts of advice, but you should ignore it and figure it out yourself", " The problem has been around for quite a time, and the literature suggests that most people get it wrong the first time", " In 1991, Parade Magazine published a correct solution to the problem, and approximately 10,000 readers wrote to claim that the magazine got it wrong", " By the way, among those 10,000 readers, 1,000 claimed to have PhDs", " I hope none of them were from MIT", " If you were taking this class at MIT, you would now have the opportunity to play the game for fabulous prizes", " Since you're not, you'll have to settle for my working the probabilities", " I'm going to do that in two different ways", " So let's look at the first way", " Assume that without loss of generality, you choose door one", " Now, Monty will open another door, and again, let's assume without loss of generality, he opens three", " And there stands the goat", " When the game started, it was equally likely that the car was behind door one or two", " Because we know it wasn't behind three", " It was placed at random", " So, one and two are equally likely", " Therefore, it doesn't matter", " You can switch or not switch, and the odds will be the same, 0", "5", " Sound plausible to you? It does to most people, but in fact, the argument is flawed", " Let's look at the problem a different way", " Again, you're the player and you make a choice", " With the probability of 1/3, the choice is correct", " That means that if you could choose the other doors, the probability of the goat or the probability of the car being behind doors two or three, the remaining one is 2/3", " So with probability a third, you are correct, and the car is indeed behind the door you chose", " But with probability 2/3, you were wrong, and the car was behind one of the other doors", " Now comes the key moment", " Monty opens the door that he knows does not contain the car", " Note that this choice is not independent of the choice made by the player", " The player has made a choice, say door one, forcing Monty to choose two or three", " He does not want to open the door with the car, because then the game would be over, so he opens the other door", " So in fact, by switching, the contestant has a 2/3 probability of winning", " It's tricky", " When we work probabilities, we always have to think about whether or not we are looking at independent events or related events", " To drive this point home, I want to look at some code that simulates the game", " So, here's the game", " I'm going to simulate it for 100 trials", " And I'm going to pass in this choose function, and we're going to look at two different ways that we might choose which door to open after the contestant has made a choice", " We'll look at the number of times the contestant wins-- the number of wins by not switching-- we'll look at the number of times a contestant wins by switching, and the number of times a contestant doesn't win it all", " The door will be behind one, two, or three, and the guests will have to be one, two, or three", " So for t in range numTrials, we first choose a place to put the car at random", " The contestant then makes a guess at random", " We then call the choose function, this one, which takes as an argument the guess and the door behind which the prize exists, because remember Monty knows that, and it makes a choice", " If two open is a prize door, then there's no win", " Of course, if we play the game according to Monty Hall rules, this will never happen, because he won't open the prize door", " But we're going to explore the other option where he chooses at random", " Otherwise, if the guess is the prize door, the contestant wins by sticking", " Otherwise, by switching", " And then, we'll return the number of stick wins and the number of switch wins", " Here are two possible choose functions", " The first one is the one that is used on Let's Make A Deal", " Essentially, Monty is just choosing the door that the contestant didn't choose and that has a goat", " The other possibility is a random choice, where Monty will say, if the guest door is one, we'll open either two or three", " So perhaps, it might be the car", " Otherwise, one or three, else one or two", " Finally, we'll have a function that displays the results", " I'm showing you this, because it's using yet another pylab plotting function, pylab", "pie, which produces a pie chart", " OK", " Let's go over to the code window and run it", " So, we'll first run it the way the game works calling it with Monty choose, and we'll display it", " And we'll produce another figure in which we make the random choice, and we'll display it", " Well, notice that if we play by the game rules, indeed, it's the case that you double your odds by switching, shown by this pie chart", " Course since there's randomness, it's not exactly 1/3, 2/3, but pretty close", " On the other hand, if we play the game randomly, then in fact, it doesn't matter, because an independent decision is being made, and indeed, the odds are unchanged by switching", ""], "i8fuPLQCW5A": ["NTA"], "VAAia4PpxZc": ["LARRY RUDOLPH: My name's Larry Rudolph, and I'll be your instructor for this course, Introduction to Computer Science and Programming", " From MITX on edX", " This course will teach you how to use computation to solve real world problems", " It's aimed at students with little, or no, prior experience in programming, but with a desire to learn how to use computation to solve problems", " It is aimed at students who have no, or little, prior experience in programming, but do have a desire in how to solve problems using computation", " It's not a programming course", " Although you will learn how to program", " It's not a mathematics course", " Although you will use mathematics", " And it's not a theory of algorithms course", " Although you will learn how to appreciate really clever algorithms", " 600x is a challenging and rigorous course", " It's an MIT course", " As such, the lectures and text will appear clear, logical, orderly and understandable", " When you do the finger exercises and problem sets, you may find that they are challenging", " Why? Because there's a lot of material, and it's going to take a while for it to become clear, logical, orderly and understandable in your brain", " I've been doing research in high performance parallel processing for many years", " I started programming over 40 years ago when I was in ninth grade", " Recently, I founded a company called ReDigi, which is a marketplace for used digital goods", " It's taught me how to communicate with a large customer base that's mostly silent", " This is all in addition to the fact that I've been teaching computer science courses for the past 30 years, both at MIT and at other universities", " Halfway through the semester, we'll have a town hall meeting", " It'll be your opportunity to interact live with an MIT faculty member", " By that point, you should know a lot about programming and computer science", " And I look forward to very interesting interactions", " Most, if not all of the lectures, are by professors Grimson, Guttag and Terman, and are the result of years of refining this material while teaching it at MIT", " I, however, will remain behind the curtain along with my great staff ensuring that everything runs smoothly, and the course is a success for all participants", " We want to make sure you have all the tools to succeed in this class", " Our staff will be in the forums everyday to answer your questions", " But you, too, can answer each other's questions", " The moment that you understand a difficult concept, you are the perfect person to answer other people who have yet to understand that concept", " Remember, the best way of learning something is by teaching", " Here are some tips for your success", " 600x is fast-paced", " Please try not to fall behind", " As soon as the videos are released, watch them", " As soon as you're finished watching your video, do the finger exercises", " Get started on the problem sets as soon as possible", " We try to keep things into bite-sized chunks", " So there's no reason to postpone them", " We practice the philosophy of learn by doing", " The finger exercises may not be trivial", " The problem sets may be challenging", " Not everything is in the preceding video", " You are going to have to find the solution", " How do you do that? Read the text", " Re-watch the video", " But mostly, experiment", " Play with the interpreter", " Type different examples", " Computers don't care about how many times you make the same mistake", " Computers do not get bored", " Computers do not yet have feelings", " And most of all, computers are not judgmental", " Please complete problem set one as soon as possible, even before watching the first set of videos", " You'll find the interpreter is your friend", " Use it as much as possible", " Type whatever you want into it", " And don't worry about making mistakes", " You'll learn by doing", " Again, this is a course in experiments", " The more you type in and the more mistakes you make, the more you learn", " If you're still confused after consulting the textbook and trying the experiments, then search the web or search the forums", " Try not to move on until you understand the solution", " If you don't understand the solution, post to the forum again", " Now stop listening to me, and go learn some computer science", ""], "j-d7-5lWcT4": ["Eric Grimson: OK", " We've talked about designing a test suite", " That is finding a set of samples of inputs and expected outputs, that we can use to test whether our code's doing what we expect it to or not", " And we talked about both black-box testing, and glass-box testing as ways of designing test suites", " What happens when we're ready to actually start doing the test? What should we do? Here, and we're going to do an example a little bit later on in this lecture, here what we're going to do is alternate between two important parts of testing", " We're going to start with what we call unit testing", " That says take a module, a function for example, and check it", " Check it on input values whose results we know what to expect", " Run the suite basically on the module to make sure that the module runs well", " This will catch algorithm bugs, that is places where I got a bug, either in how I encoded the algorithm or in terms of how I thought about the algorithm", " Once I've checked the modules, I'm going to move on to what we call integration testing, which is to check that the system as a whole works correctly", " If I've got multiple functions that are interacting with one another, I want to make sure that even if the modules do the right thing, that the whole system does well", " And this will typically catch, what we might call interaction bugs", " And by that I mean places where an incorrect value is being communicated to another function", " Or an assumption about input is being broken as I move back and forth", " And once I've done that, I want to cycle", " I want to go back around, and having done integration testing and fixing things, go back and check the modules as unit testing, and then check integration testing", " And cycle until I'm convinced that I've caught all the bugs that I'm likely to find", " So we're going to think about how we deal with doing unit testing and integration testing", " Now there's another piece of testing that's really useful to do", " And that's to build a test driver", " What does that mean? Well, drivers are code that actually set up to do the testing for us", " So I'm not just typing things in by hand", " The idea is that in a driver we're going to set up an environment, and what we mean by that is we're going to set up a piece of code that creates bindings for global variables , data structures, other pieces that I need to do the testing, is then going to take that test suite-- that sequence of inputs-- and run the code in each one, and save the results and report back out", " So a test driver is basically a piece of code that does the testing for us", " Builds the environment, takes and implements the test suite, and runs it", " Nice thing about drivers are that they basically simulate parts of the program that use the unit being tested", " So they're going to do the actual simulation of the testing that we want", " Now if there are interactions with other pieces of code, what happens if we haven't already debugged those? And there we can often use what's called a stub", " A stub simply simulates parts of the program that are used by the unit being tested", " And when I say simulate, if I've already built the code and it runs, great", " But even if I haven't, I can still get the same effect", " For example, by building a table of input-output pairs, and using that to simulate the behavior of that particular piece of code", " The advantage of a stub is that it's going to allow you to test units that depend on software even if you haven't written it yet", " Maybe not be able to test everything", " But remember since I'm building a test suite with particular set of cases, I can basically say if this code was there, here's what it should do", " And that stub will let me go back and actually fix, or test rather, the piece of code I'm testing inside of the driver", " So when I get to testing in a second, but what does it say then", " It says, having built a test suite I start with unit testing", " Having tested all the units I'm going to go to integration testing", " And I'm going to cycle back and forth", " But one of the key things to remember is, when I'm done debugging and I think my code has been corrected, it's really important to do what we call regression testing", " That is go back, and check that the program still passes all the tests it used to pass", " Even though a piece of code may have run correctly before, because I've changed things there's no guarantee I haven't accidentally messed something up", " And so a really good practice is to go back and re-run the tests I've run before to make sure that they still work", " And that regression testing will ensure, in a sort of principled way, that the tests I'm running are actually running correctly", ""], "FP4Hw1IEWCA": ["PROFESSOR: Hmm, it looks like every time we do a calculation involving a new mass and its corresponding displacement, we're computing a slightly different value for k", " Does that mean that the spring constant is actually changing a little bit every time that we hang a weight on the spring? Well, probably not", " It looks like there's a process at work that's causing our measurements to be slightly off every time we make one", " A good first step whenever we're trying to figure out what's up with our data is to plot it, to look at it visually, and to see if we can spot what's going on", " In order to figure out what's going on, we're going to have to look at the data", " And here's a couple Python procedures to help us do that", " The first procedure here, getData, its job is to read the data in from a text file where we've entered the data", " So it opens the file, and the first line of the file is just a header line that describes the format of the data in the rest of the file", " We don't need that here, so we'll read in that line and discard it", " And then, for all the other lines in the data file, we'll read each of them in", " Each line comes in as a string", " And then we're going to take that string and split it into substrings that correspond to the non blank portions of the line", " So the first substring is the first non blank portion of the line, which will be the data measurement", " And the second substring is the second non blank portion of the line, which is the mass measurement", " We then go off and convert those two strings into floating point numbers, and append them to the appropriate list that we're using to accumulate the results", " And when we're all done, we return the masses and the distances in two separate lists", " The plot data routine is now takeover, and its job is to plot the data", " So it goes off and first reads in the data", " And the reason that we've separated the reading in of the data, the I/O, from the analysis, or, in this case, the plotting, is in case the format of the data file changes in the future, we'll only need to rewrite the getData portion of the Python procedures", " The first thing we do once we get the data is to go off and convert it into the pylab array data type, a very handy data type for doing numerical manipulation", " And here we see an example of how handy it is", " On the next line we want to multiply each element of the xVals array by the gravitational constant", " In other words, what we're doing is, we're busy converting the masses that we measured into the forces that they applied to the spring", " And this statement here, an array times a constant, will multiply each element of the array times whatever that constant is", " The rest of the procedure goes off and then creates a plot, plotting the forces applied against the distances measured", " The data points will appear as little blue circles, so the b means please make it blue, and the o is please make them a circle", " Let's run it and see what the data looks like", " Here's the results, we can see we get the sort of plot that we might expect", " The x-axis is the force that was applied to the spring", " The y-axis is the displacement we measured, and here are all the data points that we measured from applying everything from the 10th kilogram up to the full kilogram weight", " Let's see what we can make of that", " So is this what we were expecting? Well, our hypothesis tells us that this should be the relationship between the weight and the extension that we measured", " That implies that if we sort of solve this for the extension, that we expect it to be mg, so this guy here is the force, divided by the spring constant k", " So that means that what we expect, also all the measured points to fall on a line with slope 1/k", " Graphically, what that would mean is that we'd expect to find some line that had all the data points on it, and the slope of this line should be the inverse of the spring constant", " At least that's what this equation here is telling us", " Well, that's not quite what we got", " Let's see if we can figure out what went wrong", " So what did we expect was going to happen? Well, we have this theory", " So we have this notion that there's a linear relationship between the force that we apply, so here's a particular force, F sub i, and the observed extension", " So we have this prediction", " So this will be our prediction for the i-th force and our prediction for what the offset that should be is equal to the force divided by the spring constant", " So this is a line of slope 1/k", " Well, what actually happened is, we have some measurement up here", " And that measurement differs from the prediction by a certain amount", " So here's my i-th observation", " And there was clearly some sort of error that crept in and so we have the sort of model that what really happened was here", " But because of some error in our process, we actually made a slightly different observation", " Maybe we'll make some progress if we think of it that way", " So here's the error, and that's a difference between the i-th observation and the i-th prediction", " So the question is, what can we say about what our expectation is for those errors that are creeping into our measurements? In many experiments in the real world the errors that we're seeing are actually the accumulation of many, many, many small random effects", " For instance, a position measurement, such as the one we're taking, might be affected by the sums of all sorts of little vibrations, the footsteps in the room, machinery across the room, machinery down the hall, that's causing a small vibration which causes our error measurement to be off somewhat", " Let's sort of see how that might affect our experiment", " So what I want to do is to model errors", " So we're going to model the errors that we're going to measure, basically, as random numbers", " So this is the assumption that the errors aren't really related directly to the experiment we're making", " They're effects that are added on to the results of the experiment", " And just to sort of see what's going on, I'm going to show you a probability density function here for a particular class of errors which are distributed between-- so the errors, basically, will lie in the range between +1 and -1", " So this is basically between -1 and 1", " And the idea is that, with this particular probability density function, that the errors are much more likely to be small than they are to be large and close to one", " So let's run a little experiment, and here's our experiment", " First thing we're going to do is to draw 100 numbers from that probability distribution", " So we can write some Python code that says, using this probability density function, please give me a random number between -1 and 1", " And it will choose 100 such numbers", " Then we're going to sum them up", " So each one of those numbers that we draw will represent a small error from some random source", " And it's really the cumulative effect of all those errors that we'll want to do", " So we're going to sum them, and obviously sort of the smallest value we should get should be like -100", " And at the other extreme, we might get something as big as +100 as the sum", " We're actually going to see what the distribution looks like", " Having done that particular sum, we'll save it away in a histogram and repeat 10,000 times", " So we're going to build a histogram of what all the sums look like", " And we're going to do it for 10,000 such experiments", " Let's write a little program and see what the results look like", " Here's a Python procedure, testErrors, that will let us run our little experiment", " What testErrors does is, for the number of trials that we've asked for, in this case the default value for trials is 10,000, it will go off and select a certain number of points, in this case 100, from a particular probability distribution, in this case a triangular distribution that goes between -1 and 1", " So that's exactly the distribution that we graphed on the slide", " It will then sum up the results of each of those random selections, and then it will keep a list of all the sums that it creates for all 10,000 trials that we're doing", " When we're done, we're going to plot the results in a histogram using the handy hist function from pylab", " And let's see what we get when we do it", " So I'm going to save this out and run it", " Of course, with 10,000 trials of 100 points each, it can take a little time to run", " And here we see the results", " What we have-- what this little graph is telling me that, of the 10,000 trials, some 650 of them resulted in a sum which was exactly 0", " That's a little surprising, but maybe not too surprising", " We had pretty much an equal chance of having a negative error and a positive error, and we expect many of the errors to end up canceling each other out", " And that sort of what we see in this diagram", " The highest probability of the sums are grouped right around 0", " And then that probability drops off dramatically as we get into situations where many errors would have had to have been on one side of the distribution, which becomes increasingly unlikely as the number of trials grows", " So what we're going to do now is to think a little bit about what we see here", " So what we saw from our little experiment looking at the accumulation of many small errors is that the net effect of all the errors being added together has a probability distribution that looks like so", " And that's a curve that we've seen many times", " So the result is that the probability of all of our sum of the errors, that probability distribution converges on the normal distribution as the number of trials in our experiment increases", " So if we, instead of doing 10,000 trials, we had done 100,000 or a million trials, we would start to see that the histogram would trace out very precisely a normal distribution", " Sort of amazing", " Another observation that comes to us courtesy of the central limit theorem", " And that basically tell us that we get the same result no matter what error distribution that we choose", " We chose a triangular distribution, but we could have chosen a uniform distribution, or a Gaussian distribution, or, in fact, any distribution that has a finite mean and variance", " So the only requirement is that we the distribution have a finite mean and variance", " And if so we'll get the same conversion to a normal distribution, if we look at the accumulated sum of many small errors, and in fact, they don't even have to be identically distributed", " So what's sort of amazing is that if our errors that we're seeing in our experiment are the result of the accumulation of many small random processes, we can actually say something about the probability distribution of those errors", " Let's just quickly remind ourselves what the normal distribution looks like", " Here it is over here, plotted for a bunch of different values of the variance sigma squared", " The distribution is completely characterized by two parameters", " One of the parameters is the mean", " And that's the central axis of the distribution, in this case, we're plotting normal distributions with a mean of 0", " The other measurement is the variance, which is a measure of the width of this curve", " With those two factors in hand, we can actually write a little equation that describes the PDF, the Probability Density Function, for a normal distribution", " So that's f(x) and we have a normalization constant, which is 1 over the square root of 2 pi sigma squared, and then we get the exponential part", " So it's E and it's x minus x minus the mean squared all over sigma squared", " You can see what that means, that is the argument x gets bigger, the probability associated with that becomes exponentially smaller", " There's some special names we apply", " If mu is equal to 0 and the variance is equal to 1, we call that the unit normal or maybe the standard normal distribution", " So let's put it all of it together", " So when our observation errors are due to the accumulation of many small random processes perturbing the measurements ever so slightly, we can say something about the likelihood that the error will be of a certain size", " And we'll just use our information about the errors being normally distributed to write the following formula", " So this is really just the information from the previous page, except here I've made the assumption that the mean of 0, which implies that the errors balance out over time", " And that's typically true with many error processes", " Now this is actually a really neat fact, it basically tells that large errors are basically much less likely, I mean, exponentially less likely, than small errors", " And we're going to use that fact, now, to go back and finish the analysis of the data points", " But it was really important to sort of establish how the measurements we're taking are differing from our expected predictions", " And now, we're going to use this information about this probability distribution, this likelihood distribution, to help us figure out the best way to sort out the actual data, or the actual predictions, from the observations that we made", ""], "kpa7QyOtIHI": ["TA: Hi", " Today I'm going to be talking to you about default values and keyword assignment", " So what you see on the right here is a fairly silly complex function that I've concocted just for this particular exercise", " So we call it complex function because it has so many of these variables that it needs in order to function", " Something, another thing, number of silly walks, and so on", " It's a whole lot of variables, and believe me, if you do a whole lot more programming, either in this class, or when you go out in the world of wonderful programming stuff, you'll probably have to come up with your own versions of complex functions that are taking a whole lot of variables as well", " So the problem with complex functions is that when you call it, you have to specify a whole lot of things", " And sometimes it can get confusing", " Let's say that something, I want something to be a cat, and another thing to be a dragon", " And number silly walks will be 100, and the cans of spam to be 20", " And that thing should be random, sort of random indicator is true", " And I love furry things, so furry should be true", " And frogs found, let's say we found just one frog", " And unfortunately, the doomsday device is not complete", " So that's false", " So you call that, it responds with the output of the function", " If you give it all those variables, and that looks all nice and good", " But the problem is what happens when you want to change something? You have to type in the whole thing in over again", " Complex function, and let's say t and dog", " 10 silly walks", " Let's see", " 20 cans of spam, let's say that everything else is the same", " So that was a whole lot of work, and a lot of painful stuff to try to change those three first things", " And that's kind of painful, but what can you do? Well, I guess we could try to simplify things a little", " If all we're going to change is just these first three things, we could make a new function, like the one below over here", " Where the user is only required to specify the first three things, and everything else is pre-specified for the user", " Wonderful", " You've made life simpler by making a simple looking function", " Let's try it out", " Simple function", " This time I'm just going to say t and a dog, and 10", " And things look better", " You don't have to type so many things", " You just have to type three things, instead of, I don't how many things that was", " But it was a whole lot of things", " So that was nice, but it comes up with a problem", " What if you needed to change one of these things? Like, let's say you wanted to change the cans of spam", " Instead of always being 30, you needed just this one particular time, you needed cans of spam to be two", " Then I guess you could just change it in the function definition, save it, reload it in Python", " And this, I'm just going to copy and paste it", " And then you'll find that indeed, the cans of spam is two now", " Well, that's a whole lot of work for your users of the function", " And fairly bad programming practice to have to change the definition of your function every time you needed to change a variable", " You ought to make it a variable again", " But then, if you keep on doing that by adding it to its list of variables, cans of spam, you're back to square one", " If each of these things you only occasionally need to change, and you have to add it to the function definition every time, you end up with your complex function all over again", " So that's not good", " Can we come up with something better? Well luckily, Python thought about this problem and came up with the idea of default values", " So over here we have this function again, and it's the exact same as before, except now we've set this equal sign and some numbers after a few of these variable names", " For example, cans of spam equals 10, and this indicator equals true, and so on", " So what this does, if the user doesn't specify a value for cans of spam, it sets the value of cans of spam equal to 10 and runs the function as usual", " Same thing with all these other variables", " So now I can call this function, complex with defaults", " Complex with defaults", " With a cat, a werewolf, and 1,000 silly walks", " And it'll run just fine", " So it had set can of spam equals 10 and all the other variables to its default values", " Wonderful", " And this time if I needed to change the can of spam to 20, all I had to do is just add number 20 for cans of spam, and everything else is just the default value", " So I don't have to change anything else", " And now we have 20 cans of spam", " Great", " That saves us a whole lot of time", " But it's still not quite there", " Well, what if we needed to change the number of frogs found? Its kind of really far out in our list of variables, so if we did that, we kind of had to type it all out again", " So 20 was cans of spam, say true for randomness in the indicator, and unfortunately, it's a non furry thing", " And let's say, I forget how many frogs I said I wanted", " Let's just say 10", " And we didn't have to specify the is doomsday device complete", " So we can write all of this out, hit Enter, and now we do have 10 scary frogs", " Oh, yeah", " I didn't need to do that", " But 10 scary frogs are very scary, and they deserve their own line and syntax error", " Anyway, so that was, I guess slightly better, since you didn't have to type is doomsday device complete", " But it was still kind of problematic", " You had to type all those other things that you didn't really need to, because those were the default values", " Luckily, Python comes up with another cool solution for this problem", " So now complex with defaults", " I can just say something is cat, and I do have to say a value for cat, and another thing for number of silly walks, since those do not have any default values", " So let's see", " Another thing is werewolf again, and that number of silly walks is 40", " And this time, if I just want to change the value of frogs found from the default value, I can just specify it by using a keyword assignment like this", " Frogs found", " Let's see if frogs found is 80", " So when I do that, it sets the frogs found variable to 80, and everything else to its default values", " That is really cool and powerful", " Now, it does come up with some, just use a little bit of caution when using keyword assignments", " You can't, for example, do something like this", " You have to put the keyword assignments after list of variables, because if you do keyword assignment before then, you'll come up with a syntax error", " And also, you can even specify the things that do not have default values with the keyword assignments, like this", " So complex with defaults", " You can say something equals cat", " And let's say that I don't want to specify another thing yet", " Let's just say I want to specify the number of silly walks this time", " And number of silly walks", " Let's say that's 100", " And let's say that another thing is, oh, let's say a vampire", " So it just sets something to cats, even though another thing is the second variable in the function definition", " I can specify another thing as the third thing as long as I use keyword assignments", " Same thing with number of silly walks, even though in the function it's the third number, or the third variable", " I can make it the second thing by using these keyword assignments", " This kind of notation makes it easier for you to keep track of what values you're passing into your function", " Sometimes when you're working on a long project, you can easily forget what the order of variables are", " So writing it this way will help make it more obvious when you're reading back and saying, hm, what was this 5 over here? What did it correspond to? Using keyword assignment lets you make the code a whole lot more readable", " So that's it for today", " I hope you found this feature of Python as useful as I did", " Have a good day, and don't let the frogs be too scary at you", ""], "o8tmvzs6F4Q": ["OK, we've now seen a mechanical description of the evaluation of procedures, both what happens when we define them, and what happens when we actually use them, when we do a computation where we use the body of the procedure", " We described a mechanical way of using environments, let's look at a couple of examples to really drive home that process", " Here's a simple example", " Let's suppose I want to compute the power of some number to some other power, a to the power of p", " I'm going to do it with just successive multiplication", " I know that Python provides a built-in version of this", " But I would, say, for example, wanted to take a to the p-th power", " And I do it by multiplying a by itself, storing that result away, then multiplying that by a, then multiplying that by a", " And then just keeping track of how many multiplications do I need to do until I've done p of them, and keep track of the result, and return it when I'm done", " So here's some code to do it", " And it's pretty straightforward", " In fact, we just saw it earlier", " It was in my earlier example", " I'm going to input some number for x", " I'm going to input some number for p", " And I'm going to make sure it's an int by doing a type casting there", " I'm going to set up an intermediate variable, or a place to store the result", " And I'm just going to run through that loop, where I'll print something up to tell me where I am, and I'll change the value in result", " Let's look at an example to see if this does it", " So if I go over to Python, I can load that computation", " It is now saying give me a number, let's give it 3", " It says give me an integer, let's give it 5", " Oh, and it prints through the stages, telling me at each iteration what the current result is", " It starts as 1, and then it's 3 and then it's 3 squared, and then it's 3 cubed, and then it's 3 to the fourth", " Wait a minute, didn't I want to take it to the fifth power? Well, notice that my print statement is just printing before I actually do the work", " And in fact, when I'm done, what I've done is, I'll return the value in result", " And there it is, it's 243", " OK, we saw how that computation would take place previously", " Now, let's capture it in a procedure", " So I'm going to define a procedure called iterative power, there's the name", " I'm going to give it two formal parameters, x and p", " And then the body of the procedure is much like what I have for my computation before", " I've got an internal definition of result, which I'm going to use", " And the only big difference is, when I'm done with the computation of that for loop, I've got that special keyword return", " That says return the value of this expression, which is just the value of result, when I'm done", " Let's try it to see if it works or not", " I've already loaded this over here", " So if I say I'm going to int-- yeah, yeah, iterative power, I'm going to compute that", " Let's do 3 to the 5", " It runs through exactly the same stages, and notice what it printed out at the end", " It printed out the value of the computation", " And in fact, if I were to bind this and say z is equal to IterativePower of 3 and 5, it runs through the computation", " And if I ask for the value of z, there it is, 243", " So it does the computation I want, now let's think about what happens inside of the environments, how it does the scoping of the variables", " So if I were to evaluate that definition, which I did, by loading it into my Python environment, what it does is, it creates a binding for the name IterativePower to a procedure object", " And inside there, I have a list of formal parameters, and I have the body", " I also have an environment pointer that points back to the environment in which I did the definition", " In fact, we know we're going to use it", " If I now call iterativePower with 2 and 5, what do we say happens? We get, first of all, the value of this expression, iterativePower, it points to that, it's a procedure object", " I get the values of each of these expressions with respect to this environment", " Numbers are always numbers, so it's just 2 and 5", " And then I create a new environment, which I'm calling E2", " This new environment here", " It has as a parent the environment that the procedure object has as a parent", " And then, inside of that environment I bind these formal parameters to the values of the expressions passed in", " And then relative to this environment, I now evaluate the body of the expression", " Ah, that's really cool", " Because now, I've basically reduced a computation to a simpler computation", " I'm now evaluating this expression or sequence of expressions relative to this environment", " And that environment contains the bindings I want", " So in fact, if I evaluate that body, what does it do? Well, the first expression it evaluates says bind result to 1", " And notice where that happens, it happens down here in this environment", " Not up in the global environment where I want to have some value that I might want to think about", " It's happening inside of this environment created by a procedure call", " Having done that definition, I run through the for loop", " And that says look up the value of x, which is right there", " Look up the value of result, which is right there", " Multiply them together and change the binding for result", " And then do it again and again, you get the idea", " All of this computation takes place in this environment, E2", " What that says, then, is that the loop rebinds that local variable until we get to the exit, until when we're done and we hit that return expression", " And return says look up the value of result in this environment", " Because that's where I'm doing the computation for the procedure", " There it is", " That's what's actually returned", " Cool, that's exactly what it said we should do", " Now, let's drive home a point", " Imagine that we had actually done some bindings for x and p before we called it", " In fact, let me go back over here to Python", " And I want to say, let's set x equal to 3", " Let's set p equal to 4", " Let's set result equal to 5", " And now let's call z as iterativePower 6 and 7", " It runs through the computation", " And notice what's happening", " What's the value of z? Well, that is 6 to the seventh power", " But more importantly, what's the value of x? Still 3", " The value of p? Still 4", " The value of result? Still 5", " Those were bindings in a global environment", " When I called the procedure, it created its own frame, its own context, did all the computation", " And that local environment had separate bindings for x and p, which are not visible to the environment where we did the function call", " So this point captures that notion of encapsulating the computation", " And what that then says is, to say it in a little more detail, we have bindings for x and p up here", " When we call the procedure, we do local bindings to the values passed in, we do local bindings for result", " And when we do that computation, the evaluation of the body only sees the bindings down here in E2", " So we created a black box", " Details don't matter", " I can re-use this procedure anywhere by simply using its name", " If I decide to change, for example, the names of the parameters in here, I'm free to do that", " And it doesn't change any computation that relies on just using iterativePower", " So procedures give us this wonderful notion of abstraction", ""], "7m8pab1MfYY": ["Congratulations", " Now you know how to use one of the basic building blocks of the course", " If you look to your left, you will see a table of contents for all of the aspects of the course", " Right now, since you are playing this video, you're in the overview section, which contains various aspects of administrivia including these tutorials", " Continuing to look to your left, if you click on the various chapter labels, you will see the course content that it's associated with each chapter", " You will not change content or interrupt a video until you actually click on a new course element to navigate to", " Each chapter contains activities that you are expected to complete, including presentation sequences, which you should watch and participate in in order to learn new material concepts", " You should also complete the homeworks and activities in order to get more practice and solidify your understanding of the material", " Many courses will grade you based off of your performance on homework questions", " The next section will describe how to enter and check your answers", " Note that in this sequence, even though the next section will give you feedback it will not affect your grade on any aspect of your interactions with that x So you should feel free to experiment", ""], "WdFrWzyYoQg": ["Eric Grimson: Welcome to 600x", " In this first lecture, we're going to talk about some of the fundamental principles of computation and computational thinking", " For example, what does a computer actually do? What are its fundamental operations? How do those fundamental operations support what we call imperative knowledge or how-to methods? What are the basic elements of a computer that enable it to compute things, described by algorithms, or how-to recipes? And finally, how can we use a language, a programming language in our case, to describe those recipes?"], "mylsICZfBpo": ["NTA"], "mExCdX2EPyY": ["PROFESSOR: In the modern world, we often have to search through many alternatives to find out which combination will give us the best result", " For example, what stock portfolio will give us the greatest return at acceptable risk? Or what combination of trams and buses will get me across town in time for the concert tonight? Or we might want to know what choice of rocket booster and trajectory will provide the minimum transit time for a space capsule to Mars", " These problems, called optimization problems, have been studied for many years and good computational solutions exist for many of them", " If you have your own optimization problem, you'll probably find it can be reduced to one of the classic optimization problems, and you'll be able to adopt one of the existing solutions", " Over the next few lectures, we're going to be looking at some of the classic optimizations", " And of course, you'll get to experiment with some of the solutions in Python", " As we tackle each of the problems, spend some time thinking about how you would approach the problem", " It can be a lot of fun", " Let's get started", " Optimization problems share some common characteristics", " Suppose we wanted to find the minimum airfare from Boston to San Francisco on a Monday or Tuesday", " Well the first thing we notice is that the statement of the problem has an implicit objective function", " So there's our objective function-- the minimum airfare", " So often the objective function involves mins or maxes or biggest or smallest or something like that", " Notice that some objective functions actually require us to look at all possible solutions so that we can choose the one that is the minimum or the maximum", " After all, how would we know that we had found the minimum unless we examined all the other ones to see that they were bigger", " The second thing that we notice is a set of constraints this solution must satisfy", " In this case, we're interested in flights that happen on Monday or Tuesday", " That seems pretty straightforward", " We could obviously generate solutions and check to see if they satisfy the constraints", " And then if they do, we can apply the objective function and decide if this is the one that we are looking for", " Sometimes a set of constraints can help constrain the search", " That's why they're called constraints", " For example, with the airfare, we might only consider flights that were flying on Monday or Tuesday, and from the set of all possible flights, that would be a considerable reduction in the amount of work we would have to do to come up with a final answer", " Before we look into how to write computer programs to solve optimization problems, let's take a moment and look at some of the more interesting ones", " Here's a classic optimization problem from the world of chess", " The goal is to place, in this case, 8 queens on an 8 by 8 board such that none of the queens is attacking each other", " That would mean that no 2 queens occupy the same row, column, or diagonal", " Well if we're going to program a computer to solve this problem, we might try a simple brute force approach where we would start by placing the first queen on a square and then think about where we could place the second queen", " And we wouldn't be able to place it anywhere in the first column, nor in the first row, the second column, or in the second row, the second column", " But we could place the second queen here", " And then we could go on and think about how to place the third queen and the fourth queen, so forth and so on", " We might eventually come to a situation where it would be impossible to place some queen, because there would be no remaining position on the board where that queen could go", " And that might mean that we'd have to back up and reconsider one of our earlier choices", " For example, the final solution might involve having the second queen actually be in this square", " And then we'd have to redo the placement of all the subsequent queens", " So this is an example that we're sort of step by step slowly enumerating all possible solutions", " Well in this case, there are 64 squares on 8 by 8 board, and we're trying to choose 8 of the locations", " So 64 choose 8 is about 4 billion possibilities, so the enumeration would take a long time", " However, we will eventually come to an answer, and one of the characteristics of optimization problems is that there's almost always a brute force approach that involves an exhaustive enumeration of all the possibilities", " Another classic problem is bin packing", " In this problem, we're given many objects of different sizes, and our goal is to pack them into bins of a fixed capacity", " And so in this case, our capacity of each bin is 80", " So we can see here that if we stack up objects of size 26, and 8, and 45, we've basically almost filled up the first bin", " The goal of the problem is to pack all the objects in the bin, but if we can, is to minimize the number of bins", " You can imagine there's many different ways to think about how to go about this problem", " For example, you could just simply take the objects as they came and stack them up one at a time in a bin, and when the next object wouldn't fit, you simply move to the next bin and keep going until you've used up all the objects", " Of course that would leave a bunch of bins with room at the top, and perhaps, some small object would fit there", " So another alternative would be to simply leave bins open all the time, and every time you have an object, you look for the first bin that will it fit in", " Or maybe you look for the bin that has the most room and put it in there", " Or maybe you'll look for the bin that has the least amount of room remaining but which the object would fit in", " So forth and so on", " It's actually fascinating to think through all the different ways you could tackle this problem", " You can see that if we tried to enumerate all the possible solutions, however, particularly when there's many, many, many choices to be made, it would be almost computationally impossible", " It would take years of computer time to figure out what we're doing, to figure out all the possible combinations", " So this is an example of a problem where almost certainly we'll have to figure out a heuristic or approximate solution that will let us make some progress and hope that it produces, as best we can, the smallest number of bins", " For our next example, suppose you worked at a cabinet shop and your job was to cut doors and cabinet sides out of large sheets of plywoods", " The objective function is to minimize the waste", " What you'd like to do is to take any lumber that ends up getting thrown away and make sure that's the least amount of lumber possible", " The constraint that you have to satisfy is that you can only do guillotine cuts", " Now, in a cabinet shop, you have to use a table saw to make a cut, and the table saws really want to cut all the way across a piece of stock, like so", " So that would be a guillotine cut, the first one you would make", " So the goal is to figure out a plan for laying out the pattern and then the sequence of cuts to minimize the waste and only do guillotine cuts", " What's interesting about this particular problem is you notice that once we've made our first cut, we have a similar subproblem", " So in other words, now we have a smaller problem that's exactly the same of taking these 3 pieces and laying them out on a smaller piece of plywood and solving the problem once again", " So this is often a structure you find in optimization problems, where you're sort of have to think a little bit about how maybe solving the problem involves really solving 2 subproblems and then looking to see if the solution produces a minimum cost", " Here's an example with a different kind of cutting", " Imagine that this is a description of an electrical grid, and we have a generating station at this end, and a city down here at this end, and the intermediate points are all substations", " And the arrows represent the capacity and the numbers represent transmission lines and their capacity", " And what we're interested in doing is computing the maximum flow from the starting point down to the ending point", " How much current can flow through this network? Well, the answer to this problem is related to the following observation", " Suppose we make a cut through the network, and we realize that-- so a cut would divide the network in half so that s is in one half and t is in the other half", " And we realize that all the current flowing from s to t would have to cross that cut", " What we would like to do is to find the cut, that so-called min cut, the minimum cut", " And what we'd like to do is to minimize-- OK, if we look at the capacity of all the cut edges, what we'd like to do is to sum up that capacity, and we'd like to minimize that sum", " So if we find the min cut through the network, that will actually tell us the maximum flow that can go from s to t", " As you can see, there's a lot of possible ways to make cuts in this network, and to do so without examining every possible cut is sort of a tricky business", " As a final example, consider the problem a traveling salesman faces", " He has a territory with cities with rail lines connecting the cities", " He would like to find the minimum cost trip that's subject to the following constraints", " He'd like to visit each city exactly once, and at the end of the journey, he would like to return home", " So this is one of the classic graph problems", " So the vertices represent cities, the lines represent the opportunities to travel from one city to another, and the goal here is to find a path now through this graph of cities that visits each city exactly once and returns to the start", " Now the question is is that the minimum cost, such trip", " Can we figure out a way to do this that doesn't involve enumerating every possible trip? The challenge of optimization problems is that they are hard to solve", " Hard in the sense that finding the solution you're looking for, the optimal solution, requires examining all the possible combinations of items", " So that's why this field is often given the name combinatorial, so studying of all the different combinations, optimization, because we're going to then look through each of the possible combinations and see if it's the one that is the best solution to the problem that we have", " The reason it's hard is that the time to examine all the combinations of a set of items grows exponentially with the number of items", " And what I mean by that is if I go ahead and add a single item to the collection, if I think about now all the possible combinations of items, what I will discover is that I will have a doubled the number of combinations", " And so as I go from 1 to 2 to 4, the problem is getting exponentially harder, twice as hard each time", " And the reason that's a problem is that real world challenges often have a very large number of items that you need to consider", " So as the problem is growing exponentially more difficult with each item, we can see that if we have 50 items that the problem may, in fact, take us too long to solve using the exhaustive techniques of looking at each possible combination", " So instead, we're going to have to look around for approximate solutions to these problems", " We give that the fancy computer science term of heuristics, something that will let us not examine all the solutions but come up with a solution more quickly", ""], "9rVsdCMxeiA": ["Eric Grimson: Welcome back to 600x", " In this second lecture we are going to start developing knowledge of programming languages", " We'll talk about how a computer converts a description of a how-to method that we write in a high level, although a semantically constrained manner, into a set of instructions that its internal circuitry can execute", " To do this, we're going to begin to introduce the basic elements of Python, the language we're going to use in this course", " We will introduce a bunch of things", " Numbers, expressions that combine numbers arithmetically, ways to compare objects like numbers, Boolean operations on logical expressions, ways to abstract expressions by giving them names, strings or collections of characters and words and operations on them, combining expressions in a linear manner, and simple ways to make decisions and to take different options or branches based on those decisions", " At the end of this lecture, you should be able to write simple programs that manipulate numbers or strings, make decisions, and print out results", ""], "uuw89vV7bGg": ["NTA"], "DKCKJJSYRU0": ["NTA"], "mixmc-woOF8": ["ERIC GRIMSON: We've now added tuples, we've added lists, we've started to see the kinds of things we can do with them, all the sorts of things we'd like to do", " We can slice, we can index, we mutate the list, we can apply functions to all of those pieces", " We're going to add in one last data structure that is a further generalization of the kinds of things we've been building", " And that data structure is a dictionary", " So a dictionary's a generalization of a list, but now the indices, the ways to get to elements of the dictionary, don't have to be integers", " If you think about it, a list is a linear sequence of things, and its indexed starting at 0, 1, 2, 3, all the way up to the end", " Now, with dictionaries, the places or the ways to get to elements of the dictionary can be any value that's immutable", " Hm, what does that mean? First of all, we're going to start referring to these indices not as indices, because that implies integers, but as keys, because the keys can be arbitrary in form", " And a dictionary then is simply a collection of key value pairs", " That is, a pairing up some key and an associated value", " The syntax for this is shown here", " We use curly braces to indicate that this is a dictionary, and each of the pairings is a combination of some key, a colon, and some value", " They're separated by commas, so the commas tell me where the ends of each one of those are", " So I'm giving the name monthNumbers to a collection of Jan 1, Feb 2, Mar 3, and 1 Jan, 2 Feb, and 3 Mar", " So I've got pairings both ways", " Each pairing has both a key and a value in it", " OK", " If I've got that-- and in fact, I'm just going to show you over here, I've got monthNumbers defined, and it is that pairing of these pieces", " Now, what I can do is, I can start doing things on this", " So the first one is, if that's monthNumbers, one of the first things I can do is I can get out elements of it", " So I could say, for example, if I wanted to get the value associated with a key, I simply give it that value of the key as an index, and it gives me back the thing I'd like", " Or I can say, if I want monthNumbers of the value associated with the key too, I can get back that as well", " So we get things by giving it a key", " So it's a lot like a list, except that now the things that go in are arbitrary expressions", " They don't have to be integers", " It's also important to notice-- and here's what we can do if we give it a second one", " It's important to notice that the entries in a dictionary are unordered, and they can only be accessed by a key, not an index", " And in fact, if you look back on my idle screen, you can see when I printed out monthNumbers, it gave me the dictionary", " And notice they weren't in the form that I typed them in", " I type them in with Jan and 1, and yet it has 1 and Jan as being the first element of it", " And so if I somehow say gee, I'd like to get what I think is the 0th entry of monthNumbers, which would be that 1 Jan pairing, it's going to complain, because in fact, I can't index by number", " I have to index by key", " OK, so what can we do with dictionaries? Well, we can do insertion", " So for example, I can go over to monthNumbers, and I can add something new", " And I would do that as you might expect", " I'm going to give it as an assignment statement saying, associated with the key Apr as a string, I want the value 4", " And that has now added to the dictionary monthNumbers so that if I ask for the value associated with key Apr, it gives me back 4", " So I've just inserted something into there", " I can also iterate over a dictionary, and I want to show you an example of this", " I'm going to bring this up here, and I'm actually going to type it in over here", " I'm going to create a variable called collect, which is going to be initially an empty list", " And then I'm going to loop over this dictionary I created, monthNumbers", " So I'm creating an generator iterator", " e is going to vary over each of the elements of that", " And I'm just going to append to the end of collect, that entry", " And if I now look at what collect is, ha, cool", " Its a list", " Oh, and notice what it put in", " It looks like it has put in the keys associated with each one of these things, and that's actually very good", " OK, so I've got the keys associated with each one", " And indeed, if I want to look at this, I can compare that to monthNumbers of keys", " And that's just a method", " And we'll come back to methods later on, but basically it's a method associated with the dictionaries, which is going to give back to me the list of all of the keys, and it turns out to be in exactly the same order", " Not a big deal", " All I wanted you to see was the idea that we can iterate over a dictionary doing things to the elements if we want to, and that's great", " The final thing that we can do is stress that the keys can be complex", " I can create a new dictionary where my keys now are tuples", " The tuple 1,2, or the tuple 1,3 have values associated with them", " I can ask for the value by giving it that key", " And notice the form", " I have to actually give it the key", " Open paren, 1 comma 2, close paren, and it will get back for me the value in the dictionary", " It's also important to stress that these keys must be immutable", " So I can use a tuple as a key, but not a list", " And that makes sense because if I'm storing something with a key in a value, and I can somehow go along and change the key, that's going to really mess things up", " I can't have mutable keys", " They need to be immutable", " And this is one place where it's advantageous to have both a tuple that can't change, and a list which we can change", " This is intended to be just a brief introduction to dictionaries", " We'll come back to them and their methods later on", " But now, what you've seen is we can have arbitrary collections of elements, ordered collections like tuples and lists, and collections like dictionaries that are simply indexed by arbitrary kinds of things, and we've got functions that can start operating on those kinds of data structures", " And that's going to add a lot of power to the kinds of things we can do", ""], "nUQtUX3zDoU": ["NTA"], "LYbCruklFEQ": ["PROFESSOR: So congratulations", " You've made it almost all the way through this course", " In this last lecture, we're going to try and wrap up what we've been talking about", " So in fact we want to do two things", " We want to first talk about what have you done? Where have you been? What are the key things that you learned in this course? what are the key lessons we want you to take away from this course? And the second thing we want to do is we want to talk about where you're headed", " What have you learned, and more importantly, how might you use the knowledge that you gained in this class to think about new things as you move forward? So let's start by talking about what's actually going on this course", " And we're going to start with a strange question", " What do computer scientists actually do? In some sense, why might you have taken this course? Well, we hope you've taken this course because you want to learn to think like a computer scientist, at least some of the time", " So what's a computer scientist actually do? Well, they think computationally", " Well, duh", " That's kind of an obvious statement", " What does it really mean to say that? A little more carefully-- a little less of a trivial answer, if you like, is that computer scientists use a set of tools", " They use abstractions", " They use algorithms", " And they use automated execution in order to solve problems", " So a better response is that you don't need to think about all of the details of something in order to build a model of it", " That's an abstraction", " You know what details to suppress so you can focus on key things", " You know how to think in a mechanical way-- a sequence of instructions", " That word \"recipe\" we used way back at the beginning of the class as a way of structuring how to execute a set of operations that let you deduce new information from initial information", " And we see ways in which you can capture all of that in a language that describes methods that can be automated to actually solve all of those problems", " One of the things we want to argue is that computational thinking is really a fundamental skill", " Every well-educated person ought to know how to think computationally", " And indeed, this is a skill that is going to be used by everybody in the very near future", " Certainly by the mid 21st century", " So that notion of computational thinking is really valuable", " And what does that say? Well, just like the old days, one talked about the three Rs", " And yes, I know it's a bad pun-- reading, arithmetic, and writing", " We would like to argue that the ubiquitousness of computing and computational thinking and computers, the fact that they're embedded everywhere, is going to enable the spread of computational thinking as a fundamental skill for every well-educated person", " With that in mind, let's say a little bit more about what does that computational thinking mean? What's the actual process? And here, this is just reminding you of the kinds of tools you've gathered", " If we approach a problem from a computational perspective, what do we say? We start by trying to identify or invent useful abstractions", " What does that mean? We want to take elements of a problem and capture them in objects-- abstractions-- where we were suppress some details", " They're internal to the abstraction", " They matter only to the implementer of that abstraction", " But to the user of the abstraction, those details are not relevant", " What is relevant is the contract one has with that abstraction", " If you give that abstraction certain inputs, it will give you back a particular output", " If you deal with an abstraction in a particular way, it will act in a well-designed and specified way", " So we suppress details and we formulate interfaces", " And those are our abstractions", " Those are the elements on top of which we then build a computational process", " And then what we say when we talk about how to think computationally? We said given those abstractions, given those elements of a problem, we want to formulate a solution to the problem by using experiments", " Building those abstractions, we want to formulate what are the steps one should use to execute those instructions or to use those abstractions to compute something new", " And having formulated a problem as a computational experiment, we then design and construct a sufficiently efficient implementation", " So we start up here with abstractions", " We then formulate a solution as an experiment", " We're going to do some computation on it", " And we then design and construct an efficient implementation of the experiment", " That's where our algorithms come in", " And having designed that, we then validate the experiment, or the setup of it, rather", " That is, we debug it", " We make sure that it actually is going to do what we expect it to", " And having done that, we then go ahead and run the experiment", " Now, running the experiment isn't the only stage", " We also want to make sure that the things that we set up-- the model we built actually makes sense", " And so when we run the experiment, we need to also evaluate the results", " Do these results make sense? Do they satisfy preconditions? Do they pass the laugh test, if you like? Do they actually satisfy all the things that we would like? And that says if, in fact, they do, great", " We've computed what we want, and we can move on", " But if they don't, then we need to repeat", " We need to go back around through this loop and refine our experiment and continue", " But that computational thinking, that designing the experiment then we can actually use computationally, is a key element of what we do", " Now, with that in mind, we can then specify three elements that you've now learned about how to think computationally", " The three As", " So the first one is that notion of abstraction", " Key elements here are how do you pick the right abstraction? How do you decide how to break a problem down into modules or chunks that have well-defined interfaces between them and that capture elements of the computation in a matter where we can suppress the details and just use the attraction? We want to do that using multiple layers of abstraction", " We certainly saw that, for example, when we talked about object oriented programming in classes", " We also saw that with algorithms, where we might build one algorithmic module, suppress those details, and build on top of that another algorithmic module, suppressing details within that, and so on", " So we want to think about different layers of abstraction and using those simultaneously", " And of course, once we've defined those layers, we need to define the relationships between them", " And that really is a key element of how we think about abstraction", " Second element is automation", " It's really important when we build abstractions to build them in a way in which we can mechanize the use of those abstractions", " We can specify a set of well-defined stages or operations that access or manipulate elements of the abstractions", " And one of the things that we saw that's very central to computational thinking is the fact that mechanization, that building a computer algorithm that does everything, is possible because we have very precise and exact notations and models for things", " That was the elements, if you like, of our syntax and our semantics of our language, as we talked about", " And the second key element is that there is a machine that can interpret those notations", " That is our interpreter", " That is our evaluator, underlying all of the evaluation that we do", " And then the third A are the algorithms", " These are the specifications, the recipes, the ways in which we detail the things that we're going to deal with", " And again, the key element with our algorithms is that they follow certain patterns", " They obey certain rules", " And we've learned those rules", " And those rules are, by and large, independent of the programming language in which we described those algorithms", " With that idea of computational thinking, one of the things that we can then say is we've got a language, we've got abstractions to details", " With that, we can also then think about some examples", " And I want to give you two of them", " The first one is when we think about a problem computation", " The kinds of questions we can now ask are how difficult is this problem, and how best can I solve it? We've already seen that the theory of computer science gives the precise meaning to these questions and to their answers", " We saw that certain problems have more complexity", " That solutions to them inherently involve some minimum amount of computation", " And that some classes of problems are much more efficient to solve than others", " And it gives us a sense of where we want to be when we think about how to tackle a particular problem", " We also saw that different kinds of algorithms tackle different kinds of problems better", " And those tools we're going to come back to when we think about how to use them to best solve a problem", " One of the key things we saw with computational thinking is that we can think recursively", " And this means not just that we use a recursive program to solve something", " It also talks about how we solve a problem", " That if we're given what seems like a very difficult problem, often we could reduce it to a simpler version of another problem, or to a simpler version of the same problem", " The latter one, of course, is the standard recursive version", " But this idea of reducing or embedding or transforming problems into other solutions is really handy", " So part of your goal as a computational scientist is to create and store away a set of standard methods for solving problems", " So that when you get a new problem, you can use it to say, is this a problem I can reduce to a problem that I already know how to solve? And if I do, how do I do that transformation in a way that lets me solve the original, more difficult problem? That idea of recursive thinking, we've seen many times", " And just to show you a favorite example of it, you can obviously create things that recursively unwind into simpler or smaller versions of the same problem", " But of course, somewhere way down here in the middle, you do need to have a base case to stop the unwinding of the computation", " But that's basically what we've been doing in this course", " We've been thinking about how to approach problems computationally", " In the next section, we're going to move on to talk about what actual tools have you learned", ""], "bGx4MAxsVuI": ["NTA"], "-8T8AXxVFZg": ["Eric Grimson: OK, so we want to think about computational problem solving", " We want to understand, what does it mean to think computationally? That leads to the philosophical question, so what's computation? And like a good philosophical question, that leads to another, deeper philosophical question", " To answer that question of what's computation, let's start by asking the question, what is knowledge? And, as we're going to see, we can divide knowledge up into 2 parts", " There's declarative knowledge, which we can think of the statements of fact", " And there's imperative knowledge, or how to's methods", " Statements of facts give us true, but, as we'll see, they don't necessarily help us think about how to find new information", " Imperative knowledge, how to methods or recipes, give us ways of finding new information, and that's going to be really valuable to us", " Now, to look at this, let's look at an example", " So, what do we mean by declarative knowledge? Well, here's a piece of declarative knowledge", " That first statement says, the square root of a number x is a number y such that y * y = x ", " You know that's true from high school algebra", " It's a statement of truth", " It tells us something about how to decide whether a particular number is a square root or not, but can we use this to actually find a square root? And the answer is no", " If we have a number x equal to 25 and we're trying to find the square root of that, and somebody gives us a guess y = 5, we can use this statement to test to see if 5 * 5 = 25 , which it does", " But it doesn't tell us how to find the guess", " So declarative knowledge, which is what much of knowledge is based on, isn't what we need", " We want a different kind of knowledge, and for that, fortunately, we have imperative knowledge", " As we said, imperative knowledge is how to kinds of knowledge, or methods or recipes for finding something, and here's a recipe for deducing square root", " It's actually attributed to Heron of Alexandria, although there's some debate as to whether he was the original creator of this algorithm, but it dates from the first century AD", " And you can see the description here", " Description says if I want to find the square root of some number x, I'm going to start with a guess", " I'll call it g", " I'm going to take g and multiply it by itself and look if that result is close enough to x", " If it is, I'm going to stop, and say that g is the answer", " Otherwise, I'm going to make a new guess by averaging g and x/g , and using this new guess, which I will call g again, I'm going to repeat the process until we get something that's close enough", " Notice, this is a mechanical set of steps and it has some basic forms", " Right here there's a test", " It's going to let us know when we're done, when we're close enough", " If that test isn't satisfied, then there's some simple calculations, like here, that tells us what to do", " And then, finally, there's a flow of control, or a loop, that tells us how to keep executing the same sequence of operations until we get, in fact, to a place where we're done", " This is something that tells us how to find a square root", " This is imperative knowledge and this is what we want", " OK, let's try it out", " Here's a little description of that", " Let's see what happens if we were actually to do it", " So I'm going to do a simple little simulation", " I want to find the square root of 25", " And, yeah, I know the answer is 5, but let's think about what might happen here", " I'm going to start with a guess and I'm just going to initially guess 3", " Heron of Alexandria's algorithm says multiply 3 by itself", " That, of course, gives me 9", " Is 9 close enough to 25? I don't think so, so let's get x/g , which is about 8", "33", " And now, let's take the average of x/g and g", " So we add g and x/g , take the average of that, and we get 5", "67", " And then our little recipe says take that and do it again", " So this now becomes my new guess, 5", "67", " I multiply those together", " I happen to know that comes out to be about 32", "5", " I've gotten closer to 25, but it ain't there yet, so that's not close enough", " Again, let's take x divided by this g which turns out to be about 4", "41, and then I take g and x/g and I average them, and I get 5", "04", " And my algorithm says, my recipe says, take this and do it again", " 5", "04 multiplied by itself is about 25", "4, and I'm going to say, you know what, that's close enough, so my little recipe says there's the answer", " Not perfect, but close enough", " So, Heron had it right", " This looks like a pretty good algorithm", " This is a way of describing a method for doing something, and that idea, that notion of a recipe, is something we're going to use a lot", " So we can think of algorithms as being recipes, sequences of mechanical steps for doing something", " We put that analogy to a little bit more use, we can see that recipes have much of the same form, real recipes", " Imagine I want to make some custard", " Here's my recipe", " I'm going to take all the ingredients of the custard, that mixture, put it into a pot over some heat, and I'm going to stir it", " As I stir it, every once in a while, I'll dip a spoon into the custard, pull it out, and run my finger across the back of the spoon", " If the spoon is clear, then I'm done and I'm going to remove the custard from the heat and let it cool", " If not, I'm going to repeat", " And notice what we have here", " Again, we've got a test, right there", " And we've got a way of, in fact, changing the flow of control", " So, normally, the flow runs this way, but based on that test, we have a way of going back up and continuing the path", " And this pattern is something we're going to repeat a lot", " So, you want to capture recipes and we need to figure out how to get the computer to do that for us, which is what we're going to talk about next", ""], "3nWlFHGKNAk": ["ERIC GRIMSON: We've been looking at optimization problems", " These are problems where we want to find a solution that satisfies some function, some measure, some estimate of performance", " And we've seen that often those optimization problems can be thought of as search problems", " We write an algorithm that looks through the space of possible solutions, trying to find a solution that maximizes or minimizes some measure of success", " And, ideally, we've seen that those solutions, or those search solutions, will be efficient", " They may not look at the entire space", " They'll take advantage of the structure of the problem to find efficient ways to maximize some measure", " We want to generalize that idea to take it in a different direction, and we're going to take it in a different direction by looking at optimization problems over graphs", " So what's a graph? Well, let me give you an example", " Imagine you are a college student, which you may well be, and you want to go home for the holidays", " So you'd like to plan a flight that gets you there", " Imagine you had data on all the flights between cities in the US, or major cities within the US, including information about the prices", " Let's also assume that for any pair of cities, A and C, if I want to fly from A to C through B, that is, A to B to C, the cost of that flight A to C is the same as the cost from A to B and the cost from B to C", " If I have that, what might I like to know? Well, I might like to know what's the best set of flights that has the fewest stops between two cities", " I might like to know what's the least expensive airfare between two cities", " Or, even constrained things like what's the cheapest flight from A to C that doesn't go through more than one other stop along the way or no more than two other stops along the way", " All right, so you can imagine I might like to do this", " What does a graph have to do with this? Well, let's think about how to capture this problem", " Here's a map of the United States, where I've marked off some of the major hubs, that is, airports through which airlines fly with a large number of flights, so San Francisco, LA, Chicago, for example", " Each one of these cities I've marked here I can think of as an element of the graph", " It's a piece of information, an object, if you want to think of this in terms of our object-oriented system, with some information on it", " What else would I like to know? Well, I'd like to know where are the flights", " So I could mark in all the connections between these hubs, that is, places where there is a flight, a direct flight from one point to another", " So for example, from San Francisco to Denver, there's a flight", " Now having marked those in, let's abstract away this problem", " Let's throw away the map and just capture an abstraction", " And now I have a graph", " And what's the graph? Well, it's got some nodes, or elements, with information associated with them", " And it has some edges, or connections, things that link those nodes", " Let me describe that a little more carefully", " A graph is two things", " It's a set of nodes or vertices, my blue dots in that previous diagram", " And those nodes or vertices are connected by a set of edges or arcs, arrows in this case", " Those edges indicate relationships between the nodes, and we're going to use that in a second to actually think about doing optimization", " Now, if the edges are uni-directional-- they only go one way, you can only fly from San Francisco to Chicago but not back-- then we say the graph is a directed graph or a digraph, and the arrows here would be one directional", " If they go both ways, we just say it's a graph", " If we think about my example, I could imagine finding paths through that graph from one airport to another that minimizes the number of stops along the way", " That would just be the fewest number of edges I have to pass through in order to get there", " But if I want to know about cost, I need additional information", " And so often with a graph, I'm going to have other information", " If we add a weight, or a cost, to each edge, then we say the graph is a weighted graph and that says I can solve other kinds of problems", " So for example, here I've added in, for each edge, the cost, the cost of a flight between those two cities", " And now I can actually start answering questions like, what would be the best flight from San Francisco all the way out here, for example, to Boston that minimizes, for example, the total cost, or it minimizes the total cost subject only going through one or two additional cities", " Now I can start thinking about optimization problems over these graphs", " This is actually going to be really powerful", " Now why are these actually useful? Well, graphs let us represent a wide range of different kinds of problems", " And they lead, naturally, to questions that could be answered by a particular kind of search problem, something we're going to deal with in this lecture", " We've talked about it in terms of transportation networks, that's kind of obvious", " But there are lots of other places where a graph is a very natural way of capturing a problem", " Web traffic-- imagine I've got a set of web pages", " Those could be the nodes in my graph", " The edges would be the links", " A page links to another page, and note they may be one directional", " And then, the weights could be how often are those links used, and I could ask questions about traffic in a particular collection of pages on the web", " Another nice example is epidemiology, dealing with diseases", " If I want to track the spread of a disease, I might gather information where the nodes are people with information about the disease", " They have the disease", " They've been exposed to the disease", " They're immune to the disease", " The edges would indicate interactions between those people", " They know each other", " They know each other well", " And the weights, in fact, would capture exactly that, the level of interaction", " And using that, I could track the spread of a disease to try and identify the sources, to try and identify populations that are isolated from other populations", " We'll see lots of examples of using graphs, and especially solving optimization problems, over those graphs", ""], "mTsArBWQbhs": ["NTA"], "8iQAhz7rzVs": ["PROFESSOR: As scientists and engineers, the way we understand the world around us is design experiments and take measurements", " The world's a complex place, however, and those complexities often conspire to make the measurement process somewhat problematic", " Vibration, temperature, electrical interference can all have subtle influences on the measurements that we're taking", " Our goal in this lecture is to study how computation can help us understand our experimental data and process it to help reveal the underlying truths", " As a first step in understanding experimental data, let's remind ourselves what we're about", " So usually one of the first things we do is to develop an hypothesis of how things work", " So this is a simple statement that says if I do x, y will happen or something equivalent to that", " If we have a hypothesis, we'll quickly want to design an experiment and then take some measurements", " And it's really these measurements that will tell us what the results of the experiment were", " And in fact, we often will interchange the order of these two things", " Sometimes, we've measured, done some experiments, and we're interested in making a hypothesis that explains the results", " Other times, we have a theory about how something works, and we're trying to design an experiment to prove the theory", " In either case, once we have the measurements, then we're going to use computation to do several things", " The first thing we're going to do is probably evaluate the hypothesis", " What we'd like to do is determine if the measurements we made give us some evidence that, in fact, our hypothesis is true", " The hypothesis may involve a certain unknown, some constant to proportionality, and one of the things we'd like to do with the measurements if we decided that, in fact, the hypothesis is true is determine the values of these unknowns in the hypothesis", " And finally, and this is maybe one of the most important things that we're going to use computation for, is if we have a validated hypothesis, we would like to use it to predict consequences", " And in fact, these may be consequences that would be very hard to do experimentally or very costly", " So, for example, if we've understood orbital mechanics, we may wish to use the computer to use the mathematical model of orbital mechanics to predict the trajectory we should take in order to successfully have a rover arrive at Mars", " Let's see how this might work in practice", " In 1676, the English scientist Robert Hooke proposed the following hypothesis about how springs work", " \"The power of any springy body is in the same proportion with the extension", "\" So let's see what he's talking about here", " So, if we take this common piece of gym equipment-- a bunch of springs with handles on it-- and we bolt one handle to the wall, and then we start pulling on the other end of the spring-- we apply some force this way-- the spring will stretch", " And, in fact, we can measure the amount of stretch, and we'll call that the extension", " And as anybody who's tried this knows from experience, the farther you stretch it, the harder the spring is pulling in the opposite direction", " So the spring will busily be exerting some force to counteract the extension, and that force will be proportional to the amount of stretch that you're putting into it", " And that constant of proportionality is called the spring constant", " If k is small, it's a very weak spring, and in fact, it doesn't take much force to either compress or extend it", " For example, a ballpoint pen can easily be controlled", " The little spring inside can be compressed with a single push of your finger", " On the other hand, if the spring constant is large, that means it's a very stiff spring", " So, example of a very stiff the spring is like a car spring, where it takes a tremendous amount of force to compress it even a little bit", " Let's design an experiment to test Hooke's law", " To do that, what we're going to need to do is to figure out how to apply unknown force to the end of the spring", " And we're going to do that by hanging a weight on the end of the spring, and the force, the downward force, applied by that weight is going to equal to the mass of the weight times the gravitational constant", " That's the acceleration due to gravity, which is, I'll say, 9", "81 meters per second squared", " And so, when we hang a weight, we get a downward force", " That will cause the spring to stretch", " So the spring stretches out, and the more it stretches, the greater the extension, obviously", " So, here's the measured extension of the spring here", " We can measure how far the spring stretches when we add the weight, and we're going to get an upward force by the spring resisting the extension", " And in fact, that upward force, according to Hooke's law, is equal to the spring constant times the amount of extension", " Eventually, the system will reach equilibrium", " And equilibrium happens when everything stops moving, which must mean that the downward force exerted by the weight is equal to the upward force", " In other words, everything's exactly balanced and there's no more forces acting on the weight, so the weight isn't moving and the spring isn't stretching any farther", " And what that will tell us is that at that point, the downward force, mg, is equal to the upward force, kx", " We went off and performed that experiment", " We took many different weights and hung them on the end of the spring, and here's a listing of all the different masses that we use from 0", "1 kilograms up to 1", "0 kilogram", " And we measured the extension in meters that each weight produced", " So, let's figure out, can we compute k from this", " Well, if Hooke's law is true, then we know that mg = kx", " We decided that on the previous page", " That implies we should be able to compute k by taking the force that was applied by the weight and dividing it by the extension", " Let's try it", " So, our first weight was 0", "1 kilograms", " The gravitational constant is 9", "81 meters per second squared", " And we'll just divide that by the measured extension, which is about 8/100 of a meter, 8 centimeters", " And if we do the arithmetic-- you know, we can type that little formula into Python or use a old-fashioned calculator or even more old-fashioned instead of working it all out by hand-- we end up computing that k is equal to 11", "341 Newtons per meter", " So, are we done? Was it really that simple? Seems like we didn't really need to take all of these measurements", " We used the first one to do the calculation, and if everything is perfect, all the rest of the computations should come up with the same result", " So, why not as a finger exercise do the same computation that I just did, except use the second measurement", ""], "SVQuLOiHJeE": ["NTA"], "mtVzWIRNOBI": ["NTA"], "7-mC6P2B6Ac": ["NTA"], "fgrbzv_HQeE": ["OK, we've now seen graph search-- depth first search, breadth first search", " And we've seen, in fact, searches where both depth first search and breadth first search will find solutions, find paths with the fewest edges", " That may be what we want", " But there are also times where we might want more information", " Let's go back to our original example of finding flights from one city to another", " We could find the sequence of flights that involves the fewest stops", " That would be the minimum number of edges", " But we might be more interested in minimizing time or minimizing cost, and that's information that's on the weight on an edge", " So if our edges are weighted, we need to find other solutions-- solutions that minimize that total cost", " Turns out that for depth first search, the algorithm we've shown you is quite easy to modify", " Rather than just counting the number of edges, we simply sum up the weights", " And we keep searching to find the solution-- the path that minimizes that sum", " Structure of the algorithm, other than that change, is basically the same", " For breadth first search, in fact the first found solution may not be the best", " Because it's minimizing by the structure of the algorithm, the number of steps-- the number of edges", " And so one needs more sophisticated methods to actually try and solve it", " Just to give you a difference, or a sense of the difference between them, let's look at a couple of simple little examples", " Here's that graph abstraction we had at the beginning of our lecture about different flights", " If we're just minimizing the number of edges-- for example, going from here to there, either algorithm will find it", " And in fact, there are a number of different solutions", " So here's one", " It's got four legs", " Here's another", " It's got four legs", " And in fact, there are a bunch of them with four legs", " Here's another one with four legs", " We're minimizing the total number of edges along a path", " When we take weights into account, for example the cost of the flight, then things are little bit different", " And in fact in this graph, one could actually run an algorithm to show that the best solution is this one, which has a cost of $300 plus $200 plus $150 plus $130, which is 5, 6, $780", " And you can explore this for yourself to discover that any other path through this graph, in fact, has a higher cost", " So sometimes we want to solve minimal problems or optimization problems with weighted edges", " Sometimes it's just the total number of edges", " All right, with that in mind, why are we doing graph optimization? Well, as we said, we have lots of problems that are naturally expressed as a set of transitions between a state of a system", " And those often can be easily solved as a graph search", " Simple examples would be ones where the actual structure the problem is itself a graph", " Travel through a physical network, whether it's a flight network or whether it's actually something like using your GPS to find driving routes from one location to another", " In those cases, the nodes naturally correspond to physical locations, like hubs or intersections", " And the edges naturally correspond to physical structures-- flight paths, roads", " But there are other problems are also well described as graphs", " Imagine you're trying to program a robot to accomplish some task", " Here, the nodes may be the state of the system-- the locations of pieces or the location of the robot", " And the edges are actions that that robot should take to change the state of the system", " Again, well solved as a graph problem", " And indeed, that leads to a more general sequence, or collection of problems", " Those are problems where a physical system is being handled or manipulated", " And here, the nodes are descriptions of the state of the system-- parameters that describe the position or state of the system", " And the edges are actions that will move, or transitions if you like, that will move the physical system from one state to another", " And again those are well solved by graph optimization problems", " And that says, basically, what we've shown you are two very handy tools for doing depth first and breadth first search, to find a sequence of transitions that transforms a system to a desired goal state", " These methods can find optimal solutions to a wide range of problems that are described in this matter, and they're going to be really valuable as you use these tools to solve problems of interest to you", ""], "9VqKk8cn6Cg": ["NTA"], "R8NTftu7shM": ["NTA"], "d-SBFpxf8Bk": ["NTA"], "-gLoe0n1CEQ": ["Let's visualize what this idea of checking if something is a palindrome does", " The basic idea is to check the first and last letter to see if they're the same", " And then if they are, to check the remaining middle portion to see if it's a palindrome", " So here's ablewasiereisawelba, all reduced down just to lowercase letters", " And so at the first step, we check to see are the two end cases the same? They are, and that reduces to checking a smaller thing", " Again, we check to see if the first and last character are the same, they are, and that reduces to checking a smaller thing", " And at each stage, we keep checking the end characters", " In this case they are all the same, and we keep reducing to smaller and smaller versions of the same problem", ""], "mB26qQckcHc": ["NTA"], "Ys5yKRESAOw": ["NTA"], "FuJyo3kNgto": ["NTA"], "hC-bd-D-4nQ": ["NTA"], "jJqP3ZUSy5E": ["Now that we've introduced the idea of a function definition, I want to spend a little bit of time giving you a mechanical way of thinking about how function implications work and in particular how the right kinds of values get stored in the right places", " So we're going to use the idea of what's often called an environment to understand how bindings of variables take place", " And here's the basic idea behind an environment", " It's going to be a formalism for tracking the bindings of variables and values", " And it will in fact apply to general bindings of assignment statements as well as more broadly to when we do function calls", " So indeed, whenever we do an assignment statement, that simply pairs a name and the value of the other expression together in a table, if you want to think of it that way, that we call an environment", " If we want to get the value of a name, invoking that value or that name rather, just asking for the value of that name simply goes to the table, and looks up the value, and returns it", " Generally when we're talking to a Python shell, there is an environment", " It's often called the default or global environment", " And it contains the bindings of all the expressions that we put in as we deal with it", " And then, the key piece of this is when we evaluate a definition, it pairs the name of the function with the details of the function without actually evaluating those details", " It creates a pairing up the name to what we call a procedure object", " Let me show you a graphical way of thinking about this", " Here's a little bit of a description that we're using", " I have evaluated two expressions", " I've evaluated an expression that binds x to 5 and that binds p to 3", " And over here, I have my global environment", " This is the environment to which the Python shell is talking", " And in fact, when I evaluate these assignment statements, they create bindings of names to values", " x is bound to 5", " p is bound to 3", " I've also bound result down here", " bound to 1 over in that environment", " That gives me variable names and values as associations", " And now imagine I want to run a little piece of code, this little for loop here", " I'm not going to worry too much about the details", " We'll come back to it", " But basically, this four-loop is going to run using an iterating variable turn over the range from 0 up to p minus 1, which we know is going to be 0, 1, and 2", " It's got a print statement in there", " But it's also got an expression down here", " And here's what will happen if I evaluate that", " We know what should happen", " But in terms of the environment, when I want to evaluate this expression, it says get the value of result by looking it up over here in the environment", " Get the value of x by looking it up here in the environment", " Multiplying them together, and then rebind result to that value", " That was when term was equal to 0", " Having done that, we go back and we say turn equal to 1", " And we do the same thing", " We get the value of result", " We get the value of x by looking them up in this environment here, doing the computation, and rebinding result to 25", " Turn goes up one more", " That's equal to 2", " It's going to be the last one", " And we again, do the same kind of computation, getting result, x multiplying together and rebinding result", " So my rules, now, are just amplified a little bit", " I'm actually just keeping track in this environment of the bindings of variables, looking them up when I need them, and re-changing them with assignment statements when I have to", " So after I've executed all of this, my environment would look like this", " So that if in fact I said to Python, what's the value of result, it would look it up in that environment and return the value", " So this computation does what I expected it would do", " But we can see how this idea of an environment gives us a little bit more formalism for thinking about what happens as we do those evaluations", " Now, let's see what happens when we create a procedure object", " I'm going to bind, in this case, x to 5 and y to 3", " And there are my bindings right there for it", " And when I give the Python shell a definition, whether I load it in from a file or I type it in, it is going to associate with the name in the environment, what we call a procedure object", " So it's got an identifier that says this is a procedure", " And inside of it, it has the parameter list", " And it has the body of the procedure", " And notice the form which is important", " It doesn't have substitutions for x and y here", " It has them as variable names", " That means that this procedure here can be used multiple times", " And that's great", " I've now captured that computation", " I can refer to it by name because that name's available in that environment", " And I ought to be able to use it", " Great", " So that procedure object is something that sits available to me, but again has not been evaluated", " We don't have substitutions for x and y there", " There is variable names", " And the last piece is this little thing here we call an environment pointer", " And it, from the procedure object, points back to the environment in which that procedure was defined", " And we're going to see why we want that", " But it basically tells us the context relative to which I want to evaluate my procedure objects", " So this arrow points to the binding", " This arrow is an environment pointer that comes back", " Here's what happens when I actually call a function", " If I want to evaluate some expression followed with, in parentheses, some other number of expressions, which would be what a function call would look like, I first evaluate this expression, which is a name", " And that says I'm going to just look it up in the environment", " And I will get back the value which is that procedure object", " I then evaluate all of these other expressions to get the values of the parameters", " Then I bind those parameter names in the procedure object to the values of the arguments that has passed in", " And I do that in a new frame, which has, as a parent, the environment in which the procedure was defined", " That's going to create a new context", " It's going to look just like an environment", " It's going to have names, in this case the parameters, with values associated with them", " And relative to that environment, I'm going to evaluate the body of the function", " And that's going to do just exactly the same rules", " So I evaluate the body of the procedure relative to this new frame", " So for example, if I were to now call max of 3 and 4, right there I'm going to bind the value of that to z when I'm done", " What do I do? I first get the value of max", " It's right there", " And it is pointing to that object", " I get the values of 3 and 4", " Those are easy", " They're just numbers", " And then I bind the parameters of the procedure in a new frame", " I'm calling this one E2 for Environment Two", " I bind them to the values that I just got", " And then relative to E2, I'm going to evaluate this body", " That's great", " Because now what do I have? I have a way of saying if x is greater than y-- and where do I get the x? It's right there", " It's relative to this frame", " So I only see that value of x", " I only see that value of y", " I don't get confused by things up here in the global frame", " Because I've created a new environment right there", " And relative to that environment, I evaluate the body of the procedure", " Now you can see, this encapsulation is going to protect the interior details so that it doesn't matter, in fact, what names I use for the parameters here, or whether they have bindings elsewhere, because they're not going to get seen by Python", " It's going to use the local context, and, in this case, return the max of these, which is the value 4", " Mechanistic? Yes", " A little bit boring? Yes", " But really valuable for understanding exactly how the computation keeps track of what values to use, what variable names to use, and how to use the steps to do the computation we just captured inside that procedure object", ""], "NDAb2bewzbI": ["NTA"], "jL4wZ8-RjTs": ["In this ninth lecture, we're going to look at search algorithms", " Many computational problems involve searching to find items in collections of data objects", " We will generalize the idea of bisection search to more generic binary search, where we use information to reduce the search space in half at each step", " We'll show that if the data is sorted, this is a very efficient way to find objects", " But if the data is not sorted then we have to find ways to transform the data set", " And we'll look at two different sorting algorithms", " Finally, we'll show that if we're going to execute multiple searches of a data set then the combination of sorting and binary search is a very powerful method", ""], "bFKqJNSw4zE": ["NTA"], "Zoy7t4LbAPY": ["PROFESSOR: We've been looking at the idea of exhaustive search", " And we just saw, when we want to do this on things that don't have a finite number of choices, real value to floating point numbers, for example, we've got a problem", " We need to make the step size small in terms of how many different things we sample", " But as we keep making it smaller, it's going to make the search take longer and longer", " Because if we're going to do it, we're going to put a lot of effort into trying to find the right answer", " So we'd really like to have a way of having things still be very efficient, yet, find the answer we want", " And it turns out, for a lot of problems, we can do that using a wonderful idea called bisection search", " So what do we know? Let's go back to the idea of trying to find the square root", " We know that the square root of x lies somewhere between 0 and x", " We're assuming x is positive just to make life a little easier for us", " That's a mathematical fact", " Now, what we did was we said let's start with 0", " Then, 0 plus a little bit", " Then, 0 plus 2 times a little bit, and then 0 times 3 times a little bit, trying all of those examples, until we got to something that was close enough to the answer we wanted", " That's exhaustive", " Rather than doing that, suppose instead we say, look, we know that the square root of x is somewhere between 0 and x", " So let's just pick a guess right here in the middle", " Let's call that g", " Let's just pick the midpoint between 0 and x and try it", " Now, if we're lucky, the answer is close enough and then we're done", " That's unlikely", " But even if that is not the case, we have a good situation", " Even if we're not close enough, we can now ask was that guess g too big or too small? Well, if g^2 is bigger than x, then we know that it's too big", " We know that the square root has to lie somewhere between 0 and g", " And that says we can now instantly just focus on this portion", " Doing that, we can, again, take the midpoint of that", " Let's call it another version of g", " A new g", " And again, we can say, is that close enough? If not, is it too big or too small? For example, in this case let's assume that g^2 is less than x", " That says g is too small, and what does that say? It says, we know that the actual value has to lie somewhere between my new g and the previous g that I guessed", " And again, we can pick the midpoint and guess again", " If this works, and it does, this is really cool", " Because it says, at each stage of this bisection search I'm cutting in half the size of the range of values I have to look at", " We're bisecting them, which is why it's called that", " At each stage we reduce the range of values that we have to search by half", " And that is going to be really powerful", " Rather than just at each stage throwing away a little bit, we're cutting down the problem, a big portion, each time through", " So can we capture that idea? The answer is, sure, and it's not that hard to do", " Again, there's some code", " It looks a little bit daunting, but it's really not as bad as you think", " What does it say? It says, I'm going to have some value of x I'm going to start with", " OK, I'm going to pick an epsilon which is going to tell me how close I am, and I'm going to keep track of how many guesses I did as well", " I'm going to set up, initially, a low and high value, which are to start with 0 and the value of x", " That's my range where which I want to be trying to do the computation", " My answer is initially going to be the midpoint halfway between low and high", " And then, what do I do? I run through one of these little loops where, again, I basically say, am I close enough? If this is true, then I'm too far apart", " I'm not close enough", " And in that case, well, I'll print out some information that tells me where I currently am", " I'll change the number of guesses and I'm about to make a new guess", " And if I'm not close enough, what does it say to do? It says, if my current answer squared is less than x, I'm too small, and I'm going to change the lower end to be that guess", " I'm moving up the lower end", " On the other hand, if answered squared is bigger than x, then I'm too high and I'm going to reduce the high down to the answer", " And I'm just going to keep doing that", " If I keep doing that I'm going to keep chunking this thing in half, and having done either of those two pieces I then change my answer to gain the midpoint", " And I do this one more time", " So I'll just keep cycling through this, cutting in half each time, the size of the problem until I get to something that's close enough", " We hope", " OK, let's see what happens if we do it", " Here's some code in my IDLE system that has it", " It has exactly that", " Let's do this, basically, let's start with something simple which we said was going to be 25", " And let's see what happens if we evaluate that", " Oh, look what happens", " I start off, and let's look at that, I start off with a range between 0 and 25", " And the answers is the midpoint", " I then, cut down the high end", " I then, cut down the high end again", " I then, cut down the low end", " I then, cut down the low end", " And you can see at each stage it's reducing the range", " And after only 13 guesses I get a pretty good guess for what the square root of 25 is", " It's not exact", " I happen to know it's 5, but in only 13 guesses I got it", " Remember, last time we did 50,000 guesses to get to something that wasn't, in fact, much better", " In fact, it wasn't even as good as this guess", " So notice how it's cutting down the problem at each stage", " All right, let's go try this other version of this, right? 12345", " Let's see what happens if we find, using by section first, the square root of that", " We see it cranking along", " Wow, in 26 steps, it got to something that took a million steps the last time around", " In 26 steps it gets to a pretty good approximation", " Let's try something even bigger", " Let's see what happens if we do that one", " All right", " Again, you can see if you look at these numbers how quickly it's zeroing in", " In only 36 steps, it got to the square root of a pretty big number", " So in fact, this does it really well", " What can we observe out of this? Well, here are some things that we see", " First of all, bisection search radically reduces the computation time", " And this is part of that original message that it's not just having a fast computer", " It's being smart about how we think about solving the problem", " And in this case, being smart about how we generate the guess is going to be really important", " So when does this idea of bisection search work? Well, it should work well on problems where there's a sort of ordering property", " Meaning, that the value of the function being solved varies monotonically with the input value", " Another way of saying it is here the value I'm looking for is g**2", " Then, it grows as g grows", " And that says that there's this nice ordering of the solutions or the potential solutions, and so picking a midpoint gives me a good way of cutting the problem in half at each stage", " We're going to come back to this idea of bisection search throughout the term", " It's a really powerful tool, but you can already see how dramatically it reduces the computational cost", ""], "zhKN60gDjk8": ["So far we've been building up our repertoire of Python expressions", " We've seen numbers and strings as primitive data objects", " We've seen assignment, the ability to give a name to a value", " We've seen input and output characteristics", " We've seen the ability to make comparisons, and we've added in looping constructs", " Things like for and while loops", " With that set of tools, they turn out to be sufficient to give us what we call a Turing complete language", " And what does that mean? It says just with that set of tools, anything that's computable, we can compute", " So we can compute anything", " That's actually amazing", " With just that set of tools, anything that's computable, we can capture with a description using those sets of tools", " Sounds like we're done", " And of course we're not, and part of the reason we're not is the code we're able to write so far, those scripts that we've done lack what we call abstraction", " And let me give you some reasons of what I mean by that, and then what the definition of abstraction is", " For example, as you saw before, every time I want to use a script, I've got to reload the file", " And if I want to do it with some different parameters, I've got to change the values of variables before I run that file", " Moreover, or more importantly, I can't use the same variable names other places in the code", " If I've got a piece of code this using x, y, and z, I've got to make sure that they're not accidentally getting changed somewhere else", " So I'm stuck with having to be very careful about the use of names", " And finally, imagine I've got a piece of code that's computing the maximum of two numbers", " I might want to use that many places", " I'm going to have to copy it throughout the code", " Doesn't sound too bad, except it gets very quickly cumbersome to be able to maintain that code", " Suppose I change my mind about the actual details of how I do that computation", " I've got to then search through the code and find all the places where I was doing that, and make that change", " Otherwise I'm going to mess up", " So I lack abstraction, and what we're going to do is add the idea of a function", " A function is going to give us a way to capture a computation, to wrap it up in a package and then treat that function as if it were a primitive", " Something provided to us by Python that we can just use", " Let's look at that", " Here's a very simple example, just to get us started", " Suppose that we want to take two numbers whose names, or variable names are x and y, and we want to compute the maximum and bind that to the name z", " Here's a very simple script that would do it", " Assuming I've got values for x and y, I just do the comparison", " If x is greater than y, I bind z to x", " So there's a binding there, and if not I bind z to y", " But as I already said, notice the problem here", " I'm going to have to copy this everywhere that I want to use it", " That's going to be a real pain", " And I can't reuse x and y, because if I did, I might actually change the values here, and that's going to be a problem", " So I want to capture this", " I keep using that word capture, let's see what that means", " The idea is that we want to wrap up that computation, that set of mechanical steps, that recipe within a particular scope so that we can treat that function, that computation as if it were a primitive", " Then I could just use it by simply calling its name, using the name, and I'll get back that procedure object, and giving some input into that function", " We'll see how to do that in a second", " But a key thing by doing this is that the internal details, the steps inside of the computation are going to be hidden from the users", " They won't know what they actually are, they're going to just treat this like what we call a black box", " Something that we can use that satisfies a particular contract, but we don't need to know the details inside", " And more importantly, what happens inside won't have any effect on computations outside the scope of this function", " What does it look like? Well, here's the syntax for a definition of a function", " It's got, let me in fact give you the next pieces of it here", " It's got a keyword, def, that tells Python I'm about to create a definition of the procedure", " It has a name for a function", " And I've put that here in angle braces just to say it'll be some particular instance", " And the name can be any legal Python name", " And then within parentheses, we're going to have a sequence of 0, 1, or more formal parameters, names for variables", " And those names are going to be used in the function body", " And then we have a colon here", " That is followed by the body of the function, which is any sequence of legal Python expressions that's going to do the actual computation", " And what we'll see is that within that body, we're going to use the names of the formal parameters to identify the places where we want to use the values associated with those parameters", " So those very lanes are going to be used inside the function body", " And of course there's an indentation here just to help us determine the scope, or the length of the function procedure itself", " That's the syntax", " Let's look at an example", " Well, let me go back to my idea of taking the max of two numbers", " Here's a nice function definition", " I say define, and there's the name, max", " Inside of the parens here I've got two formal parameters, x and y, and then the body is simply a description of the computations I want to do", " And I'm going to compare x to y, and depending on the value, whether x is greater than y or not, I'm either going to return the value of x, or return the value of y", " We'll come back to return in a second, but let's just think about how would we use this? So we invoke this, or we call it, as we say, by simply using this sort of an expression", " We say I want to bind z to, and there's the assignment statement, the value that this function max gives me on these arguments 3 and 4", " When we do that function call, when we invoke max of 3 and 4, we literally get the values of these expressions, and those are easy", " In this case they're just numbers", " And given those values, we are going to locally bind x to the value of 3, y to the value of 4, just as if they were like assignment statements in a very particular scope", " And then relative to those bindings, the body expressions are going to be evaluated", " And you can see, then, this is going to do exactly what I did with my little script", " So that's cool", " Now, what about the body? Well, I said the body can be any legal Python expressions", " And in the process, if you like, when I invoke or call a procedure definition, it's having bound the variable names to the values", " I will simply execute or evaluate each of the expressions of the body in turn until one of two things happens", " Either I run out of expressions, I get to the end of the body, in which case a very special value called None is returned, and that is the value of the computation", " And if you think about my invocation, I said I was going to bind z to some value", " If I get to the end of the expression and there's nothing returned, I'm going to just bind it to None", " Alternatively, I will keep executing instructions until I hit that special keyword return that we saw earlier", " And in that case, the expression immediately following that keyword return is evaluated, and that value is returned as the value of the function call", " That value becomes, if you like, the semantic value of calling that function", " And that suggests if you look back at my code, I'm going to be able to then in fact do the computation, and I'm going to be able to reuse it multiple times to get the max of two numbers", " So, to summarize this then, the sequence of events are when we call a function, the expressions for each parameter are evaluated the normal way they would be in Python", " And they are bound to the formal parameter names of the function", " Should be 1 expression for each parameter name", " We then transfer control to the first expression in the body of the procedure, in the body of the function, and we start evaluating", " And those expressions are evaluated or executed until either that return keyword is reached, in which case we get the value of the following expression and return it back, or we run out of expressions, thereby returning None", " And after that, the implication is bound to the return value, and as that return value is what is passed out to whatever asks for it, and control transfers to the next piece of code", " In the next segment, we're going to look at some details of understanding mechanically how this happens, but there's the idea of a function definition", ""], "e7IErqC25nU": ["ERIC GRIMSON: So we've now starting to see some interesting examples of recursion", " In the case of Towers of Hanoi we saw an example of where the recursive call might involve multiple subproblems, in that case too", " We also will see examples of recursion where it may have multiple base cases", " And let's look at another classic example, Fibonacci numbers", " The history of this is several centuries ago Leonardo of Pisa, also known as Fibonacci, wanted to model how quickly rabbits breed", " And he built a model that's not completely realistic, but still gives you an interesting process", " And he described it as follows", " He took a newborn, or he wanted to take, rather, a newborn pair of rabbits, 1 male, 1 female, and put them in a pen", " He assumed that rabbits mate at age of 1 month, and that the gestation period for a rabbit is also a month", " So after 1 month rabbits can mate, a month later, the female will produce offspring", " And in particular, he assumed that the females will always produce a new pair, 1 male, 1 female, every month from the second month on", " And finally he assumed that rabbits don't die", " Which is not true, but it's an interesting way to try and deal with it", " And the question was, how many female rabbits are there at the end of 1 year, 2 years, however many years? So, that was the model", " Here's how we can actually think about it computationally", " We want to know the number of females", " So at the end of 1 month, let's call it 0, we've got 1 female", " That's what we started with", " After the second month, there's still 1 female, but she's now pregnant", " And at the third month, she's going to deliver", " So, in fact, not only is there now that female, but there's a second female", " 1 pregnant", " 1 not", " And in general, we can figure out the formulation of the recursive expression, if you like", " Because in general, every female alive at month n - 2 is going to produce a female at month n", " It takes 2 months for that to happen", " Those new females that are generated at month n, can be added to those that were alive the previous month, because those are the new females", " So the total number of females at month n is the number that were alive at month n - 2, because each one of them has produced a new offspring, plus all the ones that were alive at month n - 1", " And so you can see at month 0 there will be 1", " At month 1 there will be 1", " At month 2", " There will be 2", " At month 3 there will be 3", " And now you can see we're just adding to create the next one", " At month 4 there will be 5", " At month 5 there will be 8", " And 13, and so on", " OK", " We don't really care whether this is a good model for rabbits, although you can see why Australia may be suffering the problems it does when 24 rabbits were introduced into their ecosystem", " But let's think about just writing code to capture it", " Description is nice and easy", " And notice here, Fibonacci has 2 base cases", " Base case for the zeroth month", " Base case for the first month", " That base case in both instances is 1", " And then the recursive case is what we just described", " OK", " And the code, nice and simple", " I'm going to add 1 new thing here, which is this assert statement right here", " So let me spend a second on that", " Here's my definition for Fibonacci", " I've got a specification", " It says assume that x is an integer and it's greater than or equal to 0", " If that's the case, I'm going to return the Fibonacci number of x", " Assert is something that basically takes an expression, which is a Boolean, and in this case, it's an expression that has 2 subexpressions, both of which are Booleans", " And what assert does is it a checks to see is that statement true", " So here what you see we've been doing is we're saying, given x, let's make sure that it is, in fact, an int by checking its type", " And let's make sure that it satisfies the condition of being greater than or equal to 0", " And if both of those are true, then the body of the procedure will be evaluated", " But if either of them is not, if the overall expression for the assert is false, it's going to stop and return an error", " Inside of fib, it's exactly what we'd expect", " I've got two base cases", " I happen to be checking them with just one Boolean combination", " Two base cases and a value to return and otherwise I'm returning, just like in towers, a recursive call done twice, I'm returning the sum of fib(x) - 1 , and fib(x) - 2", " OK, let's try running it", " So I'm going to go over to idle", " I have my version of fib", " And let's check", " Let's check the base cases", " fib(0) should be 1", " It is", " fib(1) should be 1", " And then what did we also know? Well, we said that fib(2) ought to be the sum of those two", " And it is", " fib(3) ought to be the sum of the previous two", " And it is", " fib(4) ought to be the sum of the previous two", " And it is", " And you can see it's doing pretty well", " And so, how many at month 12? 233", " Gets bad fairly quickly", " Just to give an example of that, at 13 it jumps up", " And If I go to something like say fib(15) , or fib(16) , it's climbing pretty quickly", " But there we are", " We've got a way of computing Fibonacci", " Great", ""], "QgDq9EieZTg": ["ERIC GRIMSON: Now, you may still be a little concerned", " I've tried to show you that, using this environment model, we can see how the computation of a recursive function should do the right thing, but you may still be saying, wait a minute", " Does this really work? How do we know that our recursive code will work? And when I say will work, how do we know both that it's actually going to stop, and how do we know that it computes the value that we want it to? So I'd like to walk you through that a little bit just to give you a sense of how we can reason about it", " Let's start with the iterative version", " iterMul we know terminates because b starts out initially positive, and each time through the loop, it decreases by 1", " And just by simple logic, if it starts out as a positive or non-zero, non-negative value as an integer, and we keep decreasing by one, at some point, it's going to get down to 0, which was our test case, and it's going to stop", " Great", " Now, what about recursive mul? We can actually reason about it in a similar way", " We know that recursive mul, if it's called with b as the value of 1, stops, because there's no additional work to do", " The code simply said return a value", " So we know it stops, and we also know it gives us back the right value", " What else do we know? Well, we know from our code that if we call recursive mul with an integer bigger than 1 as a value of b, it makes a recursive call with a slightly smaller version, in fact, b - 1", " But by exactly the reasoning that we just used here, we can apply the same argument to that call", " It's going to make a recursive call with a smaller version of b", " And because b is reducing by 1 each time, it started a bigger than 0, eventually we have to get to a place where it has a recursive call with b = 1, which says we're going to get back down to that case and we're going to stop", " Great", " So we know it stops", " How do we know it does the right thing? Well, we're going to come to that", " And to do that, I'm going to burrow with a little bit of a side tour a tool for mathematics", " Because in fact, what we can do is we can use the idea of mathematical induction to reason about code", " What's mathematical induction, say? Well, if you haven't seen it before, here's a simple definition", " If we want to prove a statement, a mathematical statement that is indexed on the integers, that is, it's a statement where one of the parameters is an integer, if we want to show that that statement is true for all values of n, here's how mathematical induction works", " We're first going to prove that it's true for n's smallest value, which will typically be when n = 0 or n = 1", " And then we're going to prove that if that statement is true for an arbitrary value of n, you can show that it must be true when n is 1 bigger", " If we can prove these things, we can prove it's correct for small values, and we can prove that, given any value, it's true for the next larger value", " Then induction says we can assume it is true for all values of n", " That's powerful, because it's a way of helping us deduce that our code, if we can use it there, works all the time", " This may sound a little funny, so let's look at a very simple example from math", " And here's the simple example", " If I add up all the integers from 0, 1, all the way up to n, the claim is that that is equal to n * n + 1, all divided by 2", " That's a little statement of fact from mathematics", " But let's see how induction would actually let us prove that", " So if we wanted to prove it, what do we have to do? Well, we've got to look at the base case, the simple case", " If n = 0, what do we know? Well, this left hand side of that equation is just 0, so that's done", " In the right hand side, I'll substitute n", " If n = 0, that says 0 * 1 / 2, well that's 0, so we know it's true", " OK", " The inductive step says that we need to now assume that this statement is true for some value, let's call it k", " And what we need to then show is that, as a consequence, we can also established that it's true for k + 1", " So we're assuming it's true for smaller versions of the problem, and we want to show it's for the next larger version", " If we can do that, then can prove it's true for all values", " So what do we need to do? We need to show that this is equal to that", " OK, but this left hand side, that is just the same as taking this part + k + 1", " And that part, we've assumed is true", " That was part of our assumption", " We said it's true for smaller versions", " So we know why that one is given by this definition", " So that is simply this plus that", " OK", " That's nice", " And then, I can just do a little bit of algebra", " I'm not going to do it here, but if I just do the additions together, by a little bit of algebra, I can show that this piece here becomes that piece", " Ah, and that's exactly what I wanted to prove, because this is just that definition where n = k + 1", " What have I done? All right, so, I show it's true in the simple case, and then I said, let's assume it's true for all cases up to some size", " Given that I can prove it's true for the next larger case, by induction, I can assume that it is true for all sizes", " Great", " What does that have to do with code", " Well, the same logic applies to code", " There's my recursive mul, and let's look what we have", " In the base case, we can show that recursive mul stops, if b = 1, it just returns a value, and more importantly, it gives us the right answer", " It gives us back a", " OK", " a * 1 is just a", " And then what do we know? In the recursive case, we can assume that recursive mul correctly returns an answer for problems of size smaller than b", " And then what do we know? Well, by this step right here, we know that this is not only going to give us an answer, it's going to give us back the correct answer for a * b - 1, and therefore, we can deduce that this will return an answer because it's just doing an addition, and giving us back the right answer", " So it must give us back the correct answer for problem size b", " And therefore, by induction, we've just shown that this code always stops and returns the correct answer", " And when we say always stops, stops if we give it an appropriate value for a and b", " We're not going to do a lot of proofs throughout this course, but this is one nice way of seeing how thinking recursively actually works very well", " And we're guaranteed, if we do it properly, that it will give us correct answers, and it will terminate", ""], "J1zJNuEFw2U": ["So we're going to do one last example in this sequence", " We've been looking at approximation algorithms", " We've been looking at guess and check, exhaustive enumeration", " We saw when we wanted to move to floating point, we needed to be a little more clever, and that led us to the idea of bisection as a smart way of reducing the computation at each stage, especially when we have functions or problems where there's a monotonic relationship between the value we're looking for and the guesses we're making", " There's one other, very powerful, algorithm for doing approximations, due to Sir Isaac Newton, often called the Newton-Raphson algorithm because it was found at the same time by Newton and by Raphson", " Here's the basic idea behind it", " We want to find the root of a polynomial", " I'll remind you a polynomial, p(x), is some sequence of coefficients and powers, so it's a_n * x to the n-th power + a_n - 1 * x to the n minus first power and so on", " It's just a sequence of numbers times powers of x, and what we often want to do is find a value r such that p(r) is equal to 0", " We want to find the root, the place where, on that x-axis, that graph crosses 0", " Now, that sounds like a lot of math", " Let's make it a little simpler", " A simple way to think about this is if we want to define, for example, the square root of 24, we just need to find the root of the polynomial x^2 - 24", " Makes sense, if we combine the value of x such that x^2 - 24 is equal to 0, we're done because that's the thing we want", " Now, what Newton showed was that for things like polynomials, if g is an approximation to the root, the place where it's equal to 0, then g - p(g) / p'(g) is a better approximation, where p' is just the derivative of p", " And if you haven't done calculus, don't worry about it", " We'll show you in a second what that means, but this is a powerful tool", " Newton proved this, that given an approximation, g - p(g) / p'(g) is a much better approximation", " OK, so what does this have to do with things? Well, let's look at an example, a really simple case", " Suppose our polynomial is just some coefficient c times x^2 + k, then its first derivative is just 2cx", " And in particular, if the polynomial is just something simple, like x^2 + k, then the derivative is just 2x", " Why is that nice? Well, Newton-Raphson says that given a guess g for the root, a better guess is just shown right here, is g - g^2 - k, all divided by 2g", " And remember, we were using this form to find square roots, because it says if k is the value of the square root I want to find, then that's the polynomial I want to use", " So this little formula says here's a better way of finding a guess for the square root of k", " All right, let's put that together", " We can now have another way of generating guesses, which we can check, which turns out to be very efficient, so here's some code that would do it", " Again, I've got a little epsilon that tells me how close I want to get", " Let's assume I'm looking for the square root of 24", " We'll try some other examples in a second", " I'm going to give an initial guess, which will just be y / 2", " It's not a very good guess, but it's reasonable place to go", " And look at the code", " Very crisp, very clean, very efficient", " It basically says check to see am I close enough", " Is the difference between the guess^2 and y less than or equal to the epsilon", " If it's bigger than that, I'm not close enough", " And then Newton says get a new guess by taking the old value of guess, taking guess^2 - 1, divide it by 2 * guess, which is the derivative, and use that to create a new binding for guess", " You just keep updating", " Do that until I get close enough, and when I'm done, just print out the result", " Nice and crisp", " What's this doing? It's generating guesses", " There's the generation", " But it's not doing it exhaustively", " It's using this property of mathematics together, and then it's testing, right here, to see if I'm done", " So it's another example of a generate and test kind of algorithm, and let's look at what happens if we run it", " So in my IDLE, I've got just a version of that", " I'm going to do it with 24 to start with", " And if I evaluate this, it prints out its guesses, starts with a value of 14, and then goes to 7, 5", " And you see, in just 4 guesses, it gets a pretty good answer", " Let's try a different example", " Let's try our good old example of 25", " Again, if I evaluate that one, you'll see again, in basically five steps because the first one was using 12 and a half, it gets to a quite good approximation of it", " Let's try something even bigger", " I'll go back over here", " Let's do my example of 12345 and let's evaluate that", " And if we do that-- huh", " What did it take me? 1, 2, 3, 4, 5, 6, 7, 8, 9-- in 10 steps, it got to a really good solution", " So this is what? This is another way of simply figuring out how to generate good guesses and then testing them", " So we've now seen several examples", " We've got this idea of iterative algorithms", " We're using the same piece of code over and over again", " We're using that to build up this idea of a guess and check method where we guess solutions and then check them", " We use a looping construct to generate the guesses, and then we just check and keep going", " And what have we seen? We've seen we could do exhaustive enumeration, where we just do a whole bunch of trials", " We could cut down on the search in a clever way by simply using bisection, bisecting the range of places where we're looking for guesses until we get to something close enough", " Or for the group finding case, which it turns out to be a very general case, we can be really efficient by taking advantage of a mathematical property to very quickly cut down on where the solution lies", " Those are examples of iterative algorithms, and they're examples, in particular, of guess and check methods that turned out to be really powerful", " And we're going to give you a chance to explore those as we move through the class", ""], "bckOwpozezo": ["Chris Terman: Our next example comes from the world of text formatting, where we're trying to position the words on a page to produce an attractive and readable layout", " Two challenges here", " First, we have to come up with a good metric for measuring the goodness of a layout", " And secondly, we want to structure the problem in such a way that there's a good possibility of overlapping subproblems as we do our search", " Compare how we choose to structure the subproblems for the layout problem versus how we did it for the 0/ 1 knapsack problem", " I think you'll find there's a lot of similarities", " Our goal in this problem is to find the optimal layout of words in a paragraph so as to make the result look the most pleasing", " This over here is simply the operation of a greedy algorithm, where we take the words as they come along, and we keep adding them to the line until we run out of space and the next word would cause us to go beyond the margin, so what we have to do is to start a new line", " So this is the result of a simple greedy layout algorithm", " People don't like this because of the large indentation here", " And in fact, there are four spaces here at the end of this line", " And that's considered to look ugly", " They would much prefer a layout that looks like this, where the right margin is kept as even as possible", " In this case, that's achieved by having two spaces at the end of each line", " So this is what we would like to achieve if possible", " And the way that was reduced to an algorithm-- and this is following the example of Don Knuth and his tech layout language is we simply compute the number of spaces at the end of each line", " We're going to actually omit the last line from this calculation, because we don't mind if the paragraph has extra spaces on its last line", " So we're going to omit the last line", " But otherwise, what we're going to do is to compute the number of spaces in each line, take the cube of that result, and sum it up to compute the badness of a particular layout", " And we're trying to find the layout that has the minimum amount of badness", " So in this case, with the four spaces at the end of the second line, we end up with a badness of 4 cubed, or 64", " In the better example, over here we see we have basically two spaces at the end of two lines", " So the total badness is 16", " And so, according to the badness measure, this layout is to be much preferred to the original greedy layout", " So how do we divide the line breaks problem into subproblems? Well, here's our formulation", " We're going to define formula called lineBreaks, which, given a list of words, a starting column-- so initially that will be zero, because we're starting on the first column of the first line-- and a maximum width, which is the total width in the previous example-- that was 13 columns-- that we want the paragraph to be laid out with, is going to return the actual paragraph", " So this is a string, which represents the optimal laid out paragraph", " And this is the cost of the badness", " So this is what we're trying to minimize here", " So how do we break an initial problem into subproblems? It goes as follows", " What we do is we consider taking the first word from the list and basically saying, look, there's no line break after this word", " So what we're going to do is to lay out the rest of the list, but we're going to start after the first word", " So the remaining words will start on the same line as the current word, except the starting column will be moved over by the width of the first word", " Plus a 1 that corresponds to the spaces between the first word and the rest of the words", " So the subproblem is, please lay out all the rest of the word list, but leave room in the current line for the current word", " And when we get back, we'll simply modify the string that represents the paragraph that's been laid out to include us at the beginning of the first line of that paragraph", " And then, as we return up, more words will accumulate on each line", " So that's the first alternative", " The second alternative is to say, look, maybe what we'll do is to put a new line after the first word in the list", " In other words, the first word in the list will actually be the end of the current line", " So laying out the remaining words will basically start on a new line", " So the column that we're going to ask for all the rest of the words to be laid out on, the starting column, will be starting at zero", " OK", " And so again, we have the subproblem", " And then, when we get back the answer for the subproblem, we'll go off and add our word at the beginning of that list, but instead of separating it from the remaining words by a space, we're going to make sure that the remaining words start on a new line", " So we'll put in this new line character here", " And since our current word is at the end of a line in the paragraph, we'll go off and compute the cost, now, and add that to the total cost of the paragraph", " So what we do is we go through the entire word list until we get to the end, and then we're slowly building the paragraph back up, computing the cost every time we run across the end of a new line", " The lecture code includes an implementation of the line breaks algorithm along the lines we just discussed", " There are two cases where we terminate the recursion", " One is when we reach the end of the paragraph, there's no more words to lay out", " And the other is if the word that we've just placed on the line actually go goes past the end", " In that case, we want to return an infinite cost for this alternative, because it's illegal for a word to go past the margin", " Otherwise, we've implemented the two alternatives just as described before-- one where the remaining words are laid out on the same line as the current word, and the other in which the remaining words are laid out on a new line", " We simply choose the least costly of the alternatives to return as the desk layout for the word list, including the first word", " Just for comparison, we've included a definition of a greedy layout algorithm, so we can see what sort of badness it computes, and hopefully our layout algorithm will do better", " And we've included a couple test cases", " One is the short word list that we used at the beginning of this segment", " And the other is a longer statement involving a piece of the Gettysburg Address", " Notice we're doing an exhaustive search of where to place the new lines, and we would anticipate that with this long a list, that the recursive search-- the exhaustive search-- will in fact run for a very, very long time", " Let's give it a whirl", " Let's start by testing this on our short list", " So we're going to test breaks, and we're going to use the original little five or six word paragraph, and we're going to lay that out in a width of 13 columns", " And you can see that our optimal layout did achieve a cost of 16", " And the greedy layout had the cost of 64, just as we computed on the first slide", " Now, let's try our longer example", " So this is with the second word list, the Gettysburg Address-- or the first couple paragraphs of the Gettysburg Address", " Let's try it with a width of 40", " And in fact, you can see that it's not going to return, because it's off trying that optimal layout", " And it's going to have to work for a very long time, because the exhaustive search, or trying every possible combination of line breaks, is essentially computationally intractable", " So I'm going to stop that", " And you can see, I was really deep in the recursion", " And then, what I'm going to do now, is go off and memoize line breaks", " So \"memoize", "\" So this is the advantage of having that general purpose function", " We don't have to rewrite any of our code", " We're just going to apply our general purpose technique for dealing with overlapping subproblems, was to use our little cache of previously computed answers", " So now, if we do that, and we test it now-- again, using the long list with the 40, we can see that we get our answer right away", " The line breaks had a total cost of 1068", " And you can see the margin here is as smooth as it felt it could make it", " The greedy breaks had a cost of 2124", " And the real difference here occurs on this line, where we can see that after the word great, there's a large indent because of \"battlefield\" being such a long word", " And that's what caused this cost to go through the roof", " So this is yet another example of a implementation where there must be a large number of overlapping subproblems", " And it's interesting to think about why that is", ""], "2Y5CrREsJ-4": ["computer to do things for us", " As we've said, we want to take that idea of computational thinking, taking a problem and breaking it down into a sequence of mechanical steps that will let us deduce solutions to that problem", " And we want to be able to take that description and somehow convert it into a form that the computer can do the work for us", " That says we need a way of describing those sequences of steps, and that's where the programming language comes in", " Programming language is going to define both the syntax and semantics that we need to translate our computational ideas into mechanical steps", " Syntax, I'll remind you, says how we put together legal expressions? Semantics says, how do we deduce the meanings associated with those expressions, which is going to let us solve the problems that we want", " We're almost ready to start talking about a programming language, but we need to make one more choice", " And that choice comes down to the kind of programming language", " One way to think about this is, no matter which language we use, the interaction with the computer will all be roughly the same", " We're going to take an input and provide it to the computer", " That's what we call the source code", " That input is then going to go through some kind of computational process", " And when we're done, we'd like to get a result printed out or returned by the computer", " And right here is where that computational process is going to take place", " And we have some choices here in terms of how the computer actually deals with taking our input and reducing it to an output", " And let's look at what those choices might say", " One choice is that we can use what's called a low level programming language", " Low level says that the instructions we type in or that we enter into the computer are very similar to the internal control unit we saw last time", " Those instructions might be at the level of saying, move data from one location of memory to another, or execute a simple ALU, or arithmetic logic unit operation, like add, subtract, compare", " It might also involve jumping to a new point in the sequence of instructions based on that comparison", " But the programming would be done in a very low level", " Once you make that decision to use this kind of a programming language, then the stages within the computer are pretty straightforward", " There is a process called a checker, which takes that low level code and just confirms that the syntax is correct and that the static semantics are correct", " And then, it passes the sequence of instructions on through a process called the interpreter that simply follows that sequence, much as we saw last time, ending up with some output that gets printed back out to us", " So on a low level language, we're programming, basically, at the level of the machine", " That's one option", " There's a second option, though, which is to use what's called a high level language", " And a high level language uses more abstract kinds of terms", " We might want to talk about having the computer think about, invert a matrix, compute a function, compare two complex data structures", " We'd like to be able to program, if you'd like, at the level of thinking about higher kinds of abstractions", " Now here, again, we've got a choice", " In a compiled language, those abstractions are then first checked, as they did before, but then converted back into low level code", " So there is a special thing, or special process, inside the computer called a compiler that takes the checked sequence of instructions and reduces or converts them back down to those basic computer instructions that we know we need and those are then run through the interpreter in order to execute the actual process", " So this is certainly one way to do it, a compiled language", " There's an alternative", " And the alternative is, again, to have a high level language, run it through the checker as before", " But in an interpreted language, there's a special program that converts that source code to an internal data structure and then sequentially converts each step into a low machine instructions and executions", " That says we're going to, one instruction at a time, do the conversion and execution", " And in this case, this is the kind of like you're going to use", " In this course, we're going to use Python, which belongs to this class of interpreted programming languages", " Now, you might say, so what are the choices? What are the tradeoffs here? And there are a couple of tradeoffs", " In a compiled language, the code typically is faster because we do all the work ahead of time, through the compiler, to convert our instructions into the low level machine instructions", " So we can make them very efficient, which means they'll run faster", " But one of the challenges is if we have a bug or an error in our code, when the compiled code hits that error, it can often be difficult to figure out what caused it", " Because we're way down in the weeds of those compiled instructions and figuring out what corresponding point in our actual instructions led to that error can be a challenge", " In an interpreted language, it can be a little slower, not badly, but a little slower, because we're doing the conversion on the fly, one instruction at a time", " On the other hand, when we do hit an error or a bug, it is usually easier to determine what caused that error because we know exactly at what point in our code we were at when that error occurred", " Again, there are tradeoffs here", " Different people like different versions of languages", " For us, we're going to use Python, which has this property of being an interpretive language", ""], "AU66NP1kQm0": ["Eric Grimson: All right, we want to measure complexity", " We're going to use this random access machine model, which says we're going to count basic steps", " And we want to measure this in the worst case", " And we want to measure it basically as a function of the size of the problem", " So what we need is a formal way to talk about the relationship between the running time and the size of the input", " And as we suggested, what we're mostly interested in is what happens as the size of the inputs gets very large, as it approaches infinity", " So let's look at an example of how we might capture that a little more formally", " And in particular, let's look at a little example", " I've written a function that's got 3 loops in it", " I'm first going to loop for i from 0 up to 999", " And I'm going to set answer equal to i", " It's a boring thing to do, but because I want to do something like that, I'm going to do it", " Then I'm going to loop for i from 0 up to x - 1 for whatever the input x is", " And I'm going to just increase the answer by one", " And then, finally, I'm going to have a nested loop", " I'm going to loop for i from 0 up to x - 1", " And for each version of i, I'm going to loop for j from 0 up to x - 1", " And I'm going to set answer to increase by 1", " Not a big deal", " What I want to know, though, is what amount of time does this take? And ignoring the issues of the overhead, if you like, of running the for loops, you can see that in this first loop here, there are going to be 1,000 steps, no matter what x is, because I'm doing it 1,000 times", " For this second loop, there are going to be x steps, depending on what the input x is", " And for this final loop, well, I'm going to do this inner loop x times", " And I'm going to do that another x times", " So I'm going to do x squared things", " So I've got an expression that basically says, I've got 1,000 plus x plus", " And I've got a 2x squared there", " The 2 is, I guess, if I really think about it, I'm doing 2 steps here", " And I should actually have a 2 there, because I'm really doing 2 steps there, as well", " All right, so I've got 1,000 + 2x + 2x^2 if each of these things is a basic operation", " OK, with that, let's think about this", " Again, I'm going to change this slightly", " That should really be 2x", " I've got 1,000 + 2x + 2x^2", " So let's think about x", " If x is small, the constant term dominates", " This term is really the big one", " It's going to be, if x is 10, then 1,000 out of the, basically, 1,200-- and actually, it should be 1,220-- steps are in the first loop", " But still, almost all of it's done in the first loop", " On the other hand, if x is large, then this term dominates", " So for example, if x is a million, then the first loop takes a tiny, tiny fraction of the time", " The second loop takes only a tiny fraction of the time, because we've got a billion in summed operations that we're doing here", " And you can see that, in fact, in this case, all of this is dominated by this term", " We really only need to consider, when we look at code then, that nested loop, the quadratic component", " And does it really matter if this part takes 2x^2 steps as opposed to, say, x^2 steps? A little bit, but not really", " In our example, if our computer executes 100 million steps per second, then the difference might go from five and a half hours down to two and a quarter hours", " So the 2 does matter in terms of practical time", " But on the other hand, if we could find a linear algorithm here, something that varied with x, not with x^2, then this thing would run in a fraction of a second", " And so again, it goes back to saying those multiplicative factors probably are not crucial", " It's really this order of growth that is the most important thing that we want to deal with", " So what we're saying is we want to use asymptotic complexity", " And what does it mean? We're going to describe the running time in terms of the number of basic steps", " If the running time is a sum of multiple terms because of multiple components to the code, we're going to keep the one with the largest growth rate", " And if that remaining term is a product, we're going to drop any multiplicative constants", " And so here's where the asymptotic portion comes in", " We're worrying about it as the problem size goes to infinity", " That's really what we're concerned about here", " The notation we'll use-- we borrow from theoretical computer science-- it's called big O notation", " It comes from the Greek letter Omicron, which Donald Knuth picked when he was measuring these kinds of things", " And we'll use big O as a way to give an upper bound on the asymptotic growth of a function", " What we're going to do next is look at some examples of the different kinds of asymptotic growths that we have", " And these capture, if you like, different classes of complexity of functions", ""], "Zi3q2FB1fDo": ["NTA"], "CIld2wLmjXI": ["ERIC GRIMSON: We've now seen a bunch of examples of recursive functions", " Seen some of the power of them", " We keep coming back to this idea of break a problem down into smaller versions of the same problem", " Really great way of trying to tackle a problem", " We're going to do one last thing", " And that goes back to when we ran fib", " When we ran Fibonacci, we might have noticed that as we made the arguments larger and larger, it slowed down", " Which is not surprising", " It's calling itself multiple times", " But suppose we wanted to actually count the number of times that fib called itself recursively", " Multiple ways of doing it, but one of the ways in which we can do this is to use what's called a global variable", " What does that mean? Well, so far, all the functions have communicated with their environment strictly through their parameters and their return values", " If it's when we call a new function, it creates an environment with some parameters passed in", " It does some work internally, and it returns a value as the value of its response", " We can make a variable or declare a variable to be global", " And what this means is that the name is defined at the outermost scope of the program, rather than the scope of the function within which it appears", " It's global because it's going to appear up at the top level", " It's going to be part of what we want to deal with when we're interacting with, for example, the Python shell", " As it notes here, this can be a bit dangerous", " And we'll talk about that in a second", " But let's just look at how we might do this", " So, here's the idea", " We're going to call this a metered version of Fibonacci", " It has much the same form as before", " There is the recursive call, just as we had before, using a different name, of course", " But we do two things", " Right here, we make a declaration that says the variable numCalls is global", " That means it's going to be bound way up at the top, at the highest-level environment", " Inside of fibMetered, we're going to actually change numCalls", " This says every time we call fibMetered, we're going to increase that global variable by one", " Great", " So that's going to count how many times it's called", " We can test this with a little test script here", " I'm going to run fib for some number", " I'm going to have i roll over from 0 up to n", " And notice what I'm going to do", " Each time I go through the loop, I'm going to again say numCalls is a global variable", " It's defined up in that top-level place", " And I'm going to set it to zero", " That is going to have the effect of in the global environment changing numCalls to zero", " And then I'm going to actually do some work and print up some results", " I'm going to do the work of figuring out what Fibonacci is", " The call to fibMeter will, every time it calls it, change numCalls by one", " And when I'm done and when it returns, I can print out how many times was that actually called", " OK", " Let's see what happens if we do this", " I'm going to go over and start up over here inside of my IDLE environment", " And if I load that in, let's actually do a test on fib", " And this put means we're going to do up to five", " And it now tells us, oh cool", " When I call a fib on zero, the answer is one", " It was called one time", " Makes sense", " When I call fib on one, the answer is one", " It was also called one time", " We knew those were the base cases", " And then you can see the responses as we move up", " So let's make this a little bit bigger", " Let's do testFib-- oh, let's make it up to 20", " Then we'll see what it does here", " You see it's moving pretty quickly", " It's starting to slow down a little bit", " But we're actually now calling testFib in that metered form", " And it's showing us how many times it's called", " Also notice, if you look at the numbers, it's clear that we're resetting numCalls each time around", " And that, if we go back to our slides, came from right here", " Each time through the loop and testFib, we reset numCalls to zero up in that top environment", " So that when we go ahead and call fibMetered, it is starting from zero and doing a count for each time it calls recursively within itself", " A nice tool", " A tool that's really kind of handy, and something that we'll come back to, because it is a way of being able to keep track of some things", " But I want to finish with a couple of comments", " First one is use it with care", " Putting a variable as a global variable is destroying the locality of the code", " One of the beautiful pieces about recursive code is all of the function call contains within it all the information it needs", " The parameter's passed in, it does all the work internally, locally, and it simply returns a value back out", " That is an elegant way of being able to not only think about what's going on, but to be able to deal with the code", " Once we have global variables, they can be modified or read in a wide range of places", " And that's going to make it really easy to break the locality, especially if someplace outside of the function we're dealing with makes a change for global variable and that affects the computation inside that local call to a procedure", " This is going to allow the potential for introducing bugs", " And most computer scientists will be very strong about arguing that one should not use global variables if at all possible", " It is much better to encapsulate the computation locally", " But here's an example where we're metering things, where having a global variable can be really handy", ""], "UreW8x38Z2Y": ["NTA"], "BvooIjkNJ24": ["computer to do things for us", " As we've said, we want to take that idea of computational thinking, taking a problem and breaking it down into a sequence of mechanical steps that will let us deduce solutions to that problem", " And we want to be able to take that description and somehow convert it into a form that the computer can do the work for us", " That says we need a way of describing those sequences of steps, and that's where the programming language comes in", " Programming language is going to define both the syntax and semantics that we need to translate our computational ideas into mechanical steps", " Syntax, I'll remind you, says how we put together legal expressions? Semantics says, how do we deduce the meanings associated with those expressions, which is going to let us solve the problems that we want", " We're almost ready to start talking about a programming language, but we need to make one more choice", " And that choice comes down to the kind of programming language", " One way to think about this is, no matter which language we use, the interaction with the computer will all be roughly the same", " We're going to take an input and provide it to the computer", " That's what we call the source code", " That input is then going to go through some kind of computational process", " And when we're done, we'd like to get a result printed out or returned by the computer", " And right here is where that computational process is going to take place", " And we have some choices here in terms of how the computer actually deals with taking our input and reducing it to an output", " And let's look at what those choices might say", " One choice is that we can use what's called a low level programming language", " Low level says that the instructions we type in or that we enter into the computer are very similar to the internal control unit we saw last time", " Those instructions might be at the level of saying, move data from one location of memory to another, or execute a simple ALU, or arithmetic logic unit operation, like add, subtract, compare", " It might also involve jumping to a new point in the sequence of instructions based on that comparison", " But the programming would be done in a very low level", " Once you make that decision to use this kind of a programming language, then the stages within the computer are pretty straightforward", " There is a process called a checker, which takes that low level code and just confirms that the syntax is correct and that the static semantics are correct", " And then, it passes the sequence of instructions on through a process called the interpreter that simply follows that sequence, much as we saw last time, ending up with some output that gets printed back out to us", " So on a low level language, we're programming, basically, at the level of the machine", " That's one option", " There's a second option, though, which is to use what's called a high level language", " And a high level language uses more abstract kinds of terms", " We might want to talk about having the computer think about, invert a matrix, compute a function, compare two complex data structures", " We'd like to be able to program, if you'd like, at the level of thinking about higher kinds of abstractions", " Now here, again, we've got a choice", " In a compiled language, those abstractions are then first checked, as they did before, but then converted back into low level code", " So there is a special thing, or special process, inside the computer called a compiler that takes the checked sequence of instructions and reduces or converts them back down to those basic computer instructions that we know we need and those are then run through the interpreter in order to execute the actual process", " So this is certainly one way to do it, a compiled language", " There's an alternative", " And the alternative is, again, to have a high level language, run it through the checker as before", " But in an interpreted language, there's a special program that converts that source code to an internal data structure and then sequentially converts each step into a low machine instructions and executions", " That says we're going to, one instruction at a time, do the conversion and execution", " And in this case, this is the kind of like you're going to use", " In this course, we're going to use Python, which belongs to this class of interpreted programming languages", " Now, you might say, so what are the choices? What are the tradeoffs here? And there are a couple of tradeoffs", " In a compiled language, the code typically is faster because we do all the work ahead of time, through the compiler, to convert our instructions into the low level machine instructions", " So we can make them very efficient, which means they'll run faster", " But one of the challenges is if we have a bug or an error in our code, when the compiled code hits that error, it can often be difficult to figure out what caused it", " Because we're way down in the weeds of those compiled instructions and figuring out what corresponding point in our actual instructions led to that error can be a challenge", " In an interpreted language, it can be a little slower, not badly, but a little slower, because we're doing the conversion on the fly, one instruction at a time", " On the other hand, when we do hit an error or a bug, it is usually easier to determine what caused that error because we know exactly at what point in our code we were at when that error occurred", " Again, there are tradeoffs here", " Different people like different versions of languages", " For us, we're going to use Python, which has this property of being an interpretive language", ""], "aTuYZqhEvuk": ["NTA"], "r-lL6JT665g": ["NTA"], "FMGal3lXcjw": ["NTA"], "qA24CgJ1Zc8": ["ERIC GRIMSON: OK", " So we've now seen how to create simple expressions", " We can take objects that are numbers like integers or floats", " We can combine them together with operators, so we say 3 plus 4 or 3 plus 4 all in parentheses times 5", " That gives us a way of doing some simple computations, but it's pretty boring", " It basically says we got a calculator", " So we can type in expressions and get out values", " But we like to obviously do more complicated kinds of things", " One thing we need in order to make that happen is what we call a means of abstraction", " While we can certainly write arbitrary expressions, it would be valuable having written it down and gotten the value of an expression to be able to remember, to save it away by giving it a name, and then using the name to get the value back whenever we needed it", " Fortunately, we have that ability", " It's called assignment", " And in Python, the format of that is shown here", " We type in word or a sequence of characters followed by an equal sign followed by some expression whose value will then be associated with that word", " So if I go over to my Python shell, I can do things like I'm going to say, give the name pi 3", "14159", " And notice when it print it out, it doesn't mean anything", " It simply has done that assignment", " That is it basically-- as we're going to see later on-- created a binding of the name pi to that value", " If I want to see the value of pi, I can simply ask the Python interpreter to give it to me, and it prints it back out", " So I could do another binding", " I can say, I've got a radius of 11", "2", " Again, notice that it doesn't print anything out", " If I want to get the value of radius, I can ask for it", " But I can also now do things like create expressions", " So I'm going to assign the name area to", " And I can now write an expression as I would have before with now not just numbers but names whose values are also numbers", " So the area is pi r squared, where r is my radius", " And I can say, OK, what is the value of area? And it did that computation", " So I have an assignment statement", " And notice here I'm using a single equal sign, which is why we use the double equal sign for comparison", " A word or a name, an equal sign, and expression says, get the value of that expression and bind to it or bind it to if you like the value of the name associated on the left hand side of that expression", " So let's look at that in a little more detail", " We say that we're binding a variable or a name to a value", " And what does that mean? That statement pi equals 3", "14159 literally assigns the name pi to the value of the expression to the right hand side of the equal", " And you can think of this as literally creating a binding between a name and a value stored somewhere in the computer", " So over here are all the values that are stored away in the computer", " And I have somewhere within the computer a listing of all the names whose bindings I have done", " As we just saw, we can retrieve the value associated with the name by simply invoking the name, just asking for what is the value pi or pi", " Now I can change the bindings", " So having the bound a variable name, I can do another assignment statement", " So, for example, if I go back over to my Python shell, I could change the value of radius", " Remember, initially we had radius of 11", "2", " Let's change it to something different", " Let's changes it to in fact-- I'm going to make this 14", "3", " So how do I do that? I say let's have radius be 14", "3", " Now what's my value of radius? There it is", " What that's done in my diagram over here is it's change the binding for radius", " Remember before it was 11", "2", " It has now changed into something else", " But notice that area hasn't changed", " And in fact I can confirm that", " The area is still 3", "94 point a whole bunch of stuff", " And that's because my evaluation of the binding for area having been done earlier has simply stored away that value", " As you can see right here, it doesn't have an expression of value", " And it is the particular value", " So rebinding radius does not change the binding associated with area", " An easy place to make a bug or have a mistake and something that you want to keep an eye out on as you move forward in terms of using these ideas", ""], "f3TskgnL_3U": ["NTA"], "qic9_yRWj5U": ["take place when functions are called", " Let's do a couple of other examples to just really reinforce this point", " Because it's really important for you to understand bindings of variables and how they take place", " For this one, I'm actually going to just go over to Python and IDLE, and type in a little example", " Imagine I say I'm going to create f(x) to have the following property", " I'm going to bind y to 1", " I'm going to bind x to be x + y", " I'm going to then print out the current value of x, that x is equal to-- sorry", " I'm printing out the string x is equal to and then the actual value of x", " And then I'm going to return the value of x", " And now inside of Python, I set x to 3", " I set y to 2", " And I'm sorry", " I mistyped that", " So let's do that properly", " There's y is equal to 2", " And I bind z to be f(x) ", " And I run it", " And it says x is equal to 4", " And if I now ask, what's the value of z? It's 4", " x is 3", " And y is 2", " Hm", " I want to see, so why does that happen? Why is it that x is now returning an internal value of 4 here", " But externally is 3", " And z is 4", " And y is equal to 2", " So why does this happen? This is going to give us a chance, again, to look at what happens inside of the binding", " So let's look in detail at what happens here", " I create a definition of f", " And in my global environment for Python, that says I've got a binding of f to that procedure", " And to remind you, inside there, there's the formal parameter for x", " And there is the interior", " And I didn't repeat all of it", " It's got that print statement to it", " But basically there is that interior that deals with all of those pieces", " And notice that it's just there as text", " It hasn't actually been evaluated yet", " I then go ahead and do the bindings of x is 3 and y is equal to 2", " And at this stage in the computation, I've got bindings for them inside the environment", " Key thing to notice", " In the global environment x is 3, y is 2, and f is bound to a procedure object whose body has references to x and y but nothing more", " Let's move on in the computation", " I now say I want to invoke f", " I'm going to eventually bind z to the value returned by calling f on x", " But I'm invoking f of x right there", " What does that do? Well I get the binding for f, which is this procedure", " And that says I'm going to copy this environment pointer", " So I'm going to create a new frame whose parent is that global environment", " And inside there, I'm going to bind a parameter x-- and that is coming from there-- to the value passed in by the value of the call to f", " And that x refers to this one", " OK, a little funky", " But it's important to see that the rules actually tell me how to do that", " My invocation of f says create a frame in which the formal parameter x is going to have a binding", " And what's the binding for that value? It's the value of this expression", " And that expression is a variable name", " So I'm doing that evaluation here in the global environment", " I get that value of x, which is 3", " So I've now created a local binding for x to be 3", " And now I'm ready to move on", " So relative to this environment, I am now going to evaluate the body of f", " So let's step on", " The body of f says, first expression is to create a binding for y", " Remember that's happening here", " That's happening in the frame associated with the function invocation", " So I'm going to bind y, have the value 1 there", " That's interesting because it's not changing things up here", " It is making that binding there", " So that step of the computation creates that change", " And If I now move on, the next expression in f says get the value of x", " Remember, I'm doing that relative to this frame", " Get the value of y, which I'm doing relative to this frame", " And then do that computation and change the binding, which is why it goes from 3 + 1, and I'm changing that binding to 4", " From the perspective of f, it never sees that version of y", " It only sees this version of y", " From the perspective of f, it only saw that version of x, which was originally 3", " And then the binding, this, happens in this frame", " And that's why that version of x changes", " Having done that, we can move on", " And it says return the value of x, which is 4, and that is what z is going to be bound to", " And that binding, remember, takes place up in this frame because that expression is being evaluated relative to the global environment", " It's a long-winded way of saying notice that this particular expression here, the body of f, got a value for y that it had bound locally, got a value for x which was the local parameter, and did the change locally inside of that environment", " But the return value was a binding that took place up in the global environment", " And that's why if I were now to go ahead and print out, control reverts to the global environment", " And that's where the values of x, y and z are visible, which is why I am going to, in fact, now do the values that I saw printed when I did that in my environment", " So the point of this is that those bindings actually take place in frames that make sense", " Here are some observations", " Each function call creates a new environment, a new scope, where the bindings of the formal parameters and the values passed in take place", " And where, as we saw, local variables, things created as assignments within the body, take place, that local binding of y", " And that creates an environment in which we actually do the computation", " This scoping is often called either static or lexical", " Because the scope within which a variable has a value is defined by the extent of the code boundaries", " That definition of f had, lexically, a scope around that said I'm locally binding y", " I'm locally using the formal parameter of x", " All computations take place within that scope", " So that gives us a sense of why we see the particular"], "PauHW4ObHDo": ["In this sixth lecture we're going to introduce compound data types", " These are ways to combine simpler data objects into collections, for which we can then write algorithms to infer new information", " In particular, we will introduce tuples and lists", " And we'll talk about fundamental operations on these common compound data types", " Finally, we will show you a more general collection of objects called dictionaries, and methods for creating and manipulating them", " At the end of this lecture, you should be able to write functions that manipulate compound data objects, as well as those that deal with scalar objects, like numbers and strings", ""], "tyESRmeZK1E": ["NTA"], "99LfboDePVE": ["NTA"], "EeGAH_Es_7s": ["Eric Grimson: Now we've seen black-box testing, designing a test suite based on just pass through the specification", " A nice complement to that is glass-box testing", " That's where we're going to use the code itself, the implementation, to guide the design of test cases", " Obviously looking at the code should give us a more complete handle, if you like, on trying to figure out where there might be possible bugs", " So let's think a little bit about what it means", " And again, the name sort of suggests it", " Glass-box says I can see inside to figure out what's going on", " A glass-box test suite, a good one, is called path-complete, if every possible path through the code is tested at least once", " Now if you think about it, that's not always going to be possible", " If we've got a loop, we might be able to say what happens if the loop is executed once, executed more than once", " But to do one, two, three, four, five, up to a billion times, again we may not be able to test all of them", " But we can certainly talk about different samplings of test through a loop", " Same thing with a recursive function", " There maybe arbitrarily deep levels of recursions, where we may not be able to test all of it", " But the idea of testing multiple paths through the code", " And if possible all paths through the code, is really nice", " Notice by the way, even a path-complete test suite can still miss a bug", " It will depend on the choice of examples", " But if it is path-complete, if we're exercising every path through the code, at least we're more likely to find a bug if it's there", " Now let's look at a little example", " Here's a simple little piece of code for finding absolute value", " Assumes x is an int", " It's going to return x, if x is greater than or equal to 0, it'll return minus x otherwise", " And since I know that x is an int, I can do some good sampling here", " And you can see the code inside", " Now, what would a good test suite here be? Well, one sample of a test suite would be to pick the values of minus 2 and 2", " It's certainly path-complete, right", " If it's minus 2, it's going to take this path", " If it's positive 2, it's going to take this path", " So it's looking at both paths through the if clause", " On the other hand, it's going to miss a case", " And it will miss in fact, this case here, of looking at absolute minus 1, which in this case gives me a bug", " Because in fact I should have had x less than or equal to here to catch that case", " What does that say? It says it's not just being path-complete, but we want to think about boundary cases", " And here the code itself gives us a boundary case", " Since that's the test, I ought to pick that up as one of the boundary cases", " When it's at that boundary, when it's below that boundary, when it's above that boundary", " But here's a case where I do explore all the possible paths", " I've got a path-complete set of tests", " OK, so what can we do with this? Well, here's some simple rules of thumb-- in a second we're going to get to an example-- but here's some rules of thumb for how you do good glass-box testing", " First, make sure that both branches of all if statements are checked", " I just did that, in that particular case", " Similarly, insure that every except clause is executed", " We're going to return to this", " We haven't talked a lot about except so far, or exceptions", " But it's the same idea", " Every time I've got an exception, make sure I actually test that", " If I have a loop, a for loop, I want to have tests where the loop's not entered, where the body of the loop is executed exactly once, or the body of the loop is executed more than once", " As I said earlier, I can't do all possible versions of them more than once", " But I can sample those three because they tend to expose places where there are bugs", " Same thing for a while loop", " Do the same thing I did for for", " The loop's not done, done once, done multiple times", " But also I want to catch all the cases here where there are different ways to exit the loop", " If there are different parts of my loop or I can break out of it, I want to catch all of those", " If I've got a recursive function, I want to test what happens if there's no recursive call, it's just the base case", " What happens if there's exactly one recursive call? And again, if there's more than one recursive call", " And you can see this pattern of none, one, and more, there and here", " And that's a common thing that I'm going to want to try and use, as I build different test suites for doing glass-box testing", ""], "kbrZtHI5CSo": ["NTA"], "Vb-zAII5204": ["NTA"], "NYBjfMwpvzs": ["NTA"], "R4uDE45cYI4": ["NTA"], "_FbKIp-6YzY": ["Chris Terman: In this lecture, we're going to revisit optimization problems, particularly those that involved having to do an exhaustive search to find the optimal solution", " Before, we were forced to adopt a simple heuristic, like the greedy algorithm, in order to come up with run-times that are reasonable", " Now, we're going to try using a technique called dynamic programming that will let us achieve optimal results, but with much more reasonable run-times", " Let's get started", " Some optimization problems exhibit properties which, if they were true, allow us to come up with a much more computationally efficient way to solve the problem", " The first property is called optimal substructure", " So suppose we have some optimization problem expressed as the function f, where we pass in an argument that has some structure", " For example, the argument may be a list of items, and the shaded area might represent the first half of the list, and the unshaded area the second half of the list", " In some problems, we might discover that, to come up with the optimal solution for the original problem, we'll discover ourselves computing the same optimization problem, but on a smaller argument as part of the original arguments that have been whittled down somehow", " So in this case, we're computing the optimization function on the first half, and then the second half", " So we decompose the problem, the original problem, into two sub-problems", " Now, if it's the case that I'll be able to take the answer to these two sub-problems and combine them some way, I may be able to come up with the answer for the original problem", " And if that's true, if our computation exhibits this behavior, we say that it has optimal substructure", " Another property is that in doing this sort of decomposition of the optimization problem into sub-problems, we may discover that the same sub-problem keeps reoccurring", " And when that happens, so for example, we may discover that we keep computing this particular function many times", " And when that happens, when we say that the sub-problems are overlapping", " In other words, if we find ourselves computing the answer for the same sub-problem again and again and again", " Although if not an optimization problem, this definition for Fibonacci and its execution display the properties that we talked about on the previous slide", " We can see that, to compute fib(n) , we end up computing fib(n-1) , and fib(n-2) of , and this is the sort of substructure we were talking about", " And then, of course, the computation involves adding the two results together", " So we-- processing the answers from fib(n-1) and fib(n-2) to come up with the answer for fib(n) ", " If we actually consider the execution of this, say, on Fibonacci of five, let's sort of show the call tree, all the sub-problems that have to be solved, and see what we see", " So, fib(5) we have to compute fib(4) and fib(3) And fib(4) we'll compute fib(3) and fib(2) And for fib(3) we'll compute fib(2) and fib(1) fib(1) , when the argument is 1, you can see we don't make any more calls, so that's a leaf of the call tree", " But fib(2) involves a call of fib(1) and fib(0) Same up here, call to a fib(1) , and a call to fib(0) ", " And then fib(3) involves a call of fib(2) and fib(1) And finally, this fib(2) involves a call to fib(1) and fib(0) So that's the entire call tree that we will execute when we initially start off by calling fib(5)", " We can see there's a lot of common sub-problems here", " For example, we compute f(2) here, and here, and here", " And in fact, there's higher levels of sub-problems", " For example, fib(3) shows up twice", " So as we look at the call tree, we see that there is a lot of overlap in the various sub-problems", " And we'll be able to take advantage of that as we think of a more computationally efficient way to compute fib", " So how many calls does it take to compute Fibonacci(n) ? Let's let t(n) equal the number of calls that we need", " So we can sort of say, well, T(n) , and now we can look at the structure of the problem", " And we can see that to compute Fibonacci(n) , we have to compute Fibonacci(n-1) , which will take T(n-1) calls, plus Fibonacci(n-2) , which takes T(n-2) calls Well, looking at the form of this equation, we can see that this quantity basically approximately doubles with each increment to n, and that suggests that the answer-- we expect the answer to grow exponentially", " Now, it's not quite doubling, so the exponential won't involve the constant 2, but let's assume that it involves some constant alpha, so it goes alpha^n ", " So let's see if we can figure out what alpha is", " So this equation here, if we assume that the form of t(n) of n is alpha(n) ", " that suggests that alpha^n = alpha^(n-1) + alpha^(n-2) We'd like to solve this for alpha, so let's divide both sides by alpha^(n-2) so I'm just dividing both sides by the same constant, which is fine", " OK, so now I'm going to simplify this into-- that's alpha^2 , and alpha^(n-1) over alpha^(n-2) is alpha, and then that reduces to 1", " And I can go ahead and solve that, so I'm going to have to solve this for alpha, and when I do so using the quadratic formula, I discover that alpha = 1 + sqrt(5/2) , and that's a very magic number", " It occurs in many interesting places-- particularly in nature, it's called the Golden Ratio", " A good thing to remember as sort of part of your education is what the golden ratio is-- it's 1 plus the square root of 5/2", " And so what that suggests is that the number of calls that we have to make in order to compute Fibonacci(n) is order of this Golden Ratio, which is about 1", "6^n ", " In the code accompanying this lecture, we provided a definition of Fibonacci, which we'll use to do some performance evaluations", " One little detail we have to take care of before we start, though, is that Python really thinks that functions that keep calling themselves too many times-- too many levels of recursion-- are probably in error", " In order for our experiments to succeed, we're going to have to convince Python to let us do a large number of recursive calls, and we can specify that using the set recursion limit function that is inside the sys module", " So we set it very high so that we can run our experiments without complaints from the Python system", " OK, so let's go give this a try", " We're going to save this out, and then do some functions", " So for instance, we can ask for what fib(10) is-- 89", " And we can ask maybe what fib(20) is ", " OK, that's a bigger number", " You can see that the Fibonacci sequence actually gets large quickly", " How about fib(30) ? Did you see there was a little bit more of a pause there", " Remember that the number of function calls is growing exponentially with the size of the argument, so we had to make many, many more function calls in order to compute fib(30) with the definition of fib that we have", " How about fib(35) ? Well, it's going to be somewhat larger, and you can see that I was taking a considerable length of time to compute, and as we're going, the run-time is sort of growing exponentially", " How about fib(40) ? Well, it's running away, and in fact, it will run away for quite a long time", " We'd have to sit on our hands, go out for a cup of coffee, maybe even lunch, and come back to get the answer here", " If I interrupt this execution, you can see that we were many, many levels deep in the recursive calls to the Fibonacci", ""], "Y0lczs-_w-I": ["Eric Grimson: In this third lecture we are going to start building on our ability to write simple programs", " In particular, we're going to introduce the concept of iteration, or how to repeat a method multiple times in order to reuse the computation to execute something an arbitrary number of times", " Once we have iteration, we can start doing some interesting classes of algorithms", " Starting with guess and check methods, the guess and answer, check it, and then use the results to improve the guess", " This will lead naturally to the idea of loop constructs, or mechanisms in our language that let us generalize the idea of repeating a computation until a particular condition is reached", " This will let us generalize our guess and check methods to a broader group of algorithms called successive approximation, and especially to a very common and very powerful method called bisection search", " At the end of this lecture you will be able to write simple algorithms that solve numerical problems by improving approximate estimates of the answer to get successively better guesses", ""], "GometKBrL7E": ["CHRIS TERMAN: By now, I hope you're getting the idea that we can tackle the exponential cost of exhaustive search by structuring the problem so as to generate recurring subproblems", " Then we can use memoization to look up the answer instead of recomputing it", " Our next example comes from the field of genomics research, where one of the interesting computational problems is to figure out the alignment of two genetic sequences", " In this example, we're trying to find the minimum cost alignment between two sequences, so here are two example four element sequences", " If we consider an alignment where we basically start by lining up their first characters, and going from there, we can see that, in this particular case, there are three mismatches", " In this column, this column, and this column the individual symbols don't match, and so I would say the cost of this alignment is three times the cost of a mismatch", " So that will be a parameter that we can set, a cost of a mismatch", " Let's consider a different sort of alignment", " Suppose we start off by aligning the two first characters but assume that the second character, in the first sequence, lines up with a gap in the second sequence, and then we can continue the matching process like so", " And then there's a final character in the second sequence, which we would assume would line up with a gap in the first sequence", " So here what we're considering is what happens if we start introducing gaps into the process where some characters disappeared", " This particular alignment, where we've made some assumption of the gaps in each of the two sequences, would have a total cost of two times the cost of a gap", " What we'd like to do is to consider all possible combinations of matching the symbol at any particular column or introducing a gap in one sequence or the other, and once we've run through all possible combinations of mismatches and gaps, we would like to choose the alignment with the minimum cost", " Let's see how we can break the alignment process into subproblems", " Originally, we're given two sequences", " Let's say this one starts with A and some number of symbols afterwards, and sequence two starts with a B and some number of symbols afterwards", " There's actually three different alternatives we want to be able to test out", " In the first alternative, we assume that the two sequences match at their starting symbol, and so the subproblem that we need to solve is basically to align the rest of the sequences", " We want the optimal alignment for the rest of the sequences", " So all but the first character in the first sequence and all but the first character in the second sequence", " So we want to align those two, and then we'll simply account for the cost of the alignment of the first symbol", " So the cost is, well, if the first character in S1 isn't equal to the first character in S2, then we have to increment the cost of the subproblem here, increment the cost by the cost of a mismatch", " However, if they were the same, if it turned out that was A and that was A, then we'd use the optimal alignment for the rest of the sequence and there would be no additional cost", " The second alternative is that the first character in A actually of the first sequence, actually aligns with a gap in the second sequence", " So this is sort of the problem we're looking at here", " And so that means that the subproblem now, this is after we consider the first character was the subproblem, the subproblem is that we need to align the rest of this characters in the first sequence", " So that's when we take off the first character because it's aligning with a gap, with all the characters of the second sequence", " And then when we get back the optimal alignment there, the first string will have an A on it, and the second string, we'll put a gap-- a dash to indicate a gap at the front", " And the additional cost is going to be now the cost of a gap, so gcost", " And finally, as a third alternative, we have the second situation only reversed", " In this case, we assume that the first character of the second sequence aligns with a gap in the first sequence", " So that's the situation we have, and now the subproblem is to align the first sequence with the remaining characters in the second sequence like so", " And the cost, once we get back that optimal alignment, we can put these two characters at the front, and we'll have the optimal alignment including the first characters and the increment and the cost will be again, the cost of another gap", " So if we pursue this recursively, where we slowly consume the first character of the sequence and then consider the three alternatives, we'll eventually exhaust all possible combination of matches and gaps in the two sequences", " Here's the implementation of the recursive alignment procedure we just discussed", " We start by dealing with termination of the recursion", " So, for example, if the first sequences run out, we assume that it's padded with gaps that match any remaining characters in the second sequence", " And similarly, for the second sequence, if it runs out", " Then we go off and consider the same three alternatives we discussed earlier", " The first symbols of the two sequences aligning or the first symbol of one sequence aligning with a gap in the other", " In each case, we go off and do a recursive call to compute the best alignment of the remaining symbols, and then, add any cost penalties that are incurred by the situation that we're dealing with", " We've also included code that constructs the align sequences so we can see what the optimal alignment has turned out to be", " Finally, at the end, of course, we choose to return the alternative that has the cheapest cost among the three", " We have a couple test cases down here at the bottom", " One is a very simple alignment where we're aligning the sequence CAT with the sequence AT, and then a longer challenge, which-- and we'll see how that turns out", " And, as usual, we have our little test case", " So let's start that up and see how it works", " So first, let's test the alignment", " of the simple sequence", " So s1a and s1b, and as expected, we discover that the minimum cost alignment involves a gap at the beginning of the second sequence", " What about the longer of the two problems? Now, as you might expect given that this is a lecture on dynamic programming, we'll discover that, in this particular case, we don't get an answer right away, and, in fact, we'd have to wait for a very long time because exploring all the possible alternatives of where to put the gaps is actually quite time consuming as the sequence gets longer and longer and longer", " The cost grows exponentially", " So I'm going to terminate this, and now, we're going to see if there's any overlapping subproblems", " If there are overlapping subproblems, then I would assume that if we go off and memoize the alignment procedure, now we would hope that trying to align the longer sequences, so s2a with s2b, will actually result in an answer quickly if there are overlapping subproblems that the memoization is taking care or for us", " And, in fact, you see we get the answer almost instantaneously", " So that means there was a large number of overlapping subproblems, and you can see that it suggests that the optimal alignment comes with the insertion of two gaps leaving just one mismatch", " So this C and that A, so one mismatch and two gaps was the optimal guess for the alignment of those two sequences", " Well, there you have it", " We've looked at three examples where dynamic programming could reduce the exponential costs of our exhaustive search so that we can get the optimal solution in reasonable time", " We needed two properties to be able to do this", " One was optimal substructure, where we had to be able to reduce the original problem into a sequence of smaller but identical subproblems, and then we could combine the answers from the subproblems into the answer for the overall problem", " And secondly, we wanted to have overlapping subproblems so we could use memoization to look up the answers instead of having to recompute them", " Dynamic programming is not something we can apply to every optimization problem, but it's always worth giving it a try to see if you can cast a problem in a way that exhibits these two properties", " If so, you're in luck and you should be able to get a computationally efficient answer", ""], "3a2rB3LhRjo": ["NTA"], "RQdyRhHDlRo": ["NTA"], "9i-VL98AuEY": ["PROFESSOR: In the last lecture we started talking about graphs, and we saw the basic idea of a graph", " We could represent objects as nodes, and connections and interactions between those objects as edges", " And then what we often wanted to do was to find a solution-- an optimization-- over that graph", " And that was straightforward to understand when we were thinking about graphs that represented physical networks-- a transportation network, an electrical network, some other network that moves things around", " Where in case of the transportation network, the nodes could be cities and the edges would be flights between those cities", " We saw as an example, we could find solutions like the cheapest flight or set of flights from one place to another, or the one that took the least number of legs or segments in the flight", " But we can also use graphs to explore other kinds of systems", " In particular, systems where we're really interested in the changes in the state of a physical system", " What does that mean? I might have a physical system like a plant-- a power plant, some other kind of plant, a manufacturing plant", " And I want to have the states, or the nodes of the graph rather, represent the states of the system-- current configuration", " And the edges in this case, would represent actions-- things that cause a change in the state-- open up a valve, close a valve, change the heat, something like that", " And here, my graph search wants to find a sequence of actions that converts the system to a desired state", " Now, let's look at an example", " And here's what seems like a simple example, but actually a fun one", " This is a little puzzle you may have had when you were a child called the 8 puzzle", " It has a set of 8 numbered tiles in a grid that has 9 spots", " So there's one blank spot right here", " And the idea is, I want to go from some initial state, such as the one shown here", " By sliding the tiles one at a time into the blank spot, I want to try and figure out how do I convert the puzzle into some desired goal state-- such as getting them all lined up in the proper order", " So here process is slide any tile", " And I want to find the sequence of slides that actually gets me to the solution I want-- the goal state", " Here's an example", " There's my initial starting solution and here's the things I can do", " I can start by doing a slide that moves 6 down into that spot, getting it down where I want it to be", " And then I could do another slide that moves 3 over", " And that I'm going to do because I want to actually shift 4 up", " Now I'm in pretty good shape because you can see that this is going to let me move 7 over and 8 down", " Now the bottom three tiles are now in the right place", " And oh, I can also see now that if I bring 5 down, all I have left to do is shift 2 over and then 1 over", " And I'm done", " Nice and easy, right", " And you can see here, I'd like to find that sequence of steps", " You can also see it may not be trivial to find", " So how could I turn this into a graph problem? Well, a simple way would be to just think about representing it the way we did with previous problems", " I could take each state of the puzzle-- each particular arrangement of tiles-- and I could represent that as a node in a graph", " So every specific layout of tiles would be a different node in my graph", " Each edge of the graph would specify which tile I would slide to get to a new state of the puzzle", " So from one node there might be 2 or 3 possible edges that tell me different ways I could slide a tile to get to a new state of the puzzle", " And I could just then explore that space", " Here's the problem: how big is the space? Well, I've got 9 spots in my grid", " So in fact, there are 9 factorial, or 9 * 8 * 7 * 6 all the way down to 1", " Different ways to arrange numbered tiles in that grid", " And that says I've got almost 365,000 nodes in my graph", " Eh", " That's big", " Worse, each node has either 2, 3, or 4 edges because there's going to be 2, 3, or 4 tiles that I could slide into the open spot", " And that says basically, that the graph has almost a million edges and 360 plus thousand nodes", " I don't want to build a graph that big", " That'd take forever", " It's going to be huge", " Is there another way in which I could actually turn this into a graph problem and solve it? And that's what we're going to talk about", ""], "vmz9pVWI2S4": ["Eric Grimson: In this fourth lecture, we are going to take our ideas of looping computations and abstract them", " That means we'll capture the idea of a computational method inside a function, allowing us to separate the details of how we do the computation from the use of the computation", " Something we call a black box abstraction", " This is a very powerful idea that will let us build complex collections of functions that compute very interesting things without getting bogged down in the details", " And in a way, that makes it easier to reuse methods, or to debug or correct them", " We'll also introduce a formalism called environments to help us visualize how using functions within a Python interpreter controls the assignment of names to values, how those values are retrieved, and how we can use those ideas to conceptualize new algorithms", " At the end of this lecture you will have the ability to write arbitrary computations as functions, and to use those functions as building blocks for other computations, a key element of computational thinking", ""], "pG9JQOSadtk": ["NTA"], "kYJj0I4YMHQ": ["NTA"], "-3BEW8PBdhk": ["NTA"], "BQMz9FUnJj0": ["NTA"], "4cz7_-_VlmI": ["NTA"], "yBRf7ajFSTU": ["PROFESSOR: So let's use polyfit to find the line that best fits our data", " So what we've done here is created a new Python procedure called fitData", " And it's just like plotData except that we've added a call to polyfit in which we give it the forces and the observed extensions and ask it to find the equations of the line so that the predictions best fit the observations", " Then we go off and use those parameters to make a bunch of estimates for what the y value should be, the extension should be, based on the forces that we're applying", " And here, we're using the predictive power of our mathematical model, and we're going to plot that line on the graph", " And finally, since the slope of the line is 1 over k-- this is the slope, so that means that k is equal to 1 over the slope", " And we'll also put that on our plot", " So let's go off and run this procedure on the data values", " So I've already saved this out", " So we'll start the execution, and hopefully up we'll plot", " Here it is", " And here's the line", " We can sort of see it here", " And you can look at that and say, well, OK that's certainly the best fit line, I suppose", " It does the best job it can of sort of minimizing the sizes of the squares of the errors here", " But it doesn't look like the best fit", " It seems something here about it we don't like", " Maybe Hooke's law is wrong", " Maybe there's a different curve here that would actually fit the observed points better", " So just for grins, let's try to invent Terman's law", " So what Terman's law is, in fact, that there's a cubic relationship between the force that's supplied and extension, rather than a linear relationship", " So let me start off by commenting out the call to fitData", " And here I have a new procedure, fitData1 which uses polyfit to fit a cubic equation to the observed data", " And let's plot those results", " So I'm going to make it so we run this guy", " And I'm going to save him out and then start execution", " And here's the resulting plot", " And in fact, this actually looks better", " Maybe Terman's law has something going for it here", " The curve looks much closer to all the points than the original linear fit, so maybe Hooke got it wrong and modern springs are much more sophisticated", " They obey this sort of cubic relationship between the force that's applied and extension that's observed", " Well how do we figure this out? I mean, here we fitted some data, and we're sort of saying, gosh, it certainly looks like that's a better fit", " Well, one of ways we can evaluate the power of a model is its predictive power", " So what I want to do, I'm going to start by-- let's comment this guy back out again, and look at that fitData2 which is just like fitData1 except what I've done is that when I'm going to use the model for predictions, I'm going to ask it to predict the extensions created by applying heavier weights", " We didn't make these measurements, but we sort of expect the spring to keep stretching as we apply higher and higher weights to it", " So everything is just the same", " We are still doing a linear fit here and a cubic fit here", " Let's see what happens when we run this and plot the results", " So we're trying to use our model here to determine the predictive power of Terman's law which hypothesizes a cubic relationship between the extension and the force applied", " So we're going to save this out and then run it", " OK, here's the results", " Oops", " We did a pretty good job of matching our curve to the observed data, but when we went off and asked about some predictions-- so here's what the prediction extension is as we add additional force to the end of the spring", " And even though we're pulling on the spring harder, all of a sudden the extension is getting smaller and smaller", " The spring is no longer stretching", " It's shrinking when we pull harder on it", " Well, gosh, that doesn't seem quite right", " So even though we've managed to find a way to fit the curve to the observed data, it turns out the predictive power of Terman's law is bunk", " It's simply predicting behavior in a spring that doesn't seem very sensible", " And we would certainly expect displacement of the spring to continue to get longer as we pulled on it", " So let's give up on Terman's law and actually think a little bit about what we saw in the data", " So when we looked at the data, what we saw is that it flattened out at the end", " And so what I was thinking of is-- well actually, let's put that plot back up while we're sitting here", " If we look at this sort of flattened data here, we can see the curve flattens out at a point", " So it looks like Hooke's law may, in fact, with some observational errors in our measurements that we made, it looks like Hooke's law might be OK", " It's just that these last data points show that the spring has stopped stretching", " And we might hypothesize instead of Terman's law with a cubic relationship, we might just say, look, Hooke's law applies to the point at the spring reaches its elastic limit", " in other words, when it stops behaving as a spring and now just behaves as sort of like a rigid rope or a cable of some sort", " In other words, it doesn't get any longer just because you hang more weight on it", " So maybe what we should do is try getting rid of these last points and seeing if Hooke's law does a better job of doing the projection", " So we're going to come back here and go ahead and comment this guy out and look at fitData3, which is just like fitData1 except that what we've done is to eliminate the last six values, the values that we feel that correspond to the spring having reached its elastic limit", " So let's go ahead and run this", " So let's comment that back in again, save that, and run it and see what the plot produces", " And voila", " Without that flattening out of the curve, we actually have a fairly good fit to the data", " In other words, there's still some amount of measurement error, but now the curve seems to fit better", " And in a couple minutes, we'll talk about what a measure of the goodness of the fit, but we're pretty happy or certainly happier with this fit than with either the cubic fit, which mispredicted, or the original fit, which just didn't seem to fit the points at all", " So this raised the question, are we just allowed to eliminate points we don't like? I mean, suppose I eliminated all but two points? I'm going to keep this point and that point", " And then I would discover that I can make a perfect prediction", " You can always put a line through two points", " So why was it I felt comfortable eliminating those last six points and I'm not running around eliminating some other points here that seemed like embarrassments or making it harder for me to show that Hooke's law is the right equation? And the answer is, well, I had a theoretical justification", " I hypothesized this notion that there was an elastic limit to the spring", " And as soon as I saw that the length wasn't growing as I added extra weights, I said, OK, maybe what I should do is to consider that a different regime", " Hooke's law wouldn't apply there", " But I am expecting Hooke's law to apply for all of these measurements", " So I'm not allowed to willy nilly just get rid of points I don't like", " I really do need a theoretical justification", " But with that justification in hand, I think we can make a fairly good prediction that the spring constant of the spring is somewhere around 15 1/2,"], "OEoXaMPEzfM": ["LILA FISHER: Hi, welcome to Edx", " I'm Lila Fisher, an Edx fellow helping to put together these courses", " As you know, our courses are entirely online", " So before we start learning about the subjects that brought you here, let's learn about the tools that you will use to navigate through the course material", " Let's start with what is on your screen right now", " You are watching a video of me talking", " You have several tools associated with these videos", " Some of them are standard video buttons, like the play Pause Button on the bottom left", " Like most video players, you can see how far you are into this particular video segment and how long the entire video segment is", " Something that you might not be used to is the speed option", " While you are going through the videos, you can speed up or slow down the video player with these buttons", " Go ahead and try that now", " Make me talk faster and slower", " If you ever get frustrated by the pace of speech, you can adjust it this way", " Another great feature is the transcript on the side", " This will follow along with everything that I am saying as I am saying it, so you can read along if you like", " You can also click on any of the words, and you will notice that the video jumps to that word", " The video slider at the bottom of the video will let you navigate through the video quickly", " If you ever find the transcript distracting, you can toggle the captioning button in order to make it go away or reappear", " Now that you know about the video player, I want to point out the sequence navigator", " Right now you're in a lecture sequence, which interweaves many videos and practice exercises", " You can see how far you are in a particular sequence by observing which tab you're on", " You can navigate directly to any video or exercise by clicking on the appropriate tab", " You can also progress to the next element by pressing the Arrow button, or by clicking on the next tab", " Try that now", " The tutorial will continue in the next video", ""], "nf-d1FFE-bE": ["PROFESSOR: In our first example, we're going to work on a specialization of the bin packing problem called the knapsack problem", " Here we're going to have a single bin, and our goal is to find a collection of objects that fit into the knapsack but that maximize the value when it's full", " We'll also meet the greedy algorithm, an efficient little computation that can be used to come up with acceptable solutions for many optimization problems", " It looks like it's going to be a good night for our burglar", " He's found a mansion and nobody's at home", " He arrives and with him he's brought a knapsack, and the maximum weight the knapsack can hold is 20 kilograms", " When he gets inside, the burglar discovered he's facing a challenge", " There are many items to choose between, each with their own value and weight", " The burglar remembers that his knapsack can only hold 20 kilograms", " So expressed as an optimization problem, the burglar wants to maximize the sum of the values of the objects that he's taking", " OK", " But, he also realizes that the sum of the weights of all the values that he's taking has to be less than 20", " This type of optimization problem is called the 0/1 knapsack problem", " 0/1 because either you can take nothing of an object or all of an object", " So you can either take a whole clock-- that would be, in a sense, represented by a 1-- or not take any part of the painting-- that would be represented by a 0", " And you have that choice for each of the objects", " So it's really up to the burglar to find some combination of items to take and items to leave behind that meet his weight constraint but maximize the total value of the goods in this knapsack", " This problem gets harder as the number of items grows", " That's because, as there's more and more items, there's more different combinations to consider when trying to maximize value within the weight constraint", " Our burglar's going to solve this problem by using a greedy algorithm", " Here's how that works", " At each step, he's going to choose the best of the remaining items subject to the constraint that it will fit in the remaining weight allowance of his knapsack", " Best-- how does he determine best? Well, he's going to use some metric, and he can use that to evaluate the goodness of each of the choices", " And he'll choose the one that scores highest on the metric", " One possible metric is to choose the remaining item that has the greatest value, or if there's more than one with the same greatest value, just arbitrarily choose", " The reasoning here is that by maximizing the value at each step, he hopes to maximize the total value of his knapsack", " He might decide to try to use minimum weight objects", " Here the theory is that if he fills up on the lighter objects first, perhaps a greater number of objects will actually result in a greater total value", " Or he might sort of try to choose objects that have the best value to weight ratio", " Whichever metric he uses, the burglar's basically adopting the strategy of choosing a locally optimal item in the hopes that a series of locally optimal choices will lead to the global optimum of coming up with the greatest value of goods", " Then he simply repeats that first step until his backpack is full", " The burglar likes the greedy algorithm, because it's easy to implement and because of its straightforward nature, will actually perform quite well even when the number of objects is large", " So which of these metrics should the burglar choose? As it turns out, none of these metrics actually produces the optimal result in all cases", " By that, I mean that if the burglar always uses one of the metrics to choose items, he may end up with a sack of items which has less total value than would have been possible", " Moreover, none of these metrics is always better than the other metrics", " So even if the burglar is willing to do with a less than optimal solution, it's still the case that if he chose a different metric, he might end up with a more valuable bag of items than in certain situations", " So in other words, a certain combination of items in which max value does best, and there's other combinations in which min weight does best", " Sadly, the burglar comes to the realization that the greedy algorithm is heuristic for the 0/1 knapsack problem", " In other words, the choices that are made aren't guaranteed to produce an optimal result", " There are situations where the greedy algorithm does produce an optimal result", " Consider a situation where the materials that the burglar is thinking about choosing between are, in fact, infinitely divisible", " He can take as much or little of each one that he wants", " That's why it's called the continuous knapsack problem", " So for example, suppose there were three barrels of liquids, one containing water, one containing oil, and one containing wine", " It turns out that if the burglar pursues a greedy algorithm with a metric of choosing the liquid that has the greatest value per weight, then he'll find an optimal solution", " And so what he'll do is choose the most valuable liquid, and either fill up his backpack with that, or if it runs out early, he'll move to the next valuable liquid", " And if he pursues that strategy, he'll end up with the most valuable contents in his backpack", ""], "MJ4baVLD4uU": ["COLLIN M", " STULTZ: So my name is Collin Stultz", " I'm a faculty member at MIT in the Department of Electrical Engineering and Computer Science, and also in the division of Health Sciences and Technology", " I am also a clinical cardiologist who still sees patients", " And I have an interest in combining computational methods with medicine to make statements about patients, statements that will help to improve the lives and quality of people who are sick", " And today, I'm going to talk about some methods that we've been working on to combine sophisticated computational algorithms to make statements about patients with cardiovascular disease", " Cardiovascular disease is a big problem", " In fact, everybody has atherosclerosis", " It doesn't matter how young or how old you are", " Atherosclerosis is actually a disease of the juvenile", " And the problem is that, although everyone has it, some people will die from it and some people won't", " So a huge challenge in clinical cardiology is to identify those patients who have atherosclerotic heart disease who are going to die from it", " And this slide demonstrates that atherosclerosis is a huge problem", " About every 30 seconds in the United States, somebody dies of heart attack", " And about half a million people die each year", " So it's about a quarter of all deaths in the US", " And these are statistics from just a few years ago", " And although we know that everybody has atherosclerosis-- we know a lot about the disease-- we're horrible in trying to identify those who will die", " So if you look at the whole pie of people who die from atherosclerotic heart disease, we only can identify a small fraction of those who will", " So our goal, at least one of the goals of my research group, is to develop predictive models that help our ability to identify patients with high risk of death", " So when you think about atherosclerosis, what really happens when somebody has a heart attack? Well, here in this picture is the classic photo of somebody having chest pain due to heart disease-- clutching his chest", " It usually feels like a pressure that comes down on your chest", " It's typically described as an elephant sitting on your chest", " And this type of event is correlated with something that has been very well described in the literature", " A lot of studies have been done to say what causes this type of pain that leads to adverse events", " So if you were able to open this man's chest to decipher the actual things that are going on, you'll find that here's the heart", " And this is a blood vessel which supplies blood to a region of the heart", " And in a heart attack, this blood vessel becomes blocked", " You have this thing which builds up within the lumen of the vessel called an atherosclerotic plaque", " So this heart muscle normally was being profused by blood, but this blockage happens", " And it grows all of a sudden", " And this blood vessel can no longer supply blood to that area of the heart", " And consequently, that heart muscle dies", " And if you were to take a blow up of this picture, this is an actual specimen taken from somebody who died of a massive heart attack", " Here is the atherosclerotic plaque", " And what happens is it this plaque ruptures", " And the blood, which sits in the lumen, comes into contact with all of this bad stuff that's in the atherosclerotic plaque, and a clot forms", " And this process of breaking open the plaque involves lots of inflammatory cells", " So these are cells which are involved in an immune response", " And these cells secrete substances which break open the plaque", " There's a protective covering of collagen on top of this atherosclerotic plaque that becomes ruptured because these cells secrete enzymes that degrade the collagen", " And that's what allows the blood to come into contact with all of these bad materials with an atherosclerotic plaque, which leads to the formation of this clot", " So here's where computation could come into play", " All of this was determined by biological methods, experiments that are typically done in a laboratory with test tubes and gels and so forth", " But the events that happen at this level, the enzyme that actually breaks down collagen, these involve very, very small things that are typically very hard to study experimentally", " But what you can do with a computer is you can model these proteins", " So we know what the structure of collagen looks like", " We know the structure of the enzymes that degrade collagen", " And we can put this molecule in a computer", " We can do sophisticated calculations to get estimates of how this molecule moves and how it gets degraded", " And we can get insights into the motions of this protein that lead to its degradation, which leads to rupture of this plaque, which leads to formation of the clot, which leads to a heart attack", " And so our group has been involved in doing a lot of sophisticated computations along this line", " But that's really not what I'm going to talk about today", " I'm going to talk about something that's a lot bigger", " This is just an example to show you one avenue in which sophisticated computational tools can be used to gain insights into the disease process known as atherosclerosis and atherosclerotic plaque rupture", " So now, what I'm going to talk about-- if you go back to this mature gentleman who's suffering from chest pain, this person, let's say, goes into an emergency room or goes to his doctor", " And the physician gets a lot of information about this patient", " They can get electrocardiographic information", " So that's what this is", " And if you're familiar with shows like ER or Hospital, people come into the emergency room", " There are leads that are put on the patient's chest", " And what's recorded is an electrocardiogram", " So these are the same tracings that you may be familiar with from watching popular television shows", " You can get tracings that record blood pressure, how the blood pressure changes over time, and different tracings that record pressures within various parts of the vascular tree", " So now, this electrocardiogram-- maybe a lot of you have had these done before or know somebody who's had them done before", " It's very easy to obtain", " And the question that we're posing is, \"Can we use data like these that are easy to obtain, that are obtained on a lot of people, to try to identify whether this person is going to die or not?\" He may be having a heart attack, but he can survive his heart attack and live the rest of his life in a productive manner", " Or he could have a heart attack and die", " And we want to identify those patients who have high risk of death after a heart attack", " So as I've said, lots of information can be recorded for my gentleman when he's well and when he's sick", " And this stuff is cheap, easy to obtain, and we want to see how we can use this to improve our ability to identify patients who die", " So again, we're interested in using easily obtained data that are low- cost to improve our ability to identify patients of high risk of what we call adverse cardiovascular events, of which the worst is death", " Now, one thing to note about the surface electrocardiogram-- it encodes a lot of information", " And this is a normal ECG strip, ECG being electrocardiogram", " This, what I'm circling here, is one beat", " It constitutes one beat of the heart", " And what you notice is that there are three peaks associated with the electrocardiogram", " There's what we call the P wave, a QRS complex, and a T wave", " And it repeats in a quasi-periodic fashion, pretty regular", " Now, a healthy electrocardiogram tells you a lot about the patient", " It tells you that the patient's myocardium, the heart muscle, is for the most part normal", " The electrocardiogram records electrochemical impulses as they traverse through the heart", " And you need a normal myocardium, normal heart muscle, to have a normal electrocardiogram", " The heart, however, is not by itself", " It's not an island by itself", " It interacts with other things", " And there's the nervous system, which sends nerves to the heart, which helps to innervate the heart", " So the heart responds to nervous stimulation", " The classic example is the flight or fight response", " If you're running away from something that you're scared of, or if you become nervous at times, your heart starts to be faster", " That's because your nervous system is telling your heart to do so", " So a normal electrocardiogram tells you about the heart rate, tells you about the interaction of the nervous system with the heart, and it tells you about the myocardium", " We call it the endogenous factors-- the myocardium-- because that's intrinsic to the heart itself, and exogenous factors-- interactions with the nervous system", " And the nervous system is a combination of two types of systems that's not too important for this discussion, but are called the sympathetic and the parasympathetic system", " So again, when a cardiologist gets an electrocardiogram, he or she looks at it in a gross fashion and, to assess the health of the myocardium, the endogenous factors", " And you can look at the heart rate as well from the electrocardiogram, variations in the heart rate to determine the health of exogenous factors, and how that interacts with the heart and how those exogenous factors affect the heart", " Now, there are a number of automated approaches to try to analyze an electrocardiogram to determine who's at risk of bad events and who's not", " But a lot of those automated methods only focus on looking at changes in the heart rate, only really look at the exogenous factors", " So our hypothesis is that we can use computers to evaluate the electrocardiogram to look at both endogenous and exogenous factors to get an overall picture of the health of the patient, and thereby improve risk stratification for cardiovascular death, CVD for short", " Now, a cardiologist-- even the most well-trained cardiologist-- looks at an electrocardiogram, but it's very hard for he or she to determine very subtle differences between beats, very subtle abnormalities", " We're very good at detecting big things-- so if there are large changes in the QRS complex, large changes in T wave, or the parts of the beat", " But very small change that might be there, it's very easy to miss with the naked eye", " But that's the sort of thing that computers do exceptionally well", " Computers can look at beats and can quantify the differences in them, even though the differences can be quite minuscule and hard to detect by the naked eye, even by a specialist", " So we want to develop metrics to quantify subtle variability in the morphology of signals, and how beats change over time", " And the hypothesis is that beats that change a lot over time indicate an unstable system and are associated with patients who are at high risk of cardiovascular death", " So in this work, which parenthetically is pioneered by myself, John Guttag, who's a colleague of mine, in the Computer Science, Electrical Engineering and Computer Science Department-- and Professor Zeeshan Syed at the University of Michigan", " So if you take a normal electrocardiogram-- and remember, the goal now is to detect subtle variations in the electrocardiogram over time-- we pre-process it to remove bad beats, beats that are really abnormal, that maybe are caused by noise or other sorts of other things that really can cloud our ability to make rigorous statements about the patient", " Then, for every pair of beats within the ECG, we can align them and compute what we call the morphology differences between consecutive heart beats", " And from that, we get what's called a Morphology Difference Time Series", " So for every pair of beats, we compute the differences, and we get a time series", " And then we summarize the variability in this time series to get what we call the morphologic variability measure", " Now, the key aspect of this whole approach is this", " It's a rigorous method to compute differences in the morphology between consecutive beats", " So how do you do that? Well, if you have-- this is one beat", " Remember, from one of the previous slides, a beat is composed of several different peaks", " There's a P wave, a QRS complex, and a T wave", " So let's say these are two beats that occur in the patient", " The beats can vary by very subtle means as a ECG strip is being recorded, as the data are being obtained", " If you want to take just two beats and line them up with one another, you can take a look at this beat, look at all of the samples associated with this signal, look at all the samples associated with this signal, line them up, and just subtract them to get a difference between those beats", " But there's a problem with that", " If the beats vary by a lot in terms of their length, then you may end up pairing up this portion of the T wave at the region of the beat that doesn't correspond to the same physiologic event", " The T wave corresponds to something very specific, as does the QRS and as does the P wave", " So really, when you align beats and when you compare them, you want to make sure that you're comparing the same physiologic things", " So there is an algorithm that we use called dynamic time warping to align these beats, to ensure that they correspond to the same physiologic event", " Similar algorithms are used in the area of computational biology to align sequences, sequences of amino acids, sequences of nucleic acids, DNA, protein", " And really, essentially, you just want to make sure that you're comparing apples with apples, T waves with a T wave, QRS with a QRS, and a P wave with a P wave", " And then, once this pairing is done using this dynamic time warping algorithm, we can subtract the differences and get a meaningful result", " So quickly, to summarize-- we have our electrocardiographic strip", " We take two beats, we line them up, we perform dynamic time warping akin to a sequence alignment-- what is done in computational biology-- and we get a number", " We look at the next pair", " We do the same sort of comparison", " We line them up and we get another number", " Similarly, we do this for the next sequence of beats", " We get another number", " And we get this Morphologic Difference Time Series", " So this is time on the x-axis and this is the value on the y-axis that correspond to these differences", " So lots of variation here in this signal means that there's lots of changes in the heartbeat over time", " Even though these changes might be subtle, they'll be captured, because computers are very good at computing these differences and doing the alignment", " And so then from that, we can use this time series to compute measures of the variability of the underlying signal", " So again, Morphologic Distance Time Series captures both differences in the heart rate, because different heart rates means the length of the beats are different", " And that will give you a nonzero difference when you align the beats and when you compute the distance measure between them", " And so both in the heart rate, as well as the morphology, even if the heart rate is constant and the lengths of the beats are the same, if there are morphology differences-- So if the T wave looks slightly different one beat to another, the QRS complex looks slightly different one beat to another-- it'll be captured in this Morphologic Distance Time Series as well", " So it encapsulates both the exogenous and endogenous factors that affect the heart", " It's something that we stated that we wanted to address at the outset of this talk", " Now, myocardial ischemia-- by ischemia, I'm referring to what I talked about in one of the very earlier slides-- when you have a vessel that supplies the heart, there's a blockage that develops in that vessel, and then the heart is denied blood", " That's what ischemia means-- just denying blood to the myocardium, to the heart muscle, leads to abnormal repolarization, abnormal electrical conduction", " And it can cause subtle changes in the electrocardiogram", " So these are the endogenous and the exogenous factors", " This is what a typical Morphologic Distance Time Series looks like", " So this is time and this is the dynamic time warping morphology difference", " Looks like a mess, right? It's very hard for any person to look at this and be able to say with any certainty whether this patient is at high risk or not", " Now, with the computer, what we do is we take a look at this and we can quantify this in a very straightforward manner", " We can do this both in the time domain, or we can look at the power spectrum, do a Fourier transform, and look at in the frequency domain to develop various metrics", " So how do we develop this measure? So we have a list of patients from a database", " We have a database of patients who all had heart attacks", " And some of them died, some of them did not", " And they all had Holter monitors, which are devices that can record your electrocardiogram for a long period of time", " And we used this database to be able to develop our methods", " So when you look at the Morphologic Distance Time Series and then you look at it in the frequency domain, is there a particular frequency band that carries prognostic information? So what I mean by that is you have your time series signal, you transform that to the frequency domain, and you have a list of frequencies and you have the power spectrum", " So is there a particular range of frequencies that are more meaningful than others? So we sub the power in a particular frequency band to determine the patient's risk", " And we have to determine what band is appropriate", " So we use this DISPERSE2 data set of these patients-- some patients who died and some who did not die", " But all of them have had a heart attack", " And we use that to derive parameters for this model", " We created a heat map where we looked at the prognostic information on all possible frequency bands", " So here-- this is the upper band limit", " This the lower band limit", " And the colors here is an assessment of the predictive value within that frequency band", " This is a plot of-- for those you who are familiar with it-- the area under the curve from the receiver operating curve for this predictor", " And we found a particular diagnostic frequency that was actually very useful", " And once we developed this on DISPERSE, we took another set of thousands of patients-- the MERLIN TIMI-36 trial", " Again, this was a trial that compared a drug called Ranolazine to placebo", " But for the purposes of this, we were really interested in just the patients who didn't get a drug", " All of these patients, again, had heart attacks", " All of the them wore Holter monitors to record the electrocardiographic signals", " Some died", " Some didn't", " And we wanted to see if this metric that was developed on some other data set could be used to predict who would die in this data set", " And sure enough, if you compute the Morphologic Distance Time Series, you sum the power with a particular frequency band, and you get a number for each patient", " Those patients that have high numbers have lots of variability to the underlying signal", " And those are the patients that we call high risk", " Those patients that have a low value for this measure, we say are at low risk", " And if you look here, this is called the Kaplan-Meier Curve", " And this is the percent of people who died over time over the span of about a year", " The red is a death rate for patients who the algorithms says are at high risk", " And this is the death rate for patients that we say had low risk", " So what you see is that, sure enough, if the algorithm says that you have lots of variability in electrocardiographic signal, you're at a threefold increased risk of death", " And this is a P value which shows that these differences-- the statement here that's important is that this is statistically significant", " So this is really not by chance", " There's something really here", " And even if you look at different subgroups of patients-- so if you look at patients who are mature-- those are greater than 65, those that are less than 65-- in all these groups, if the algorithm says that you have lots of variability to the underlying electrocardiographic signal, you are at an increased risk of death, even a fourfold risk of death if you don't have high blood pressure, threefold risk of death if you do, and so forth", " So it works in all patient populations that we've looked at thus far", " And if you look at this and you compare this to other sorts of metrics, other sorts of things that exist in the literature for predicting who's at high risk of death and who isn't-- measures called heart rate variability, deceleration capacity, and so forth, as well as other metrics that are used in clinical practice-- of the electrocardiograph measures, the morphologic variability does quite well in terms of the hazard ratios", " So it says that you're about a twofold increased risk even after you control for all of these other metrics", " So it provides added value relative to these other metrics", " And you look at the ones-- and we've just pointed out a few here that are used in clinical practice to show that it is on par and it provides added information to these other known things that are used to quantify patients' risk", " So in conclusion, I think the one upshot to get from here is that electrocardiographic information is easy to obtain and it has prognostic value", " It just requires sophisticated tools to do so", " So one method-- to talk about this in a broader framework-- we want to get information about a patient, evaluate the patient using current and past information, and choose an intervention", " In clinical cardiology, as in many areas of medicine, this is typically the paradigm that's followed", " And you perform an intervention that's going to affect the patient", " Now, evaluation of the patient is perhaps the weakest link", " And by evaluation, I mean looking at the patient and trying to determine whether that patient is in trouble or not, getting sense of how sick that patient is", " And techniques from electrical engineering, computer science, medicine, and physics and such can help in this endeavor", " So one other thing-- there exists a lot of information in physiologic signals that's unappreciated, physiologic signals that are cheap and easy to obtain, and can be gathered in a lot of different settings", " So we believe that by gathering all of this information, you can make better inferences about patients so that you can identify those patients who are at high risk of having adverse events and treat them accordingly", " Thank you", ""], "O74Bw-NcCkY": ["ERIC GRIMSON: Let's visualize what merge sort does", " The basic idea is we're going to keep splitting the list down into smaller and smaller pieces until we get to basically, a list of one element each", " And then we're going to start recursively merging things together, taking two sorted lists and simply looking at the first element of each list to decide which is the next one to go into the merged list that's going to be sorted", " So if we start off with a list of elements like what's shown here, in the first stage we're going to split it into two parts", " And actually, we would do this recursively first with the front part, and then the back part", " But I'm going to show it in parallel", " And we'll keep splitting it until we get down to lists of just two elements each, such as for example shown here where I've got two one element lists", " At this stage, I can start merging by looking at each element, and putting the smallest element first, followed by the next element", " I then look at the next list, and again, these are two lists of one element each", " So I can once more look at each element to decide how to put the smallest element up first, and then the next element", " Now we can see where the real impact comes in, because given now two sorted lists, again the merge says looking at these two lists, check the first element of each to decide which is smallest, and put it at the front of the list, followed by the next smallest element, followed by the next smallest element followed by the next smallest element", " Now I have a sorted list", " Let me move that over, and I can now go and do the same thing with these lists", " I'm going to skip some steps, but basically that will reduce it to this stage", " And then the final stage, I could then merge this one by first comparing these two elements, moving the smallest one to the front, and so on", ""], "l4C_D90rBcY": ["NTA"], "BXfWJbn8gKQ": ["PROFESSOR: Here's some Python code that will let us test the greedy algorithm on the burglar's problem", " We define an item class, which will let us quickly hold all the information for an individual item, the name its value, its weight, along with a routine that will let us print out the contents of a knapsack in a pretty fashion", " We have a simple little helper function that creates a list of all the items in the house, the clock, the painting, the radio, the vase, the book, and the computer, along with their associated weights and values", " The greedy algorithm itself is pretty straightforward", " It starts with an empty knapsack and an empty total weight", " It then sorts the items in the order of the metric that we want to supply", " So we'll actually pass in a function, which will return the item's metric, a particular item's metric, and we'll use that as the key function here in the sort", " So every time the sorted routine wants to figure out the sort order of an item, it will call the corresponding key function-- We're passing in the item is an argument", " And that's the value that we'll use to sort of the items into the correct order", " And finally we ask for our sort in reverse order so we get the biggest metric first", " So it works pretty simply", " Once we have the sorted list of items, we go through the list one by one", " We check the items, get the item's weight", " We add the item's weight to the total weight that's currently in the knapsack", " And if there's still room in the knapsack, if that sum is less than the maximum weight than that knapsack can hold, we append the item to the knapsack and increase our accounting of total weight", " And when we're all done we return the contents of the knapsack as a list of items", " Here are our three metric function is that we wanted to try, the burglar thought of", " He was going to try a metric which was the item's value, a metric, which in a sense, was the item's lightness-- What we wanted to do was come up with a metric that would sort the lightest item first", " And if we do that, if we do the inverse of the weight, that's what we'll get", " And finally a metric that uses the ratio of the item's value to the item's weight", " Finally, we have our usual test functions", " We have testGreedy, whose job it is simply to run the greedy algorithm once using the specified metric and to print out the total number of items and their values in the knapsack that gets built using that particular metric", " And then finally, testGreedys allows us to test all three of the metrics", " So let's save that out and then give it to run and see what we get", " And here we go", " There's the items we want to choose from right at the top", " So if we look here, we see that if we use the value metric, the total value of the items in the bag is 200, and sort of what we expect because the most valuable item is the computer, which is the only thing in the knapsack, when we use the value metric because it has a weight of 20 which fills up the entire knapsack", " If we use as a metric the weight and we try to do the min weight first, we get a total value of objects of 170", " And you can see here the items are being chosen in order of increasing weight", " And finally if we use the ratio of the item's value to the item's weight, we"], "yeJJdf1sf7Y": ["Eric Grimson: We're now going to take the ideas we just saw and look at the different instances of different complexity classes", " So what are those ideas? Given an algorithm, we want to count what are the number of basic steps it's going to need", " We want to count those as a function of the size of the problem", " And we're only going to worry about the case when the size of that problem tends to get large", " What is the asymptotic behavior as that happens? We're going to see, in this segment, a set of examples of different complexity classes", " We're going to see constant time algorithms, referred to as O(1)", " We're going to see logarithmic", " We're going to see linear", " We're going to see log-linear, or n times log n", " We're going to see polynomial, and we're going to see exponential algorithms", " Let me say a word about those last two because they are actually different, and sometimes people get confused by them", " The polynomial time algorithm is something whose number of steps asymptotically is n, where n is the size of the problem, to some constant", " So a quadratic algorithm is n^2, a cubic algorithm is n^3", " An exponential algorithm is one where the number of basic steps asymptotically is described by some constant to n, the size of the problem", " So that could be 2^n", " And keep in mind that n^2 grows in a very different manner than 2^n, as we change n", " And in fact, this sequence is really listed in roughly the order of increasing complexity", " Each one of these classes describes a slightly more complex kind of algorithm", " And as a consequence, we tend to want to be as high up in this chain as we can", " If I have two algorithms that solve the same problem, one of them is quadratic, the other one is linear, I want the linear one because it's almost certainly going to be more efficient", " If I've got an algorithm that is log-linear, n log n, and another one that is just logarithmic, I want the log one because it's always going to be better", " Finally, we tend to be a little sloppy in this subject in terms of how we use these terms", " Really what we're talking about here are upper bounds on the complexity of the algorithm, on the number of steps", " In many cases, it's an actual tight bound, it's both an upper and lower bound", " But if we're not certain about an algorithm, we may end up saying, for example, that it's exponential because the best analysis we can do says that the running time may involve an exponential number of steps", " It may be possible to show that it's less than that, but if we can't actually do it, we're going to use the upper bound to capture the class", " With that, let's start looking at some examples", " So the first class is constant complexity", " That says the complexity is independent of the size of the input", " This is great, and unfortunately, there aren't very many interesting algorithms in this class", " It says, literally, that the number of steps doesn't depend on the size of the algorithm", " Now while pieces of code may satisfy that, it's not common for an entire algorithm to have that property", " If you've got one, though, still great", " And note, by the way, that even in this case, you can have loops or recursive calls, it's just that the number of iterations, through the loop, or the number of recursive calls, is independent of the size of the input", " All right", " Let's move on, though, to more interesting ones", " Logarithmic algorithms", " Here, the complexity of the algorithm, the number of steps, grows as the log of the size of one of its inputs", " And you've actually seen a great example of this, bisection search", " Remember when we were looking for square roots? We said start between 0 and x, take the midpoint", " If that's close enough, we're done", " If not, depending on the size, either we're going to look only in the bottom range or in the top range", " Again, we take the input, the midpoint", " And either we look at the bottom range or the top range", " At each step we're cutting down the set of possibilities of which we need to look by a factor of two", " And that cutting down a problem in half, constantly, is a great indication of, in fact, a logarithmic algorithm", " So bisection search is a great example", " You can do the same idea, by the way, on a list", " If I have a list of elements that are in order, and I want to decide if an element's in that list, use the same idea", " Look at the midpoint", " If I happen to get lucky, I'm done", " If not, based on the size, either I'll just look at the bottom half of the list or the top half of the list", " So that kind of property is indicative of a logarithmic search, the logarithmic algorithm", " Now, let me show you an example of a piece of code doing this, just to show you how we would reason about it to decide whether something's logarithmic", " This is a little piece of code to convert an integer into a string", " Don't worry about the fact that Python will do this for you automatically", " Let's just see how the algorithm shows logarithmic complexity", " I'm going to set up an internal variable called digits", " It's just the string of all the digits", " And then given i, if it's 0, I'm done", " If not, what am I going to do? I'm going to set up a little variable result that's initially an empty string", " And then I'm going to take that integer, i, and the first thing I'm going to do is I'm going to take the remainder, which basically pulls off the bottom digit", " I'm going to index in two digits to find the corresponding string representation", " And then I'm just going to add that to the front of result, putting it in the right spot on the thing that I'm accumulating", " And having done that, I'm going to divide i by 10, which throws away the bottom digit, shifts everything to the left, or to the right rather", " Then I keep doing that", " Now if I were to count steps here, what really matters is that loop", " And in fact, let's look at that", " I only have to look at the loop because there are no function calls here", " And within the loop, how many steps do I have? Well, I've got the remainder, that's 1", " I've got the add, that's 2", " I've got the look up, that's 3", " I've got the assignment, that's 4", " I've got the division, which is 5, and the assignment, which is 6", " So there are 6 steps within the loop", " But it doesn't depend on the size of i", " It's always the same thing, 6 steps within the loop", " So really what matters is how many times do I go through the loop? And for that, I have to think about, so what is changing? And what's changing is the iteration variable, or the loop variable i", " And at each stage through the loop, it gets divided by 10", " So how many times can I divide i by 10 before I get down to a single digit case? And the answer is a logarithmic time, so this is O(log(n))", " Now let's be careful here", " You might say, well, wait a minute", " Why doesn't this depend on the size of the integer that I pass in there? And it depends, not on the size, but on the number of digits", " Another way of saying it is-- if I have some number of steps to solve a problem with one version of i, and I take 10 times i, I'm only going to go through the loop one more time", " It's the number of digits, not the size of the problem", " And that's why it's logarithmic in the size of i because that log gives me the number of digits", " How about linear algorithms? Well, searching a list where I just walk through it in order is a great example of a linear time algorithm", " In the worst case, I've got to look at every element of the list", " So it's linear in the size of the problem", " Here's another example of a linear algorithm, and I want to use this to look at how we measure it", " Suppose I've got a string that's assumed to be composed of decimal digits", " I want to add up the characters of the string to get a number out", " A trivial little thing to do, but let's look at what the code might look like", " I'm going to start off with some initial, internal variable called val", " And for each character in the string, I'm going to convert it into an integer and add it into what I've got in val in order to return that overall value", " I don't care about the computation, what I care about is the complexity, and the complexity is pretty straightforward", " I have to go through each element in the string once", " So this is linear in the length of the string", " Within the loop, it's a constant number of things to do", " So all I care about is how many times do I go through the loop, and that is linear in the size of the problem", " So far we've seen examples where we're just looking at things that have loops, and we're worrying about how many times does it go through the loop", " We can also have a complexity that depends on the number of recursive calls, and our good friend factorial is a great example", " There's the code for factorial, you've seen it before", " If I think about the complexity of this, I could say, well, within the actual code itself, there's only a constant number of things to do", " I'm doing a test", " If the test is true, I'm just returning something", " Otherwise, I'm doing a multiplication and a recursive call, but in the body of the procedure itself, it's a constant number of things", " So what matters here is, how many times do I call factorial? And we can see that on each recursive call, we're reducing n by 1", " So I've got to do fact(n), then fact(n-1), then fact(n-2)", " And you can see that I'm going to call factorial n times", " Within each call, complexity's constant so, therefore, this is linear in the size of the problem because there's a linear number of recursive calls", " Algorithms with this kind of template are typically linear, and that's a handy thing to know", " What about log-linear? Well, a lot of practical algorithms fall into this category", " They're n times the logarithm of n", " In fact, an example we're going to see later on is one of the most commonly-used log-linear algorithms, which is an algorithm called merge sort, which is a way of sorting a list to get it into increasing or decreasing order", " I just want to highlight that we have algorithms of this sort", " We're going to come back to merge sort later on to see how we can do reasoning to find these kinds of examples", " So let's move on to polynomial", " Polynomial complexity says I've got an algorithm that grows as n to some power", " And most common polynomial algorithms are, in fact, quadratic", " They grow as n squared or some parameter, some size parameter, squared", " And these commonly occur when we have nested loops or when we have particular kinds of recursive function calls", " So let's look at an example, and this is probably a good example of a very common kind of quadratic complexity", " This is a little algorithm that's going to decide whether, given two lists, one of them is a subset of the other", " And that says-- is every element of L1 in L2? The code to do this we can describe pretty quickly", " We're going to loop over every element in L1", " We're going to set up, each time through the loop, to say a variable match is equal to false", " And what am I going to do? I'm going to loop over every element in L2, or almost every element in L2, looking to see if I find one that's equal to e1", " If I find something that's equal, I set the flag to True and I break", " And what that break does is it throws us out of this loop, this interior loop, which means I can then skip down to, basically, this step here", " And if, in fact, matched is False, I return False", " But if it's True, then I simply skip back around", " OK? And that then says I'm going to basically run through this loop until, either I go all the way through, in which case matched is False because I didn't find an instance of it, or I do find an instance, and I break out of it and I set a value that returns", " All right", " I'm going to do that over all versions of this outer loop, e1", " So let's look at an example to see how we'd measure the complexity here", " The outer loop is executed the length of L1 times, so however long L1 is, I'm going to do that outer loop that many times", " Each iteration is going to execute the inner loop up to the length of L2 times", " I have to go all the way through L2, the length of L2", " If I find something earlier, I break out of it", " So, in the worst case, this has a complexity that's the product of length of L1 times length of L2", " Now, that depends on L1 and L2", " What Is the actual worst case? Well, the worst case is when they're both of the same size", " L1 can't be bigger than L2 or it wouldn't be a subset", " When they're of the same size, but none of the elements of L1 are in L2, then I'm going to run through this loop the full number of times", " I'm going to run through it L2 times", " In that case, the complexity is quadratic", " It's the length of L1 squared", " It's quadratic in that size", " Let's look at another example", " Here's another example involving two lists, and I want to find the intersection of those two lists", " And here I want to show how, having multiple loops, we're going to focus in on the one with the worst complexity", " The idea here is I want to take two lists, L1 and L2", " I'm going to set up an initial temporary list, and then I'm going to loop over everything in L1", " And for every element of L2, I'm going to look to see-- is it equal to the thing I'm looking for in L1? And if it is, I'm going to add it into tmp", " Now because L2 might have multiple instances of something, I want to keep going", " So even if I find an instance of e1 in L2, I'm going to go all the way through L2 and gather each of those instances together", " I'm going to do that over all possible versions of e1", " And when I'm done, I need to now strip away the duplicates", " So I'm going to set up another temporary variable, res", " And then I'm going to loop over that list I just built, tmp, and basically say-- if e is not in res, then I'm going to add it in", " But if I've already got a version of it there, I'm simply going to ignore it and keep going", " So that, ultimately, it'll return a list of unique elements that are those that appear in both lists", " Again, what's the complexity here? Well to see this, we can note that this first nested loop up here is very similar to what we saw before", " It's going to take the product of the length of L1 and the length of L2 number of steps", " And, in fact, it's going to do exactly that because I go through L2 in full each time around", " What about this loop? There's a second loop there, I have to think about that", " Well, that second loop takes, at most, the length of L1 number of steps because I'm simply going through that list once", " So I've now got two terms", " I've got a quadratic term, and I've got a linear term", " And, of course, we know that the quadratic term really dominates here", " It's the big one", " It's the one that really matters", " So I can ignore the second term, and basically say that this is of order length of L1 times length of L2", " So it's quadratic", " The point of this is I need to look at the loops", " If I have different loops, or multiple loops, within a piece of code, I need to find the one that has the higher complexity", " And that will tend to be the nested one, as it was right there", " OK", " What about exponential algorithms? What characterizes an exponential algorithm? And an exponential algorithm, by the way, is usually a very expensive algorithm", " Well, it's typically a case when we've got recursive functions where there's more than one recursive call for each step of the problem", " We saw an example earlier", " Towers of Hanoi has two recursive calls", " I moved a smaller stack once, this moved the bottom case and then moves the smallest stack again", " So I had two recursive calls per each size of the problem", " And that is characteristic of an exponential problem", " But unfortunately, many important problems are inherently exponential", " And that's really unfortunate because the costs can be very high", " And one of the things we want to see is that's going to lead us to consider finding approximate solutions in more efficient time, rather than trying to do something that deals with finding the exact solution", " Nonetheless, let's do one last example here", " Let's look at an example of something that is exponential in complexity, and look at how we would actually measure it", " So this is an example where I've got a list of the elements, for example, it might be a list of numbers", " And I want to generate another list of all of the subsets of that list", " So if the list is one and two, I'd like a new list as output that has the empty list, the list of one, the list of two, an the list of one and two", " So all of the different possible subsets or combinations of elements out of that list", " Again, I'm not as worried about it, but I want to see how the complexity goes there", " So here's what the code does", " I'm going to set up a place to store my answer", " If there's nothing in the list, if the list is of length 0, then I want to return a list that is just a list of the empty list", " So there's this funky-looking thing right here with two square brackets", " So it is a list whose only element is the empty list because that's the only possible subset of a list of length 0", " Otherwise, how am I going to solve this? Well, I'm going to use that recursive idea", " I'm going to first say, let's take everything in the list but the last element, and get all the possible subsets of that", " I'm going to call that smaller, right here", " I'm going to get a list of just the last element right there, which is extra", " And here's what I want to do", " I want to take all of the things in smaller, and add that last element to them because those are all subsets of the longer list", " And then I want to take all of the instances, all of the subsets without the last element, and all of the subsets with the last element, and add them together", " And I'm done", " So there's a little loop where I take everything in the smaller one, and I add that last element on to it", " And I create those into new", " And then, finally, I create a flattened version, which is all of the versions without the last element, all of the versions with the last element, and I'm done", " You can go code this up and try to see that it does the right thing", " What I'm really interested in is the complexity", " So to measure that, I'm going to assume that append is actually constant time", " In fact, it is, given the implementation inside of Python, but since it's not a basic element, I need to make that assumption", " And now what do I want to look at? What's the time? Well, the amount of time it's going to take here is basically going to be the amount of time it takes to solve this problem, the smaller size problem, plus the amount of time that's needed to make a copy of all the elements of the smaller problem right there", " OK? So how can I get at that? Well, it's important to think about the size of that smaller problem", " And, in particular, we know that, for a set of size k, there are 2^k cases", " There are 2^k different possible subsets inside of there", " So if I want to solve a problem of size n, I'm going to need to solve a problem of size n - 1, and there are 2^n possible solutions there", " And then, in the problem of size n - 2, there are going to be 2^(n-1) and so on, all the way down to 2^0", " Now we can actually solve this, but a little bit of math actually tells me that that sum, 2^0 + 2^1 + ", "", "", " + 2^(n-1), is 2^n", " And so the math tells us that this is a problem of size 2^n", " This is important because it looks like there's just one recursive call at each step, and there is", " But it's on a problem whose size is growing exponentially", " And that, therefore, when I come down here, and I want to walk through that list, basically adding all of them in, that loop there has a size that's O(2^n), for whatever the length of the list L is", " And as a consequence, this is an exponential-sized algorithm", " OK", " So what does that give us? It says we've now seen a sequence of different instances of classes of algorithms", " We've seen characteristics or templates of each one of them", " And we've seen, that as we go down this list, they get worse and worse", " As we go through the rest of the course, we're going to see examples of this complexity", " But those templates already give you a way of getting a sense of what is the complexity of a particular solution", ""], "lCDWElPHVa4": ["ERIC GRIMSON: Now, we've seen recursive functions", " We've seen this idea of inductions, a way of showing that these functions work", " And we've seen this notion of recursion as breaking a problem down into a simpler version of the problem plus some other work", " We're going to use that tool a lot", " It's a powerful tool for taking complex problems and capturing them in a way that is easy to think about", " So let's look at some examples", " In the classic example to start with is to compute factorial", " Factorial in math is written as n followed by an exclamation point, said verbally as n bang", " And factorial is basically the product of the integers from 1 times 2 times 3 all the way up to n", " How would we think about solving this recursively? Well that's pretty straightforward, right? I need a base case", " A simple case is if n is equal to 1", " 1 multiplied by itself, or just 1 is 1", " That's simple", " To get the recursive case, let's use that same thinking", " To get the recursive case, what do I have? I want a simpler version of the same problem", " In effect, right there that is n minus 1 factorial", " So recursively I would say if I can get n minus 1 factorial, then to get n factorial I'd simply take that value and multiply it by n", " And that gives me that reduction exactly like I saw before", " Fantastic", " There's a recursive definition factorial", " Let's capture it in some code", " And, in fact, to do it let's do both an iterative version and a recursive version", " So the iterative version of factorial has the form we'd expect", " I need some state variables", " One of them is going to be just the parameter n that I'm passing in", " And the other one I'm going to call result", " I need to keep track of the computation as I go along", " I'm going to set a result initially to 1 because I'm going to do successive multiplications", " And then the iterative version basically says if you start off with n that's bigger than my base case, or the stopping point, rather, what do I want to do? I'm going to take my current value result, which is 1, multiply it by n, and store it away", " And then I'm going to reduce n by 1", " There are those update equations that are updating the state variables", " I go around again, n is now one smaller", " And again, I take the current value result, which at this point was n", " I multiply it by the new value of n, which is n minus 1", " And I update it", " I reduce n by 1", " And I keep doing this", " And you can see that I want to start by taking n, n times n minus 1, n times n minus 2, and I'll keep doing that until I get down to a place where n is zero, in which case I stop and I return the result", " Great", " What about the factorial version recursively? Well, factR is nice and crisp", " Here it is", " It just says, if n is equal to 1, if you're in the base case, just return that value", " Here I said return n, I could have said return 1, because I know it's going to be the same thing", " Otherwise, get the solution to a slightly smaller problem by just recursively calling factR, multiply it by n, and just return that result", " Beautiful code", " Nice and clean and crisp", " And you can see that it gives you a very clear sense of exactly the stages-- my base case, my recursive case", " My recursive case is a recursive call plus one other operation, which is to do multiplication", " Let's see if it does the right thing", " So in IDLE, I've got a version of both pieces of code, then let's try first theater diversion of factorial", " And just to be careful, let's make sure it does the right thing on the base case, or n is equal to 1", " If it does then let's give it the bigger one-- I happen to know that 3 times 2 times 1 ought to be 6", " So there we go", " And if I give something a little bit bigger, wow, it actually computes factorial of 25", " Pretty quickly", " What about recursive version? Well let's test the same ones", " On 1 it does the right thing", " On 3 it does the right thing", " On 25 it does the right thing", " And you may notice this funny little form on the screen there where it's got an L at the end", " This is just telling us that Python's got such a big number, it's representing it in what's called a large format", " Don't worry about it", " It just says, I got a really big number", " I gave it back to you", " So we didn't look at stepping through it", " You can go do that", " But you can see that the recursive version stops, computes the right answer, and the code itself is nice and crisp", " OK, let's look at another example", ""], "PkWUiKtz_DA": ["NTA"], "AQgw8njOMec": ["NTA"], "SKyhk7j3NJA": ["NTA"], "bqmKVKr4rGI": ["NTA"], "B03dhB-YmMM": ["JOHN GUTTAG: Hello, it's me again", " In the last segment, we looked at hashing and hash tables by drawing a bunch of pictures", " Now it's time to look at some code", " The class intDict uses a simple hash function, the same we looked at before, modulus, to implement a dictionary with integers as keys", " I know that's boring because we could just use a list, but it's at least easy to understand", " The basic idea is the same when we looked at in the last segment", " You represent instances of class intDict by a list of buckets where each bucket is a list of key value tuples", " By making each bucket a list, you will recall, we handle collisions by storing all the values that hash to that bucket", " By the way, there are many other ways to handle collisions, some considerably better than using lists", " But this is probably the simplest mechanism", " And it works fine if the hash table is big enough, and the hash function provides a good enough approximation to a uniform distribution", " All right, to the code", " So we've got class intDict", " Init does exactly what we looked at in the last segment", " It takes the number of buckets as an argument, and then creates an empty dictionary, and then goes through and adds to each dictionary a bucket, which is initialized to be the empty list", " Exactly what we saw in the picture in the last segment", " addEntry entry, takes the key and the value", " It starts by finding the correct bucket", " It does that by taking the key and then hashing using modulus", " And it gets the number to take it from self", "numBuckets", " If we go back, we'll see that we saved numBuckets as an attribute of the hash table being created", " Consequently, we can retrieve it here and use it", " It's then going to go look at the hash bucket, as we did in the last segment, until it finds the dictionary key", " If it does, it updates it and then returns", " Notice that once it's returned, it's done", " It never gets to this statement if it returns", " On the other hand, if it finishes this loop without finding the key, then it just adds a new tuple dictKey, dictVal to the dictionary", " getValue is very similar to addEntry , a little bit simpler", " Once again, it has to start by finding the bucket, which it does the same way", " Once again, it has to search through the bucket, looking at each element, to see if it can match the key", " If it finds a match, it returns the value associated with that key", " Otherwise, it didn't find the match, then it returns None", " I suppose it would have been perhaps better to raise an exception, but I'm sure you get the idea", " Let's now go look at the code window", " Way down at the bottom I've got one extra method we didn't look at", " That's the string method", " And it does nothing interesting, it just provides a way to print it", " Now let's see what happens if we use it", " It does nothing very interesting", " It creates a dictionary with 29 entries", " And then I'm going to, for i in range 20, that's going to be a number of inserts, I'm going to choose a random integer in the range up to 10^5 -- so quite a large range of numbers", " That will be my key, and then I'll add that key with i, the i-th insertion as the entry", " Then after we've built it, we want to look at what's in there", " In order to make it a little easier to see, I'm going to print it bucket by bucket so that we can see the buckets", " But of course, that violates the abstraction barrier", " I really shouldn't be doing that, in a good program", " But for pedagogical reasons, it's worth doing", " So let's run it and see what we get", " Well, we get 29 buckets which, conveniently, just happens to fit on our screen", " If we look at it, we'll see that some buckets, like the first one here, have just one element in them", " Other buckets have multiple elements because there's been a collision", " And a lot of the buckets are empty", " But again, observe, even though the keys can get very large, I don't have very many collisions as we're inserting 20 elements into 29 buckets", " Now let's return to the code for getValue", " What is it's algorithmic complexity? Well, let's look at the simple case", " If there were no collisions, what would happen? We'd go through this loop exactly once", " And so it would be order one", " Suppose there's a collision", " Well, as we saw last time, if there's a collision, it has to go down the entire length of the list in the bucket", " Let's think of the simple case where we got very unlucky, and everything hashed to the same bucket", " Well, if we inserted n elements and each hashed to the same bucket, then we would have to do order n trips through this loop to see whether or not we had an entry", " But remember, we decided that our hash function was uniform, or we would design it to be uniform, and therefore it's unlikely that everything would hash to the same bucket", " In fact, let's think about what the actual predicted time should be", " Let's assume that we have k buckets and n insertions", " And again, let's assume the hash is uniform", " What is the average length of a bucket? It's simply the number of insertions divided by the number of buckets This wraps up our brief excursion into hashing", " There are a small number of things to take away", " One, and this is probably the most important thing to remember, hash tables are really useful, especially if you want to optimize the time required to look up keys other than integers", " If the key is an integer, a list works just fine", " Two, it's very important, as we've said perhaps too many times for your taste, for the hash function to provide a uniform distribution", " Otherwise, we get too many collisions", " And finally, a hash table is an example of a data structure that allows us to trade time for space", " By using more space, we can use less time", ""], "hI10vDNYz4M": ["NTA"], "flilzpxT3Pc": ["NTA"], "f2655NqIYtA": ["So, we're ready to start thinking about testing", " We've written a piece of code, perhaps several things that interact with one another", " And we're ready to start checking to make sure it really does the right thing", " Our goal, ironically-- or strangely, if you like-- is to show that bugs exist", " Now you may say, wait a minute", " Don't I really want to show that there are no bugs in my code? And the answer is, if you could, that would be great", " But it's really hard to do", " It's often much easier to show that there is something than to show that there isn't something", " And so while, ideally, we'd like to show that our code is bug-free, what we really want to do is try and run enough tests to either identify that there's a bug, or convince ourself that there's a good chance there isn't", " Why can't we just show there are no bugs? Well, part of it is that it's often impossible to run all possible checks", " If I've got a numeric function, I might, in fact, actually have something that has billions of tests", " And I don't really want to spend the time to do all of those tests just to show that the code is completely bug free", " That's a slight misstatement", " If it's a really crucial piece of code, I might do that", " But in general, I just don't have the time to run an all possible test", " There are some formal methods, that is mathematically based methods, that can sometimes help actually prove that the code is bug free", " But they usually only work on simple kinds of code, and they're not going to be always available to us", " So, let's think about how do we do the testing", " Well, what we want to do is to find a collection of inputs that have a high likelihood of revealing bugs, but where the testing is actually going to be pretty efficient", " It's not going to take a lot of time", " And this is called a test suite", " The idea is that we're going to partition, or divide up the space of inputs into subsets that provide equivalent information about the correctness of the code", " What does it mean? It says if I have a set of possible inputs, I'd like to break it up into pieces", " And say, any input from this piece, the performance is going to be pretty indicative of the performance of other inputs from that piece", " Any input from this piece-- same thing", " Performance is going to be indicative of the performance of the things inside of that piece", " And so what we're going to do is divide up the set of all possible inputs into a group of subsets with the property that each element of the set is in exactly one subset", " So, all possible inputs-- I want to partition them up", " Once I've done that division, I'm going to construct a test suite that contains one input from each element of the partition", " From each different piece I'll select one input, and then I'll run the test suite on that to see how well it does", " Let's look at an example", " Here's a little piece of code", " In fact, I haven't shown you the code, I've just shown you the specification", " Want to say, is x bigger than y", " And what is bigger does, is it assumes that x and y are integers", " And it's going to return true if x is less than y, otherwise false", " What's the input space? On the input space here is all pairs of integers", " Now that's obviously a really big how might I partition this up? Well, I could take advantage of things I know about integers", " And so, here's a possible partition", " I could say, look at one part of the space where both x and y are positive", " Look at another part of the space where x is negative and y is negative", " And then, one's positive, the other's negative", " And if you think about the plane of integers-- or the set of integers, all possible pairs-- I'm dividing it up", " Now I have a couple of other special cases that I know were unique or interesting about integers", " So, in particular, I can also look at the case where x and y are both zero, and then when x is zero but y is not, and y is zero but x is not", " So this is now dividing up the space", " And notice, I've got every possible case", " No, sorry", " Bad way of saying it", " I don't have an example from every possible case, but I have taken the space and divided it up so that all possible tests are covered by one of these particular cases", " OK", " Now, why? Why this partition? I could have lots of other choices", " I might have said, look at one where x is prime, and y is not", " Where y is prime and x is not", " Where they're both prime, where they're both not", " That's also a division of the space", " But it's not really relevant, right? This is irrelevant to the problem", " Knowing whether something bigger or not is really not going to depend on whether it's prime", " The division I made was more based on the idea of what does the space look like", " The second thing I did is that spaces of inputs often have some natural boundaries", " Integers are either positive, they're negative, or they're zero", " Ah-hah! That's why I use that partition", " In fact, I'd broken it up into both positive, both negative, one positive, one negative", " And then the cases where things were zero", " Actually, if you think about it from this perspective, if integers can be one of three kinds, shouldn't I have nine cases? Three different cases for x, three different cases for y, and all the combinations of them", " And the answer is probably, yes", " And in fact, I could really split this case, where x is zero and y is not equal zero, into x is zero, y is positive, x is zero, y is negative", " And the same for the other case", " And that would in fact, give me the nine cases that would make more sense", " What you see here is an example of breaking up a partition, of built or broken up the input space into groups, sets, classes", " Now what I'm going to do is basically use that to think about how I'm going to build a test suite", " Before I do, though, let's say, gee, what if there is no natural partition to the input space? What can I do? Well, a couple of choices", " One is I could just do random testing, that is I could simply take a bunch of examples and keep trying them", " And use the result that the probability that the code is correct increases with the number of trials", " But really I should be able to, in those cases, use the code to do better", " So, in fact, we're going to split up our testing into two different kinds of testing", " One is going to use heuristics based on exploring paths through the specifications", " We call that black-box testing", " The second one is going to use heuristics, based on exploring paths through the code itself", " We call that glass box testing", " And so, we're going to take now this idea of partitioning up the space, and couple it with these two ideas to look at how we actually build test suites", ""], "sViMNECYhZs": ["ERIC GRIMSON: In the last section, we introduced a couple concepts in terms of writing programs or scripts", " We had straight-line programs, where we had just a linear sequence of instructions and we executed them 1 at a time in order", " And we added the idea of branching, or conditionals, where we could do a test, and depending on whether that test was true or false, we might skip to 1 piece of code or a different piece of code", " But in both cases, we're doing each instruction at most once", " Useful, but not great", " To get to the ability to write programs or scripts with arbitrary complexity, we need 1 more key concept, and that concept is the idea of being able to reuse a piece of code an arbitrary number of times", " We might have a set of things we want to do once or depending on some value, twice, or depending on some value, 27 times or 1,000 times", " And rather than having to copy the code that many times, we'd like to be able to have the computer automatically reuse the code as many times as desired", " That notion of iteration is going to be incredibly valuable, and we're going to talk about some constructs to help us make that happen", " The basic idea, though, is straightforward", " Given that we have some code we're executing, when we get to an iteration loop, which is this chunk right here, we start with a test", " That will be Boolean that will return either True or False", " If it's True, we're going to go down and execute some set of instructions, the body of the loop, and then go back around and do the test again", " And we'll keep doing that", " As long as the test is True, we'll execute that same set of instructions in the body over, and over, and over, until finally, the test is False, in which case we skip around the loop body and pick up the computation elsewhere", " This notice allows me, based on this Boolean test, to be able to do the code some arbitrary number of times, and that's really great", " Let's look at an example", " Here's a simple example that shows that idea, and I want to talk about the syntax of the construct, but also about what the example's going to do", " This is a simple piece of code that squares a number", " I want to get x squared, but I'm going to do a by just successively adding x to itself x times, which is of course what x squared actually does", " I add x copies together", " Notice what we've got", " We're going to set up some value of x", " I'm going to do a binding there", " We're going to bind a variable ans for answer, which is where we're going to add up all the instances of x to get where we want to be", " And we're going to need to keep track of how many versions of x do we still have to add in", " So we're going to set up another variable called itersLeft, initially bound to x", " The looping construct, the iteration construct, we have is called a while loop", " And there's the key word while, and it has the following property", " It has a Boolean test-- in this case, we're checking to see whether itersLeft is equal to 0 or not-- followed by a colon, and then it has a set of indented instructions, which of course, are the body of the loop", " The way the while loop works is it first tests that Boolean", " If that Boolean is True, itersLeft is not equal to 0 in this case, it will then execute each of the instructions in the body in sequence", " And when it gets to the end of that sequence of instructions, it's going to go back up and retest the Boolean again", " So it will cycle through this code multiple times until that Boolean is finally False", " When it is False, it will skip down to the end of the loop, which is shown by where the indentation stops, and pick up the new set of instructions and continue", " So there's the structure, let's see if this does the right thing", " Well, here's my code, and let's just walk through this", " We won't run it on idle, we'll just walk through it", " Initially, x is bound to 3, ans is bound to 0, and itersLeft is bound to 3", " The while loop says, test to see if this is equal to 0", " Since it is not equal to 0, the test is True, and therefore, I take the current value of ans, the current value of x, add them together, and rebind that to ans", " I then take itersLeft, subtract one from it, and rebind that to itersLeft", " So I've decremented itersLeft, and I've incremented ans", " I go back up, and again, I check", " Is that not equal to 0? It is not equal to 0", " Therefore, I take ans and I take x, I add them together, and I rebind those to be the new value of ans", " I change itersLeft by 1", " That's my new value there", " And again, I go back through the loop", " That is not equal to 0", " Well, the test is still True, so again, I take ans, I take x, add them together, create that to be my new binding for ans, which is 9", " I take itersLeft, subtract 1 from it, there's my new value of itersLeft", " And again, I go back to the top of the loop", " At this point, 0 being not equal to 0 is False", " Terrible way of saying it, but that test is no longer True", " It's False", " In which case, I will skip to the end of this loop, and print out that x * x, or if you like, 3 * 3, is equal to 9", " Cool", " A little slow, but it does what I want", " Notice I have reused this code an arbitrary number times", " And in fact, if I were to change x to be something else, I will reuse that piece of code a different number of times", " There's my iteration that I really want", " You can also see some properties of an iterative loop", " First of all, we need to set an iteration variable outside of the loop", " In this case, it's x and itersLeft", " Actually, the one I really care about here is itersLeft", " I also need to test that variable to determine when I'm done", " There's the use of itersLeft inside of the test", " Now, it could be a simple test, it could be a more compound test, but that's basically what I need to test", " And finally, I need to be changing that variable inside of the loop, right there", " If I didn't, then that test value would never change, which means I would never stop the loop", " But there's a property I need", " When I set up an iterative loop, I need to say what's the variable I'm setting outside, how am I testing it, and am I making sure to change it somehow inside of the loop in order to ensure that I get the pieces that I want", " So what do we have now? Well, that's a really valuable construct", " We already saw that branching structures, things like conditionals, will let us jump to different pieces of code based on a test", " Once we add in the idea of looping over the code, things like a while loop, that allows us to repeat pieces of code until the condition is satisfied", " So it's a generalization of a conditional", " On simple branching structures, we've already said that programs like that are constant time, that is, we execute each instruction at most, once", " With looping structures, notice that things are different", " Now, the program is going to take an amount of time that depends on values of variables as well as the amount of code or the number of instructions inside the loop, because it's going to depend how many times we walk through the loop, and that depends on the variable", " Nonetheless, these loops are going to be really valuable, and we're going to turn to that next", ""], "lcDQ7GqlS-M": ["Let's apply our curve fitting technology to the results of another experiment", " What we're going to do is to fire an arrow at a target", " So as we notch the arrow on the bow spring, and we pull the arrow back, getting ready to release it, the arms of the bow are bending, and this is another example of a very powerful spring at work", " And when we release the arrow, it will fly to the target", " And what we've done is we've taken a bunch of measurements", " So as the arrow flies up, and then falls back down and hits the target, we're going to be measuring the height of the arrow at various times during its flight to the target and work to fit a curve to that", " So you can come up with a mathematical equation that describes the flight of the arrow", " We'll also be looking into ways of measuring how well our curve is actually fitting the data", " Up to now we've been sort of eyeballing it, which was a good start, but we can actually develop some sensible mathematical measures that will tell us about the goodness of the fit", " Here's some Python code that lets us experiment with the data we got from firing the arrow with the bow", " As before, we have a procedure that helps us get the data out of the data file and put it into a bunch of lists", " In this case, what we have is a bunch of distances at which we made the different measurements, and then for each distance, we have the heights at that distance from four separate experiments", " To actually do the curve fitting, here we have tryFits, which is very much like the routines we've written before", " We're converting the distances which were in yards into feet, and then we're going to process the four measurements from each of the experiments into one average measurement for the height at that distance", " With that in place, what we can do is to go off and plot the actual observations, again, as blue circles", " That's what that little \"bo\" means there, is the argument to plot", " And we're going to use polyfit as we have before to do a linear fit to see if there is a linear relationship between the distance this arrow has flown and its height above the target", " We're all set to go", " Let's save this out, and then run it, and see what the plot looks like", " So here we have the data", " You can see it as the arrow flies from the bow over here to the target, and the target looks to be about at 1,080 inches from where it was released", " You can see it follows a trajectory where it goes up, and then it comes back down again", " And here's a linear fit of a line to that data, and it's probably fair to say that the hypothesis that the arrow travels in a straight line from the bow to the target is not a good hypothesis", " You can just see that this linear fit seems to really bear no relationship at all to the actual data points", " So let's go back to our code, and let's try a parabolic fit", " And so, what we're going to do is to look for a quadratic equation that relates the distance to the altitude of the arrow", " So let's get this code back into execution", " This is just an addition of fitting a second degree equation to the data, and let's see how that goes", " So we're going to save this out, and run it again, and look at the plot", " And, yes", " Here we go", " So this curve here actually looks like it fits the data pretty well", " The jaggedness comes from the fact that we're just simply plotting the parabola only at the data points at which we actually had measurements", " It would be possible to plot the parabola using many more values", " Since it's a mathematical model, we could choose other distances that we didn't make measurements at, and then the parabola would look much more smooth", " So that looks like a pretty good fit", " And so, we're sort of happy with that", " Maybe what we should do, though, is to think a little bit about how do we measure the goodness of a fit? Is there some mathematical analysis we can do that would reveal that the line is a lousy predictor of the observations, whereas the parabola is a much better predictor? So how do we measure the goodness of a fit? Which one of these curves actually fits the data better, the quadratic fit or the linear fit? And we can tell by eye which one we seem to think is much better", " Let's see if we can develop a mathematical explanation of which one is better", " I guess the basic question is, does the model fit the data? Are our predictions coming close? Let's start by talking about a measure of the size of the errors that are being generated between the predictions and the observed points, so we can talk about the variability of error", " So, we sort of start there", " We can say, well, variability of the errors", " How much are the errors varying? So here, we can see that the errors are huge", " They're big and they're small, and so if we talked about a mean error, how much are we varying from the mean? Are the errors pretty much all the same, or are they big, or are they small? So we're talking about the variability of errors", " And a standard measure of variability is the variance", " And in fact, we've seen this", " This is, in fact, just exactly the least squares if we look at the error, which is the difference between the observation and the prediction, and we take the sum of the square of those errors over the whole thing", " And then we do some sort of normalization here-- so there's some sort of normalization constant, which I won't bother to put in-- that would give us a sense of how much the errors vary", " So if there was small errors all around, then in fact, the variance of the errors would be small", " And we can say, well, that's good enough", " We could just sort of take this number, and whatever its value is, a small value would mean the model fit well, and a large value would means that the model wasn't fitting", " But the trouble is that if we're making observations in terms of parse x, the errors may be smaller in parse x, but as an absolute value, the errors are sort of huge", " So really what we want to do is to compare the variability of the errors to the variability of the original data", " So we can use the same sort of measure of variability, the variance of the data, which is, again, some sort of normalization factor, and we're going to talk about the values of the observations relative to the mean observation", " So that would be the variance of the data", " And what we want to do is to compare those, make a ratio of those two quantities, to get a sense of how well the model is fitting the data", " So the fraction of the variability that's not explained by the model has to do with the ratio of the variability of the errors-- which is the part that we're not explaining with the predictions that we're making-- over the variability of the observation", " So think of this as a normalization factor", " And so, this gives us the fraction of what we're observing that's not explained by the model", " So that means that the fraction of the variability that is explained by the model is basically 1 minus that ratio, so the variance of the errors over the variance of the data", " And this is a very useful measure", " This gives us a sense of how well the model is explaining the observations that we're making, and we hope that we're doing a good job that the variance in the errors is small compared to the variance in the data, which means that we're explaining almost all the changes in the data that we see", " We're able to predict them", " So, this is given a name, r squared, and this is called the coefficient of determination", " So when the coefficient of determination is close to 1, that means that the model is doing a good job of explaining the data, and when the coefficient of determination is very small, close to 0, that means that there's not much of a match at all between the model and the data", " And we never expect r squared to be 1, because that would mean we had no error at all, and we expect most of our experimental observations to have some small amount of error", " Let's put this observation into some code", " Up here, we've written a procedure that will compute the r squared value given a set of measurements and a set of predicted values", " And so, here we can see that we're calculating the sum of the squares of the estimated errors, and then down here we first compute the mean of the observed values, and then we compute the difference between the mean and the measured values and the sum of that squared", " So we've left out the normalizing factor for the variances, since the two normalizing factors cancel on the ratio", " So finally, we form that ratio of the variance of the errors over the variance of the data, and then we subtract that from 1 to get the r squared value", " And then down here, what we've done is to modify tryFits into tryFits1, and we've simply gone ahead and calculated the r squared value for each of the two fits, and put that on our plot", " So we're all ready to run that", " That's the code down here", " So let's save this out, and then run it, and see what we get", " So now, the plot is exactly the same as before, except that we've reported the r squared value for each of the two models", " You see the linear model, which we sort of suspected wasn't a good fit at all, actually is a very, very poor r squared", " The variability of the data is not explained well at all by the linear model", " However, the quadratic model actually has a very good r squared", " So that means that, in fact, the quadratic model is explaining most of the changes that we see in the observation, so the model predicts those changes", " And there's a small amount of variance in the observations that's not being explained, and that comes from the observational errors", " So the conclusion is that we can use the r squared value to give us a sense of whether our model is doing a good job of predicting what the data is actually doing", " If r squared is close to 1, the prediction is good, and if it's not close to 1, then the prediction is less good, and maybe we should continue our search for a better model", ""], "WntLU2CrfdE": ["Let's visualize what happens with a Fibonacci series, using the original idea from Leonardo", " We start off with the single female", " At the end of one month, she's pregnant", " Which means at the end of the next month, she's still there, but she's given birth or whelped another female", " At the end of the next month, that first female again has whelped one more time", " The first offspring is now pregnant", " And there are now three rabbits running around", " And at each stage you can see that after one month of growth, if you like, each new rabbit produces another one", " So at this next stage two of them whelp, at the next stage three of them whelp, at the next stage five of them whelp", " And you can see we're going to have a ton of rabbits in a hurry", ""], "gAj5vgOzJB0": ["you've learned", " Think about it-- you've actually covered a great deal throughout this course", " Let's wrap up by talking about where you're headed", " First, let me start by pointing out that we know that many, if not all of you, worked incredibly hard, often juggling other time constraints in order to spend time on this course", " And we really appreciate it", " We've also worked hard to try and refine the course as we've gone along, since it's our first time through it, to try to make sure that it really worked well", " But we greatly appreciate the effort that you put in", " I think the key thing I would like you think about is, what's your return on investment", " You're the only one that really knows it", " But I really would suggest that it's handy for you to go back and take a look at some of the first problem sets and realize how straightforward they are for you to solve now", " And yet, remember that maybe when you started, they looked a little scary", " Look at this sophistication of the problem sets throughout the term and realize just how quickly you've come up to speed in terms of being able to think computationally", " And in particular, think about what you'd be willing to tackle now", " And compare it to where you were several weeks or several months ago when you started this course", " You've put in the effort", " We really hope that your return on investment is high, but we think that it's likely that you can now solve a wide range of problems much more sophisticated than what it was when you started with this class", " And we'd like you to remember that in particular, you've now got a set of tools that can give you answers to problems", " Computational thinking is the new arrow in your quiver, if you like", " We've taught you a set of algorithms-- basic classes of algorithms", " But you can use them in any way you'd like", " So we really hope that you take these ideas and when you now sit down and are faced with the problem, one of the first things you say is, how can I turn this into something computational", " What kind of algorithm would best tackle this? What are the abstractions that would really be important to think about this? How can I suppress detail and focus on the key elements of it? How could I write code that helps me give answers to things? So that when you get a new problem, first question you ask is, could I capture this computationally, and if I can, how quickly could I write a piece of code that will give me a good approximation the answer that I want", " That's where you've come to", " That's where you're headed", " You now have those tools, and you're ready to run with them", " What else could you do with it? Well we hope that you've also now got a basis for computational thinking that sets you up to explore other ideas, whether it's another course online, or whether it's reading, or in other ways", " But indeed, you are now set to think about other things", " And here are four suggestions of different areas you might head", " You're certainly now prepared to think more in detail about algorithms and data structures", " You knew a lot of basic things", " You got an amazing setup of tools already in place, but there's a whole wealth of more sophisticated and complicated algorithms that can tackle a wider range of problems available to you", " And you might think about exploring those ideas", " Again, whether it's reading a book, reading some articles, or trying another online course", " There's a whole other range of areas called AI-- artificial intelligence, smart machines", " And you now have the basis to start using the tools that you have in order to start thinking about those kinds of problems", " There's a lot of nice courses that introduce you to the notions of AI-- reasoning about things and under uncertainty in order to deduce new information", " Machine learning, being another very common problem or technique here, that I would suggest is now available to you", " You have the basis to start thinking about machine learning problems, an area that's becoming very widespread throughout the world and something that you'll learn more about", " Of course, you could build more on programming by taking an additional course in software engineering", " Or you might decide you really want to understand what is inside the machine", " We talked about that interpreter, that evaluator, but how do you really build one", " And you could dive inside the machine to think about how does a computer actually put the pieces together and focus on computer architecture", " Finally, what I'd really like to say to you, and all the staff would like to say to you is, good luck", " You started a journey on computation", " We hope that journey takes you many places", " And we hope that you find that the tools you've learned in this course are really of value to you, almost anywhere in any domain in which you're working", " And that when you are faced with a problem, you say, I know how to solve that", " I can turn that into a computational solution", " And I'll write code that gives me the answer I want", " So good luck", ""], "yGAPgGgodyo": ["In this fifth lecture we're going to first talk about the functions we've been writing, especially about how we can think of them as iterative computations that capture the heart of a computation as a set of state variables that update with each iteration through a loop", " We will then build on that to talk about the wonderful concept of recursion, where we reduce a computation to a simpler version of the same problem, and then use that idea to very crisply and cleanly capture computational processes", " We will show how this idea of recursion builds on the concept of induction", " And we will in particular use this to reason about why recursive algorithms work", " And, we'll use that idea to guide general principles in designing recursive algorithms", " To demonstrate this, we will show you a number of classic and fun recursive algorithms, especially algorithms we call divide and conquer methods", ""], "8ArBqJwU8M0": ["NTA"], "iw4BEqvvgiw": ["Eric Grimson: We started this lecture by arguing that finding efficient algorithms on our own can be hard and we want, if we can, reduce problems to things that somebody else has developed that are efficient", " And we've just seen a nice example of that, because what we've just seen is that if we combine the idea of binary search with the idea of a divide and conquer for doing merge sort, that that actually gives us a very efficient searching algorithm", " In this case in particular, if we want to search a list k times then the efficiency is n*log(n) in order to do the sorting, plus k*log(n) in order to do the search k times", " And that, remember, we're comparing against something that is k * n", " And so that says boy, we're likely to be doing much better", " And if n is of any reasonable size, then the n*log(n) times k*log(n) is likely to be much smaller than just k * n", " This still leaves the question of can we do better? This is cool, but can we actually do better? And the answer is yes, and here we're just going to briefly highlight it", " We're not going to talk a lot about this, but we want to point it out", " Because, in fact, Python comes with a data structure that supports very efficient searching, and that's the dictionary", " You may have wondered about this, because dictionaries are arbitrary collections of objects, and yet we can get things out very quickly from them", " And the reason we can is that dictionaries use something called hashing", " And a hash function is something that says that we can do a look-up in an amount of time that's almost independent of the size of the dictionary-- almost", " But for most purposes, we can really think of it as saying we can do something that is really efficient, independent of the size of the dictionary", " So let's just briefly talk then about what's hashing", " The idea of hashing is the following", " Given a key, that key into an element of a dictionary, for example", " A hash function converts that key into an integer and it then uses this integer to index into a list", " That can, of course, be done in constant time", " All right, so it says basically when I've got a dictionary I'm using that, if you like, sort of notion of indirection in a more complicated way", " The elements are stored in a list", " But to figure out where in the list to put them, I'm going to use this hash function to say given the key, here's the location to go to", " Now conversion's done with this thing we call the hash function", " And the idea of a hash function is it's going to map a large space of inputs to a much smaller space of outputs", " Because it's doing this, it could in principle be a many-to-one mapping", " What that means is it says ideally we'd like each input, each key, to go to a unique place in the output space into the list", " But it's possible that two different keys could go to the same location in the list", " When we do, we've got what we call a collision there", " And there we're going to have to store, in fact, a little smaller sub-list with each of those elements there together with their key", " So that when I do the hashing, I will go to that location in the list, pull out that sub-list, and do the search", " Now again, if I make the size of the hash table huge I can reduce the number of collisions, but of course, that chews up a lot of space", " If I'm not clever about the hash function, I could have everything go to one space in the hash table", " In which case I'll have the entire set of things there in the list and I've lost because I still have linear search", " So what it comes down to is-- and this is sometimes hard to do-- we'd like to have a really good hash function", " And a really good hash function has a uniform distribution-- it minimizes the probability of a collision", " With that idea that I'm going to hash by computing some function on the key that's going to tell me where on the list to go to", " And I've got to make the list large enough that I can store most of the elements in there-- but not too large", " One of the questions is, just sort of intuitively, how good is hashing? Well, if there are no collisions, then this is O(1)", " Now, that also assumes that the computation of the hash function can be done very efficiently, but let's assume that", " It basically says given an element, a key, I do the computation, I go straight to that point in the list, I pull it out", " And if there are no collisions, only that element's at that location in the list, I'm in great shape", " Flip it, of course, is if everything is hashed to the same bucket, then I'm stuck", " Because now I've got O(n) because I've got to then search through that list linearly to find the element I'm looking for", " But in general, I could get something you could see could be very efficient", " I can trade off space", " How much memory do I use to make the hash table large? And then if I've got a good function, I can get close to uniform distribution which reduces the complexity to something close to O(1)", " If in fact my hash table's big enough that it's likely that only one element gets hashed in a location, I'm at O(1)", " Even if it's not quite that, it's still pretty close because I'm not searching through a huge list there, I'm looking at one or two elements to find them", " And so in fact what this says is there are even more efficient ways of doing search", " It relies on finding really good hash functions", " Python does that for dictionaries", " And what we'll see as we move through the term is that there are other places in which we can use this idea of hashing to give us even better complexity", " But nonetheless, the point of this was to say if I can take key ideas, binary search, divide and conquer, I can use those ideas to create very efficient algorithms, and in this case we did it for searching", " And the second thing we've seen is that while the complexity of a single use of a procedure may be more than we'd like, we can sometimes amortize the cost", " Say, if we're going to search multiple times through something, the cost to do the sort is actually worthwhile because it gets made up by the improvement in efficiency of actually doing a search", " And we'll see those ideas as we move through the term", ""], "dEgc80Stfv8": ["NTA"], "Gt8RHv3oTSA": ["CHRIS TERMAN: Finally, let's talk about exceptions", " Exceptions are an important feature of many programming languages that allow the program to signal when it can't proceed and get the correct answer", " There's something wrong with the data that it's manipulating", " It's detected an error condition", " In Python, you can not only raise exceptions, but you can handle them", " You can wrap a particular piece of code up in such a way that any exception that is generated transfers control to special code that you've written to deal with the exception", " That's a pretty handy feature, as you'll see", " Our Python programs have been dealing with exceptions for a while now", " Let's talk in detail about how that works", " So the basic question we have is, what should we do when our procedure has to stop execution because there's some sort of error condition? We have three choices available to us", " One is we can fail silently", " We can substitute in the appropriate default values and continue execution", " And the advantage of that is that the program never fails", " I always get some answer back", " But basically that's a really bad idea", " The user gets an answer", " That's OK", " But they get also get no indication that the result that they got may be suspect because of some error condition and the substitution of default values", " So in general, that's not the way we should go", " A slightly more tasteful approach is to return a special error value", " For example, if I had a procedure that was expecting to produce a number, I could instead produce the Python object None to indicate that no number was available, that some error happened and here's my indication, a special return value", " It can sometimes be a challenge to figure out what special return value is distinguished from all the other possible return values", " But assuming you solve that problem, there's a bigger issue, because if I have a procedure that can return one of these special values, then whenever I call that procedure, I have to include code in my own body which has to check for the special value and then deal with whatever the consequences are", " And maybe what I have to do is say, well, I don't know what to do with it", " It must be an error that I'll give to my caller", " So I generate my own special value, whatever that is, and return that to my caller", " And so what happens is that all the procedure calls get surrounded by special \"if\" tests to check the results and deal with any error conditions reported in this way", " So it really complicates the program", " Instead of this very simple program of nested procedure calls, I end up with a lot of code that is checking for special case values", " So it gets the job done, but it's really a burden on the programmer", " Happily, Python provides us a tasteful alternative", " We can raise an exception", " So this is a condition that will basically propagate up through all the nested procedure calls", " And each procedure call will have a chance to deal with the exception", " If none of the nested procedure calls deals with the exception that was created, then in fact the Python interpreter will do the right thing and create this nice little error message to the user, giving a backtrace, showing exactly where we were in the execution of the program and print out this descriptive string", " So the way we actually create an Exception inside Python is we use the raise keyword followed by the creation of whatever type of Exception we're trying to raise", " In this case, just a generic Exception", " And all the Exceptions here take as their argument a descriptive string", " If we wish, we can provide handlers for Exceptions", " So for example, if I'm going to do an operation which might create an Exception and I'm willing to deal with that, what I can do is embed those statements inside of the body of a try statement, followed by some code that will deal with the exception", " So the way this works is that as I'm executing statements in the body of the try, if any one of them throws an Exception, Python will look in the list of exception handlers to see if one of them will actually deal with it", " In this case, I'm willing to deal with any possible exception", " And so any exception that happens in the body of this code will result in the execution of this Python statement", " So just to summarize, exceptions inside the body of the try will then cause Python to look through the exception handlers listed after the try statement, and whichever one matches first, it will then start executing statements from the body of the exception handler", " In this particular case, what can happen is that the open statement can discover the file doesn't exist and create an I/O error exception", " What happens is that I want to catch that exception in my code, and instead of getting some sort of obscure I/O error, I turn it into a generic exception with a more sensible error message saying, can't open grades file", " If you'd like to see more about how try and except works, you can look in Section 8 of the Python tutorial", " So usually a handler is only meant to deal with a particular type of exception", " And sometimes we need to deal with cleanup actions before continuing", " So in this case, I've refined my example a little bit further to say, look, I have an I/O error here", " I want to deal with the fact that, if this open fails, I know the type of error I'm going to get", " I'm going to get an I/O error", " And in that case, I'm going to print out a very specific error message and cease execution of my program", " And what I've done is I say, look, I can't open the grades file", " And I've also captured the actual exception object that was created by whatever the low-level exception was, and I report that as well as my generic error message", " Separately, there may be some arithmetic calculations on the errors later on, and I can catch those and print out another informative error message, in this case saying, oh, there was a bug in the grade calculation", " So this differs, because it's a much more nuanced handling of errors", " I'm distinguishing I/O errors that come from the open statement from arithmetic errors that come from the code that's processing the grades", " And I can have as many different except statements as I want, dealing with the different types of errors that I expect to get", " We've seen a lot of the common errors", " You get syntax errors", " That's when your Python can't parse a program", " A name error, when local or global name can't be found", " An attribute error, which is when we have an attribute reference that fails", " We've asked for an attribute of an object that doesn't exist", " We get a type error", " That's when the operand doesn't have a correct type", " So I'm asking to add a string and a number together", " And the plus operator doesn't know how to do that, so it's an illegal type of operand", " A value error, in which the operand types are OK, but the value is illegal", " For instance, division by zero", " I mean, zero's a perfectly good number, so it's in general a legal operand to divide", " It's just that it's particular value of zero in the denominator causes us to say, aha, we can't do this particular division", " And we just talked about I/O error", " And if you want to see a list of all the different kinds of errors and what they mean, you can look in Section 6 of The Python Standard Library", " There's a couple other handy extensions to try", " We've talked about the except statements that can follow try", " We can also have an else clause after a try statement", " And this will be executed when the execution of the associated try body completes with no exceptions", " So this is what we would do if the try body completes successfully", " And finally, there's the finally clause", " So this is a clause that's always executed after the try statement and all the else statements and except clauses that apply", " And even when one of these clauses-- either the try or the else clause or the except clauses, which might be inside a loop of some sort, or inside a procedure call-- they may have executed a break or a continue or a return", " That's fine", " They're allowed to do that", " But before we actually finish the execution of this particular try statement and all of its clauses, the body of the finally will be run", " So we often put in cleanup code there that should be run-- for example, closing any open files that we created-- no matter what else happens, errors or not", " To see how this works, let's look at a little example", " I've created a divide routine which is going to attempt to divide the two operands and return the result", " So because that may fail-- particularly if y is 0-- what I'm going to do is embed the operation that I know might raise an exception inside a try statement", " And then, in the case of a division by zero detected by the low-level Python divide routine, I'm going to print out-- division by zero is the message I return", " Otherwise, if I successfully complete the divide operation, I'm going to print out what the answer is", " And finally, in either case, I'm going to hopefully execute this finally clause", " So let's see how this works", " So I'm going to go off and say divide of 2 and 1", " So in this case, because there were no errors, this thing completed successfully", " We actually put a legitimate value into the divide local variable", " And after the completion of the try statement, since there were no exceptions, we executed the else clause, which basically says, print out this answer and return", " So result is 2, is what it printed out", " And then after I finish the else clause, this will be executed here", " And we can see we actually executed the body of the finally clause, which printed out the executing finally clause statement", " Now let's do a divide that will cause an exception", " So in this case, execution of the body did not complete successfully", " It raised a zero division error, which I actually have a handler for", " So when the body of the try raised an error, Python looked down my clauses following the try and discovered that I declared an exception handler for the zero division error, which prints out division by zero", " So it does that", " It's now done with the try, and it's going to return, but before doing so, it once again executes the finally statement", " So finally gets executed whether or not there was an exception", " Now let's try one final experiment", " Let's try some operations that we would assume will raise a type error", " And in fact, we do get a type error like so", " And since that error is not caught anywhere, it actually will percolate all the way up to the Python interpreter, and we get the standard error result where we get a little traceback of where we were, followed by the little descriptive string that was part of the creation of the type error object that we created, which was a description of what the problem was", " But notice, before we got the traceback, even though we had no exception handler, so we weren't going to do any except clauses-- and since it didn't compete successfully, we weren't going to do the else clause-- we still nonetheless executed the finally clause and printed out our message", ""], "jq7Sujh5uDA": ["using guess-and-check methods to find answers to things", " But we want to take a slight to detour", " We'd like to use guess and check but not just for integers value, not just finding cube roots of integers", " We might like to try and find them for other values", " But to do that, we have to think about using floating point numbers or float", " And to do that, we also then need to take a little bit of a detour to understand how floats are represented inside of the computer", " So bear with me for just a little bit", " We're going to talk about floating point representations and then bring that back to see how we can still use those ideas to find approximation algorithms to get solutions using guess-and-check methods", " So floats approximate real numbers, but how do they actually do this? And let's think for a second though, what is a decimal number, the kind of number we normally deal with? Well, 302 is really 3 * 10^2 + 0 * 10^1 + 2 * 10^0 which of course is just 1", " So it's 3 * 100 + 0 * 10 + 2 * 1", " That's because we're using base 10, handy because we got 10 fingers and 10 toes is an easy way to do counting", " Computers, not having fingers or toes, do things a little differently", " They represent things in terms of binary numbers or powers of 2, basically because in electronics it's easy to have a switch either be on or off, have a 0 or a 1", " So a binary number will be a sequence of 1's and 0's that has the same form", " So the binary number 1, 0, 0, 1, 1 is the same as 1 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0, which of course is 1", " So if we wanted to convert it to decimal, that's basically 16 + 2 + 1 is equal to 19", " So decimals, base 10, binary numbers, base 2", " Internally, the computer represents numbers in binary form", " So one of the things we'd like to figure out is so how does it actually get to that kind of a stage", " So let's look at that", " What does it mean to think about converting a decimal that we type in into a binary form? How does the computer convert it into a form it can use? And then how are we going to think about that? Well, let's take an example", " Suppose we give the computer some number", " We'll call it x", " And it turns out x is actually 1, 0, 0, 1, 1 in binary", " But we don't know that", " We want to figure that out", " Well, knowing that it has some form like that, what could we do? The first thing we can do is if we take the remainder of x with respect to 2", " What does that say? Well, that's says if we're going to divide each of these elements by 2 since x is this sum, we can divide that by 2 evenly", " We can divide that by 2 evenly, that by 2 evenly, that by 2 evenly", " But this only cannot", " So when we do that, the remainder that's left is whatever that bit is", " And that gives us the last binary bit, which is a 1", " That's cool", " So taking the remainder back with respect to 2 gives us the lowest order bit", " If we then divide x by 2, what we really do is we just shift the bits left", " You see that if we divide x by 2 that's going to change that to a 3, that to a 2, that to a 1, that to a 0", " This goes away because remember we lose it", " And what we've done, oh, just get exactly that form", " We've shifted all the bits left by 1", " And we can now do the same thing", " If we take this new value and get the remainder of that with respect to 2, it's going to give me that, which gives me a second 1", " And then shifting left will reduce that to 1, that to 0, then I'll keep going", " And that will allow me to successively peel off each of the bits in order", " So we can convert any decimal number into a binary form", " Here's a little piece of code to do it", " Let's just walk through it very quickly", " This part up here I'm just going to let you look at it, but it's pretty straightforward", " It's basically saying if the number I'm trying to convert is negative I'm going to take the absolute value, but I'll keep track of that so I can put the negative sign back out in front when I'm done", " And then what does this piece in here do? Well, it basically walks through what I just said", " It says I'm going to set result initially to be an empty string", " I'm going to gather up the bits", " And then if the number is 0, I just return 0", " Otherwise, oh, there is one of those little iterative loops", " It essentially says, let me strip off the bottom order bit, put it onto the result", " There's a concatenation of the string, puts it to the left of whatever I've already gotten", " Change number by dividing by 2, which shifts the bits left", " And keep going", " So this is getting me the next bit", " This is just shifting left", " And I do that, OK, until I get a number that's less than 2", " And when I do, I'm done", " result holds the thing I want", " And all I need to do is just put a negative sign out in front if in fact what I started with was something negative", " So this is just doing a conversion back", " Cool", " Let's take a check of this", " See what it does", " So here in IDLE, I've got an example of that", " I've set a number to be 302", " And let's look at what happens if I do that conversion", " I type it in", " Huh", " Nothing showed up", " That's right", " Because I didn't ask it to print anything out", " But I know that result now holds the value I want", " And it says as a string there is 302 in decimal converted into a binary form", " I could change to something else", " Make it 256", " And do the same thing", " Save it away", " And again, I need to see where the result is", " I can do that over here", " And go back down to where it was", " Here is the result", " And since I know 256 is a power of 2, that form looks roughly right", " So what are we doing? Given a decimal number, we can convert it into binary form", " And that's literally what the machine will do inside", " Now let's think about what this says", " First of all, I want to be able to get good approximations to things", " So what about fractions? Why don't we deal with a fraction? Well, let's think about a number like 3/8", " In binary, it would be 0", "375, which would be 3 * 10^-1, or 1/10, + 2 * 1/100 + 5 * 1/1,000", " So it has the same form", " Now how could we figure out how to convert this into binary? Well, suppose we could find a power of 2 big enough so that when we multiplied it by this fraction it turned it into a whole number? If we can do that, then we could take the whole number, convert it into binary using the method we just had, and then when we're done divide by the same power of 2", " It's just going to shift to the right", " So, for example, 0", "375 we kind of know this", " We multiply it by 8", " It gives me 3", " That's in decimal form", " I could convert 3 to binary form, which we know is just 0, 1, 1", " And now that I've got that, I could just divide by 8, which is equivalent to shifting the binary point, if you like, three slots over to get 0", "011", " Cool", " Let's do that", " Here's my code", " And it's really got almost exactly the same form", " It's a little bit more than we had before, but let's just look at it", " I've got something up here that's just going to input an x so I'm not having to type new values in", " And here's a little iterative loop that simply looks for the power of 2 that converts it into a whole number", " So it's just going to loop over p, looking for a value of p such that 2^p * x is a whole number", " Its remainder with respect 1 is equal to 0", " Cool little check", " I'll just do that", " Once I can do that, then I'll take x and I'll multiply it by 2^p", " I've converted it now into a whole number", " And there, I just did what I did before, simply run through that test to see how do I convert it back into a binary form", " And once I'm done, then the last piece is I need to make sure I put enough zeroes out front by looking at how many values are there between the size of p and the length of the result", " And then having done that, I just need to find the right place to put the decimal point", " And there's a funky little piece of code that is basically finding the spot in between p where we want to do it", " We'll let you look at the details of it", " But that's basically what this code does, finds the power of p to make it a whole number, does the conversion, and then converts it back", " OK", " So let's see what we got here", " Go over to my IDLE", " And I've got a piece of code that captures that", " All right", " There's the piece of code right there", " And let's run it and see what happens", " I'm going to run that piece of code", " It says give me a decimal number", " In this case between 0 and 1 because that's where I'm going to deal with it", " Well, let's try 0", "375", " Ahh", " Runs through three steps to get the remainders, and it converts it into that binary form which we saw before, 0", "011", " Sounds cool", " Let's try it again", " We enter this-- oh, I don't know, something simple, 0", "1", " Ohh, it's working away here", " And it's working away really hard trying to find something", " And it says, my goodness, the binary representation of the decimal 0", "1 is-- ohh, look at that-- 0", "0001100110011001", " Well, you get the idea", " It's really boring and repetitive", " Ha", " So what happened here? That's a little different", " We didn't get some nice, crisp, clean form", " And in fact that's going to be an important factor when we think about binary numbers and decimal numbers and especially fractions", " So what's one of the implications? If there is no integer p such that x * 2^p is a whole number, then the internal representation is always going to be an approximation", " And in fact what happened here was that the Python system eventually stopped trying to expand it out any further and simply gave us a representation out to some arbitrary number of bits that are set by the internals of the Python system", " So if it's not something that can be turned into a whole number by a power of p, it's always going to be an approximation", " This has an important implication", " It says, when I want to test two floats to see if they're the same I shouldn't use something like this because it might not be true because the approximations may be slightly different", " I'm always better basically saying, is the absolute difference between them smaller than some arbitrary amount", " And we're going to use that a lot", " This is a standard place where people get into trouble by trying to test the quality of two floats and then being surprised when in fact the code doesn't do what they'd like", " One of the things you could ask is, so why does print of 0", "1 give us back 0", "1 if in fact 0", "1 is represented as this long, funky kind of thing? And the answer is because the designers of Python decided to set it up this way, that it automatically rounds to some number of bits in order to give something that's much crisper", " But in fact 0", "1 is not represented as 0", "1 inside of the machine", " That's going to be important now as we think about taking this idea of iterative algorithms, especially guess-and-check algorithms, but dealing with floating point numbers", ""], "oJa01jCfTCU": ["We've seen giving names to those", " We've seen how we can combine those together using names and places where we would use values", " We can start doing some simple computations", " But those are all dealing with scalar objects, numbers", " Let's talk briefly about other kinds of objects", " We'll come back to them later on, but we want to see what we can do here", " So non-scalar objects are compound things, things whose proportions or components we can get at", " We'll see a lot of these throughout the course of this subject, but the simplest one to start with are what are called strings, or objects that have a type str for string", " And these are literally just sequences of characters that are all concatenated together", " So how do we write them? Well literals of this type can be written either by putting them inside of a single quote or putting them inside of double quotes", " And so if I go to my Python shell, for example, we can see that we can put things within a single quote", " And that gives us that string back", " By the way, we can give names to those things", " So we can say, what's the value of foo, and, in fact, we can look at the type and we'll see that it gives us back something of type string or str", " And, by the way, we can also put quotes around numbers", " So this is a string", " And just to see that, let's ask for the type of that", " The type of that sequence of characters, numeral one, numeral two, numeral three, inside of the quotes is a string", " And that is different than the type of the number itself which is in int", " So we can put together strings", " If we can put them together we'd like to be able to do things with them", " And I want to show you some examples of those", " So we can provide different operations on strings", " Now some of these maybe a little surprising", " So let's walk through them", " The first one is we can ask for taking the string a and multiplying it by the number three", " And that may sound strange", " But what it gives us is a string with three copies of a's stuck together", " Or, if you like, I could do it with a slightly more complicated string", " And it literally is just concatenating or copying those versions of those strings together", " We can put two strings together using addition to give us this concatenated string of a and b", " And we can, of course, also concatenate together strings if we want to make sure that they are converted into strings", " So we can take a number, convert it to a string and concatenate that together gives us the string a123", " These are just different ways of dealing with strings and putting them together", " It seems a little odd that we're using operators that don't normally deal with numbers", " And this is an instance of what we call operator overloading", " In which what we are doing here, here, here, is we are using the same operator to do different things", " If we give them numbers it'll do one thing", " If we give them a number and a string in the case of multiplication it will do something different", " If we give them two strings it will do something different", " So we're letting the operator use the type of the object to decide what the right operation is to do", " The last one we show here is that given we say we now have a non-scalar object we need to know how many portions are there inside of it", " And for that there's a built-in Python function called len for length", " And if I want to ask for the length of a particular string it gives me back that answer", " So I now have compound objects that I can do things with", " Well obviously one of the things I'd like to do is not just put them together", " I'd like to get parts out of them", " So that leads to the interesting question of how do I get out elements of a compound object like a string", " And here I want to show two examples", " The first one is we can do what's called the indexing", " And let me show you an instance of this", " If I give the string 'abc'", " Notice the single quotes around it so that is a string", " And in square brackets are braces after it I give it an integer, like 0, it's going to give me out the element of the string corresponding to that index", " Now how does it do this? Well it starts-- well, if you want to think of it this way of counting from 0", " So there's the string", " The zeroth element is that one", " And it will return that value", " Similarly if I say from the string 'abc' give me the second element it starts at 0,1,2 there's the second element", " And it returns that string", " Now you have to be careful", " If I ask for the third element", " Remember, I start counting at 0", " There's 0, 1, 2", " The third element, oh, there isn't one", " And we get out an error", " And we can seen this over here", " If I, for example, just type it into Python", " I can say give me the string 'abc", "' And I'll take, in this case, the first element", " And that will give me b", " Because I start at 0 and go to 1", " Now I can also though go backwards", " So if I have a string 'abc' and I give it in square brackets or braces a negative number, it basically starts at 0 and then counts backwards to minus 1 and then to minus 2", " So that minus 1 index will return as the c", " So it basically starts at the back end and counts backward", " So we get out components of strings which is good", " Now sometimes we'll want to get out not just a single element, we'll want to get out a substring of a string", " And for that we have a technique called slicing", " So we have a string called s, then this expression here where we have two expressions, a start and an end that are both integers or their values are integers that denotes the substring that starts at the index pointed to by start and stops just before the index pointed to by end", " So just to see that", " If I again take my string 'abc' and I say give me everything starting at one and stopping before the third index it returns for me the string bc", " We're going to come back to doing things with strings later on, but we wanted to let you see that given compound or non-scalar objects like strings, not only can we combine together but we can also get out pieces of them", " Either individual elements or subcomponents of them", " And we'll use that as we start doing more interesting"], "kB6-nallVQ4": ["If you want to have a persistent and organized reference, collaboratively collected and edited by the students of your course, you can use the edX wiki", " You can create a new article by linking to it from an existing article and then clicking on the link", " You can also create an article from the generic children listing", " However, your fellow students are more likely to see articles that are linked to from other articles, because that linking allows you readers to see how your information is relevant to what they are already interested in and reading about, making them more likely to be interested in the information that you are putting together", " The edX Wiki Editing Guide contains the most up-to-date details on how to add formatting for standard text, math, schematics, tables, code, and any other new"], "0b0bWcbQmFk": ["NTA"], "Q91AWYjf04I": ["NTA"], "49xW1lvvUtQ": ["NTA"], "l8Hw2V1tXmc": ["We're going to talk about partitioning up the space of inputs to create a good test suite, a set of examples we're going to use to try to decide whether or not our code is bug free", " First tool we have is what we call black-box testing", " And black-box refers to the fact that it's just a box covered in black so we can't see inside of it", " So here the test suite is designed without actually looking at the code", " Nice thing about this is it can be done by someone other than the implementer", " So we could have quality assurance group that is actually going to design the test suite here", " And one of the nice advantages there is that that often can help us avoid inherent biases", " As an implementer, when I design code, I may be assuming that I'm always going to run this on positive values, for example", " But if I don't build that into the specification and I don't build in checks for that, somebody else may come along and try it on a negative value and expose the fact that I have a bug inside of my code", " So that lack of bias, that lack of implicit bias is actually a great plus", " Another thing that's nice is that the testing is designed without knowledge of the implementation", " Since it's built just on looking at the specifications for the problem-- I don't know how it's actually encoded-- that means that that same test suite can be reused, even if I change the implementation", " And that's actually nice, that sort of separation of the details of the implementation from the use of the implementation", " That abstraction is an important part of how we build modules", " And testing should take advantage of that", " And, indeed, black-box testing will", " All right, now let's look at what does it mean to do some black-box testing", " So let's think about a specification", " Here's a piece of code", " And again, here I'm actually just showing you the spec", " I don't know the details of it", " It's a square root", " And it says sqrt takes in two values, x and epsilon", " And it assumes they're both floats, that x is greater than or equal to 0, epsilon is greater than 0, and it's going to return a result with a particular condition on the end", " OK, what are the paths through the specification? Well if I look at this spec, I can see that x-- there are two conditions, basically", " I can separate out when x is equal to 0 from where x is greater than 0", " And I could, in principle, just create two test cases, one for each one of those", " But I kind of know that's not enough", " So the spec itself is simply giving me a first pass of how I might try and test it", " But I might want to think about other places in which I want to refine that idea", " OK what does that mean? Well, let's think about this", " It's often good not only when I'm thinking about paths through the specification to think about just the possible paths, but to think about the boundary cases", " As an aside, if I have an input that's a list, what are the boundary cases we might want to think about here? Well the list could be empty", " The list could have one element", " Or the list could have many elements", " Difference between 2, 3, 4-- probably not as crucial", " But the difference between 0, 1, and many-- that's a nice set of boundary conditions to think about", " For numbers, we can do similar things", " It's not just is it 0 or positive", " It's also what happens if the number's very small? What happens if the number's very large? And what happens in the typical case? And I'm going to put quotes around typical, because I'm going to have to think about different variations, what it means to be typical, based on the specifications of the problem", " So if we go back to my square root example, we can actually think about this then", " What might be good test cases to use here? Well I've put a little table together here", " And these first four are what I would think of as typical cases", " OK? Notice in all cases I'm using epsilon to be pretty small because I want to get answers that are close to the right answer", " That was part of that specification-- that the difference between the actual value and the value I guessed at should be very close to what I want", " And then notice what I've got", " I've got, from the spec, the case of 0 and then the case of positive things", " And I've picked out other things", " I've picked out a perfect square", " I've picked out a square whose root is irrational", " And I've picked out one where the input is less than 1 because I know for numbers, and especially for square roots, there's often a difference between fractions and numbers bigger than 1", " I've selected four good typical examples", " The second thing I've done is I've looked at some examples that are a little bit different", " And the first one, right here, is one where I'm still taking a simple example", " But I'm taking a very small epsilon", " That is likely to stretch my code", " What happens if I have something that is really, really small? OK? And then I'm looking at examples where I'm either taking really large or really small values, both for x and for epsilon", " And I'm trying those out", " So that's into that very small, very large, as opposed to the typical case", " Now in these last five extremes here, if I, in fact, find a bug, one of the things that will be interesting is that the bug might be inside the code", " Or it might be in the spec", " For example, don't try and find a root if epsilon is really tiny", " But it'll at least expose do I have a problem or not", " So there's a partition", " This right here is a nice partition of the input space", " And it has both typical examples and boundary case examples", " And that is a nice example, just based on black-box testing of looking at what is the specification, what might I do", ""], "waIE0L9vfiI": ["ERIC GRIMSON: In the last section, we introduced a couple concepts in terms of writing programs or scripts", " We had straight-line programs, where we had just a linear sequence of instructions and we executed them 1 at a time in order", " And we added the idea of branching, or conditionals, where we could do a test, and depending on whether that test was true or false, we might skip to 1 piece of code or a different piece of code", " But in both cases, we're doing each instruction at most once", " Useful, but not great", " To get to the ability to write programs or scripts with arbitrary complexity, we need 1 more key concept, and that concept is the idea of being able to reuse a piece of code an arbitrary number of times", " We might have a set of things we want to do once or depending on some value, twice, or depending on some value, 27 times or 1,000 times", " And rather than having to copy the code that many times, we'd like to be able to have the computer automatically reuse the code as many times as desired", " That notion of iteration is going to be incredibly valuable, and we're going to talk about some constructs to help us make that happen", " The basic idea, though, is straightforward", " Given that we have some code we're executing, when we get to an iteration loop, which is this chunk right here, we start with a test", " That will be Boolean that will return either True or False", " If it's True, we're going to go down and execute some set of instructions, the body of the loop, and then go back around and do the test again", " And we'll keep doing that", " As long as the test is True, we'll execute that same set of instructions in the body over, and over, and over, until finally, the test is False, in which case we skip around the loop body and pick up the computation elsewhere", " This notice allows me, based on this Boolean test, to be able to do the code some arbitrary number of times, and that's really great", " Let's look at an example", " Here's a simple example that shows that idea, and I want to talk about the syntax of the construct, but also about what the example's going to do", " This is a simple piece of code that squares a number", " I want to get x squared, but I'm going to do a by just successively adding x to itself x times, which is of course what x squared actually does", " I add x copies together", " Notice what we've got", " We're going to set up some value of x", " I'm going to do a binding there", " We're going to bind a variable ans for answer, which is where we're going to add up all the instances of x to get where we want to be", " And we're going to need to keep track of how many versions of x do we still have to add in", " So we're going to set up another variable called itersLeft, initially bound to x", " The looping construct, the iteration construct, we have is called a while loop", " And there's the key word while, and it has the following property", " It has a Boolean test-- in this case, we're checking to see whether itersLeft is equal to 0 or not-- followed by a colon, and then it has a set of indented instructions, which of course, are the body of the loop", " The way the while loop works is it first tests that Boolean", " If that Boolean is True, itersLeft is not equal to 0 in this case, it will then execute each of the instructions in the body in sequence", " And when it gets to the end of that sequence of instructions, it's going to go back up and retest the Boolean again", " So it will cycle through this code multiple times until that Boolean is finally False", " When it is False, it will skip down to the end of the loop, which is shown by where the indentation stops, and pick up the new set of instructions and continue", " So there's the structure, let's see if this does the right thing", " Well, here's my code, and let's just walk through this", " We won't run it on idle, we'll just walk through it", " Initially, x is bound to 3, ans is bound to 0, and itersLeft is bound to 3", " The while loop says, test to see if this is equal to 0", " Since it is not equal to 0, the test is True, and therefore, I take the current value of ans, the current value of x, add them together, and rebind that to ans", " I then take itersLeft, subtract one from it, and rebind that to itersLeft", " So I've decremented itersLeft, and I've incremented ans", " I go back up, and again, I check", " Is that not equal to 0? It is not equal to 0", " Therefore, I take ans and I take x, I add them together, and I rebind those to be the new value of ans", " I change itersLeft by 1", " That's my new value there", " And again, I go back through the loop", " That is not equal to 0", " Well, the test is still True, so again, I take ans, I take x, add them together, create that to be my new binding for ans, which is 9", " I take itersLeft, subtract 1 from it, there's my new value of itersLeft", " And again, I go back to the top of the loop", " At this point, 0 being not equal to 0 is False", " Terrible way of saying it, but that test is no longer True", " It's False", " In which case, I will skip to the end of this loop, and print out that x * x, or if you like, 3 * 3, is equal to 9", " Cool", " A little slow, but it does what I want", " Notice I have reused this code an arbitrary number times", " And in fact, if I were to change x to be something else, I will reuse that piece of code a different number of times", " There's my iteration that I really want", " You can also see some properties of an iterative loop", " First of all, we need to set an iteration variable outside of the loop", " In this case, it's x and itersLeft", " Actually, the one I really care about here is itersLeft", " I also need to test that variable to determine when I'm done", " There's the use of itersLeft inside of the test", " Now, it could be a simple test, it could be a more compound test, but that's basically what I need to test", " And finally, I need to be changing that variable inside of the loop, right there", " If I didn't, then that test value would never change, which means I would never stop the loop", " But there's a property I need", " When I set up an iterative loop, I need to say what's the variable I'm setting outside, how am I testing it, and am I making sure to change it somehow inside of the loop in order to ensure that I get the pieces that I want", " So what do we have now? Well, that's a really valuable construct", " We already saw that branching structures, things like conditionals, will let us jump to different pieces of code based on a test", " Once we add in the idea of looping over the code, things like a while loop, that allows us to repeat pieces of code until the condition is satisfied", " So it's a generalization of a conditional", " On simple branching structures, we've already said that programs like that are constant time, that is, we execute each instruction at most, once", " With looping structures, notice that things are different", " Now, the program is going to take an amount of time that depends on values of variables as well as the amount of code or the number of instructions inside the loop, because it's going to depend how many times we walk through the loop, and that depends on the variable", " Nonetheless, these loops are going to be really valuable, and we're going to turn to that next", ""], "Vt6MxpUBz_k": ["ERIC GRIMSON: We've now added tuples, generalization of strengths, an ordered sequence of elements, where the elements can be any structure", " And we've already seen that a lot of the operations we wanted on strings, we're going to have on tuples", " We're going to add another kind of structure called a list", " And it looks a lot like tuples", " And again, lists are ordered sequences of values", " Each one's identified by an index, so it's going to support all the same kinds of operations I saw before", " The difference here is we're going to use these square brackets rather than the parentheses to distinguish a list or to create a list, as opposed to a tuple", " So they are a little different in terms of how they're going to look", " And as a consequence, and one nice thing, is that singletons are now pretty straightforward", " It's just a square bracket, the entry, and another square bracket", " I don't have to put that annoying comma in that I had to do with tuples in order to distinguish between an arithmetic expression and a tuple with just one element", " Looks much the same", " So what's the big deal? Well, there's one very big difference, and it's a really important one", " Which is that lists are mutable", " And what does that mean? It means we can change them", " What does that mean? Well, things like ints, floats, strings, and tuples are immutable", " And that means that we can't go in and change an element inside of them", " Now for ints and floats, that's obvious", " And tuples, we just introduced, so we sort of have to accept that on faith", " But if you think about strings, you can get elements of strings out-- you can slice into strings-- but you can't go in and directly change one character in a string", " They're not mutable", " They're immutable", " They don't change", " On the other hand, lists can be modified after they're created", " And why would we want to do that? Well, in part because there are going to be some problems where that's really valuable", " So what does that mean? Some data objects, we really want to treat as if fixed", " It says we create new versions of them, we combine variables to them, but we don't want to change them", " And this is usually valuable when those data objects are going to be frequently referenced, but where the pieces inside of them don't change", " Why would we want to support having ability to change them, because that could just lead to bugs? On the other hand, there's going to be some instances where the data objects may want to support modifications to elements inside of them", " Why might that happen? Imagine you've got a really large database of personnel information and you want to do things like change salaries", " You don't want to have to make an entirely new copy of the database just to add in a new salary", " You'd like to be able to go inside and change a piece of that", " So lists are going to support that kind of operation by enabling us to go in and mutate, or alter, elements of the pieces", " One issue to keep in mind is that, while mutable structures give us more flexibility, they also are more prone to programming errors", " If I've got two different pieces of code both pointing to the same list, and I have one piece of code change or mutate a portion of the list, I want to make sure that that other piece of code is aware of that", " If not, I can get myself into some really interesting bugs", " So there's a cost, but there's a bonus", " Let's look at an example of what this means", " So let's create a couple of lists", " And in fact, over here in my IDLE shell, I'm going to do that", " Let me just create a couple of lists", " And I'm going to call Techs as a name for a couple of great technical schools", " And notice the angle braces to get them for me", " And I'm going to create Ivys", " I'm not going to do all of them, but I will again create a list of some great schools", " We'll do Harvard", " We'll do Yale", " And we'll do Brown", " And if I print them out, I can say, what is the value of Techs? And it just gives me that list", " On my slide, I've given you a visualization of that", " So think of this as Techs and Ivys sitting up in that global environment", " After all, I just typed them into the shell for Python", " And what do they do? Well, they point to a structure in memory somewhere that has that sequence of elements inside of it", " As I've said, I can treat this as if they were just an order of sequences", " So I could say something like, what is the first element of the Ivys? Remember, we start indexing at 0, so that gives me back Yale, which is nice", " And I could slice if I wanted to", " I could say give me back the Ivys, everything up to the second one", " And that gives me the zeroth and first elements", " I can do things I'd expect to do on that", " Let's see what happens when we start putting things together", " So I've got two lists-- a list of tech schools", " I've got a list of Ivys", " Let's now create what looks like two different lists of universities", " So the first one, I'm going to call Univs, for universities", " And it's going to be a list of the Techs and the Ivys", " And I'm going to create what looks like the same thing", " I'm going to call it Univs1, and I'm simply going to re-create that sequence", " Cal Tech was the first one", " And since I'm creating a list of these lists, I'm going to put a comma in there, and then I'm going to do Harvard, Yale, and Brown", " Are these the same thing? Well, let's print them out", " If I look at Univs, yeah, nice", " It's a list of two elements, the first of which is a list of two elements", " Second of which is a list of three elements", " And if I look at Univs1, it looks exactly the same", " They certainly print the same", " So it is easy to think that these might, in fact, be the same thing", " But they're not", " And let me show how I can test that", " Let's evaluate the following little command up here", " An append is a method associated with lists", " We'll come back to methods later on", " That dot notation basically says, if I type in Techs, it's a list", " The dot says get the method append associated with it", " Don't worry what a method is, but basically think of it as a function that is going to take an argument-- in this case, a single element, RPI-- and it is going to attach that element to the end of the list text", " So, what does it do? It's an important thing here", " It doesn't create a new list", " It mutates the existing one", " It takes Techs as a list and changes it", " It mutates it to add a new element to the end, extending the list by one", " Now, as a consequence, if we print out Univs, notice we now have in that first element MIT, Cal Tech, and RPI", " We have changed what's inside of there", " We have mutated Techs, not Univs", " In fact, let's just check it", " Let's go look at Techs, and there's Techs", " But again, if I go back to Univs, there it is", " And now what happened to Univs1? Aha! It didn't change", " And that's an important point", " Look at the form of Univs1", " It has just the first two pieces to it", " And, in fact, if I go to the next slide, we've captured that", " If I print out Univs, I get out MIT, Cal Tech, RPI, followed by Harvard, Yale, Brown", " But for Univs1, I just get MIT, Cal Tech, and then Harvard, Yale, Brown", " Why? Well, this is where the mutability comes in", " So let's think carefully about what we had", " Before I did that append, I'd had a binding for Techs, and I had a binding for Ivys", " We created those", " They said we're lists", " And then what did I do? I said, let Univs equal-- and in fact, let me just write it out here-- I bound Univs to Techs and Ivys", " And what does that say? It says make a list", " So there's Univs", " It's going to make a list", " And it says the value of the first element is going to be the value of Techs", " So aha", " It's just a pointer to that list", " And the value of the second argument, or the second element, is just the value of Ivys", " So aha, it's just pointing to there", " So Univs is a list whose elements are just pointers to other lists", " On the other hand, what did I do when I created Univs1? If you look back, you'll see that, in fact, I created it by actually typing out lists", " I said Univs1-- just to say a little bit of it-- I said Univs1 was going to be, and then I said quote MIT, quote Cal Tech, comma", " And then I did a bunch of other things", " I'm not going to do all of it", " But this is telling Python, create a list with those strings inside of it", " So in fact, that's exactly what it did", " Univs1 is going to create a list, but it creates it with a new version", " Right there", " Notice Techs is not pointing to this", " There's a new version right there", " Ivys is not pointing to this because I created them and inserted them inside of this larger list", " That's important, because now when I did that append on Techs, what did it do? It went over here and changed that", " It added that into the end of it", " That means that Univs changes because it sees that", " But what about Univs1? This is a completely different list", " Nothing changed there", " Let's make some observations out of this", " The elements of Univs are not copies of the list to which Ivys and Techs are bound, but are the lists themselves", " I got the value of Techs, which pointed to the list", " And this effect is something we call aliasing", " Basically what does aliasing says? It says we have two distinct paths to a data object", " One is through the variable Techs, in this case", " There's a second one through the first element of the list object to which Univs is bound", " And one of the effects of that is that I can mutate an object through either path, but the effect will be visible to both", " And I just saw that back here when I mutated Techs, but Univs changed", " That sharing of data is really important", " And that mutation, that ability to change things, is really important", " This is very convenient, but it also can be really dangerous", " It can be treacherous", " Because if I had something that was changing Techs and I didn't realize that Univs inherited the Techs structure, I've now changed something inside of Univs", " And if you think back to the code I just typed in there, you saw nothing that said make a change to Univs", " But changing a part of it had that effect", " So aliasing is a valuable tool, but it is going to occasionally lead to some problems, and we have to be careful about it", " Now what else can we do? Well, we can certainly change elements directly", " So if I go back, for example, and I look at Techs", " Here's my list of tech schools, MIT, Cal Tech, RPI", " I might decide I want to change the list", " So I can literally say, change the second element of Techs", " And I do it just with an assignment statement", " I'm going to pick up WPI", " And now if I look at Techs, that element is changed", " I've mutated it", " By the way, if I go back and look at Univs, it has also changed", " I've now got WPI in the first portion of that element", " Just to remind you, it says I can mutate elements of this", " I cannot do the same things with tuples", " So if I do an example where I create a tuple-- we can look at temp", " But if I now say, and I could certainly get out, for example, the first element of temp", " But if I attempt to change that, as I just did above here by putting in something new, it's going to complain", " And it says you can't do it because these things are not things that can be mutated", " So now we've got lists", " Let's see what we can do with them", " As I just said, stressing it, I can't do that with tuples", ""], "tJMrTNDdsR8": ["SAM MADDEN: Hi, I'm Sam Madden", " I'm a professor at MIT in computer science", " I'm going to talk to you today about some work that I do on a research area called column-oriented databases", " I'm a specialist in building systems for storing very large amounts of data", " So, before I tell you about column-oriented databases, I need to explain a little bit about what a database is", " So, a database is simply a collection of records", " Much like in Python where you have an array, all a database does is represent something that's very much like an array", " Unlike an array in Python, however, a database is persistent", " It lives on disk, like a file", " And in addition to that, databases is often represent very, very large quantities of information", " Millions, billions, even trillions of these records", " So we're going to use a very boring example throughout this presentation to give you sort of an introduction to what a database system is", " This is an example of a record in a database system that stores some information about stock quotes", " So here we see a stock quote has a symbol, a price, a quantity, an exchange, and a date", " Databases take these records and they organize them typically into tables", " A table is simply a collection of these records stored together", " Databases then, for these tables, provide a language, a programming language like Python, for accessing these records", " Unlike Python, however, these languages that databases use are often called declarative", " They have a very sort of English-looking kind of flavor", " For example, this query that you see here selects the price of a given stock that has a set of properties from the symbol GM and with a certain date", " This particular query that you see here is written in a language called SQL, or the structured query language, which is the most commonly used language for querying databases", " So, databases are important because nearly every business, website, government, all these organizations store their persistent mission critical data inside of databases", " Databases provide a very powerful set of abstractions for keeping data safe, and storing it persistently on disk, and ensuring that certain consistency properties are preserved over it", " They also provide a way to evaluate these queries that we see here very efficiently", " What I'm going to talk about today and what column-oriented databases are about is providing a very efficient way to evaluate certain kinds of queries over data", " So, a database system is something that answers processes, these queries that are running on top of these databases", " So, the database system uses one of two basic ways to evaluate queries", " If you think about what you have to do to evaluate a query, you're going to have to find the records that satisfy these conditions", " For example, symbol equals GM, or date is equal to 1/17/2007", " So, in order to find the record to satisfy this, there's two things we could do", " One thing we could do is to use something we call an index", " An index is like a lot like a dictionary data structure in Python except for that it is persistent and lives on disk", " And what the index is going to allow us to do is to efficiently look up records that satisfy a certain criteria", " For example, we might build an index on the stock symbol, and then we could use that index in order to efficiently find all the records that correspond to a particular symbol", " So in this case, we could look up on the index for the symbol GM", " And we would see that, if this is our database, the first and fourth record in the database contain that symbol", " So, the other way that we might evaluate a query-- for example to find all the GM stock quotes-- would be to just iterate over all the records one by one", " And we call such an approach a scan", " So you might think that a scan is an incredibly inefficient way to access data, that you should always prefer to use an index", " It turns out that that's not the case", " Sometimes indices actually are a bad idea", " First of all, it's expensive to create them and maintain them, and second of all, these indices can actually be less efficient sometimes than scanning all the data", " And the reason for this is because the records that an index returns have to then go be accessed in the underlying table", " So in this case, we were told we need to go look at records one and four because they correspond to GM, but then we would have to go look through the underlying table and look up those records, and that actually can be slow, partly because these tables are stored on disk", " And we'll come back to a little bit about why storing things on disk sort of changes the considerations about performance in just a minute", " All right, so now it turns out that actually we want to use these scans for certain classes of queries", " In particular, for queries that access lots and lots of records we're going to want to use a scan", " Sometimes in the database world, these are called analytical queries", " They often look like this", " So this is very similar to the query we saw before, except for rather than the equality predicate, we now have a greater- than predicate", " And now we have this average price", " So this computes the average price of all the GM stocks over some date range", " If GM is a popular stock, which it probably is, there's going to be lots and lots of such records, and we're going to have to evaluate", " And it turns out that a scan is going to be probably the best way to evaluate this query", " So, it turns out that this market, these analytical queries, represent a multi-billion dollar business in the United States, because companies use these kind of queries in order to do analysis about what's going on inside of their business, to understand sales trends, to understand patterns of buying and selling", " All right", " What column-oriented databases are about is making these kinds of scan operations go faster", " So in order understand what makes a query slow or fast, let's try and think a little bit about how long we would expect a scan to take when we're running one of these queries", " Intuitively of course, the performance of one of these things is going to be proportional to the amount of data that we access in processing the query", " OK", " So if we go back to our simple query and our example database, the most natural way to think about this data being stored is sort of row- by- row, in the memory or on the disk of the computer system", " So in order to evaluate this query, what's going to happen is we're just going to, in a scan, just read each one of these records one by one", " OK", " There's something interesting to notice about this particular query though, which is that it actually only accessed three of the columns", " Three of these five columns that are in the table", " The price column, the symbol column, and the date column", " So, we only needed 3/5 of the data in order to evaluate this query", " So it turned out, however, that when the data's laid out in this way, row by row, there's a property of the disk that makes it so that we're going to have to read all of the data, all five columns, off disk even though we only need to access three of them", " So I'll just give you a quick little tutorial about how a disk works", " A disk a piece of physical hardware that has these spinning platters in it", " And these platters are spinning pretty fast, like several thousand RPM, revolutions per minute", " And each one of these platters has data laid out on it in this set of concentric rings, they're sometimes called cylinders", " And the data that's currently being read off of a given cylinder is the data that happens to be underneath this triangular- looking structure that you see here in the diagram", " The triangular structure is called a head", " So what happens is the disk is spinning around, and when data passes underneath the head, it's read off of the disk", " So if you think of a database table that's laid out in one of these cylinders, the record that's about to be read, you can see here, is denoted with these little X's", " When that record passes under the head, it will be read off of the disk", " So you can imagine that if the five columns of a given record are laid out sequentially in that cylinder, if we just want to read three of them-- they're randomly allocated throughout that record-- the whole record is going to pass underneath the head, even though we only needed to read 3/5 of the data", " And it turns out that this time to access this record and for the data to pass underneath the head is what really dominates how long it takes to access the data from disk", " So in this case, it turns out that when the data's laid out sequentially like this, the total time to evaluate this query is essentially going to be the total amount of time that it just takes to read all of the records, the entire table, from disk", " So you can see here, if our table consists of 1,000,000,000 records each of which is 100 bytes long, then we're going to have 100 gigabytes of data", " If the disk can read 100 megabytes a second, which is about what a disk can read, then it's going to take 1,000 seconds to evaluate this query", " OK", " What the column-oriented database does is a way to organize the data that's stored on disks differently so that we can evaluate queries much, much more quickly", " The column representation, instead of laying out data row- by- row, lays out data column- by- column", " So imagine each column of this table is now stored in a separate file on disk", " So now when we want to read these three columns, we only have to go access those three columns from disk and read them in", " And so rather than having to read all of the data, we only have to read 3/5 of the data", " So in this particular example, we could evaluate this query in 600 seconds", " Now, this may seem like it's not that significant of an improvement, but it turns out that in reality, these tables are often hundreds of columns wide", " People, when they build their databases, cram all sorts of junk into their table", " So the tables get really big", " But on the other hand, the queries themselves tend not to get really big", " The queries usually only access three or five attributes of these hundred attribute-wide tables", " And that means that this column-oriented representation can be much, much faster than the row-oriented representation", " So in addition, there's some other cool things about this column-oriented representation", " So in particular, columns compress really, really well, and that allows us to further reduce the amount of data that we have to access when we're processing a query", " So just to give you a very simple example, suppose we have a table that's sorted by stock symbol", " Now let's think about compressing just that column that represents the stock symbol data", " There's a very straightforward way to compress this data called run length encoding", " So imagine I have a table that contains the symbols AAPL, AAPL, AAPL, IBM, IBM", " These five attributes, stored in sorted order, can trivially be represented as AAPL times three, an AAPL and then a count, which is in this case three, followed by IBM an then a count, which is two", " So here it doesn't look like we've reduced the space very much, but if you think of a table of stock quotes, there's probably only a few hundred or thousand stock quotes in our database system", " And so even if our table contains billions of records, we can represent this column simply as a few thousand stock quotes and their counts, which is a dramatic reduction in space", " Notice, however, that we couldn't play this same trick for, say example, stock price, because stock price is a floating point number and there's likely to be millions of different stock prices in a given database system", " So one of the things we could do in this column-oriented approach is to compress each column using the best compression scheme for that column", " So at MIT, we built a new database system called C-Store around this column-oriented idea", " Turns out that, sort of surprisingly, almost every other database system in the commercial world built before us had used this row-oriented representation for data", " So C-Store was this fundamentally new way of building a database system", " We also added a bunch of other cool features to it, like the ability to parallelize processing and the placement of data across many nodes, the ability to support efficient loading of new data, and some special optimizations to allow queries that are only reading data to run concurrently and very efficiently with queries that are updating data", " If you like, there's a paper that you can go read for those of you who want more information", " To give you a sense of real world how much this matters, I'm going to show you a performance benchmark from a commercial company that took the ideas from C-Store and productized them", " This company's call Vertica", " This example is from a 30-day trace of call record data", " So this is information from a cell phone company", " It represents about a terabyte of data on disk", " Prior to using Vertica, this company had been using a conventional database system", " So, relative to what the previous database system was able to do, in Vertica, using these column-oriented ideas on a workload running on top of this call data record data set, they were able to get about 88% compression", " So 88% less space to store the data, and about a 60 times speed up in query processing", " So, it's dramatically faster", " Orders of magnitude faster than what you've got using a traditional database system", " So just to wrap up, for analytical queries of the sort that I've showed where you're accessing most of the records in a database, this column-oriented representation is orders of magnitude faster", " And the key idea is that these column-oriented databases allow you to access just the data that you need to answer the query, and they provide support for this very, very aggressive compression", " And I hope that I've also shown you a little bit about why database systems are interesting and different than conventional programming, because there's this whole set of new challenges that are presented when you're developing algorithms that operate on this data that resides persistently and on disk", " Thanks very much", ""], "Kndq_cHHWOI": ["ERIC GRIMSON: We've now introduced lists, ordered sequences of elements", " Elements can be almost anything, and they're mutable", " And we've seen examples of how we'd like to use them", " We can slice, we can clone, we can index, or we can have arbitrary structures inside of them", " We're going to take a slight detour just for a second to talk about functions", " But we're going to bring it back to lists then in an important way", " First, I want to talk about the idea of a first class object", " And we say a data structure, a data type, is a first class object if it has the following characteristics-- it has a type; it can be an element in a data structure, like a list; it can appear in an expression, like an assignment statement, could be on the right-hand side of the assignment statement; and it can be an argument to a function", " Now, it's pretty clear that ints, floats, strings all have those properties", " It's easy to believe that lists and tuples would also have those properties", " But so do functions", " Now, that's interesting, right? Does a function have a type? Well, that's easy to believe", " Could a function be in a data structure, like a list? Huh", " Well, if you think about how we create lists, we're simply getting values of expressions and creating a structure where elements of the memory point to those pieces", " So if I gave as an element of a list the name of a function, thinking back to our environment model, it's easy to see how that element of the list, that spot in the list, could point of to that particular procedure object", " OK", " Can they appear in expressions, like the right-hand side of an assignment? Sure", " And we can say, x is going to equal the factorial of 5", " That makes sense", " And then can functions themselves be arguments to other functions? Huh", " That's interesting", " And we're going to see that that can actually be the case", " And this idea of having a first class object for a function or having them be first class objects is particularly useful when we're going to use this in conjunction with lists", " And we often refer to this style of thinking or programming as higher order programming, where we are treating functions as if they're elements of data structures and applying functions to them", " Let's see if we can make a little bit more sense out of this by looking at an example", " I'm going to write a little procedure here called applyToEach", " Takes two arguments-- list, L, and the variable on our parameter whose name I'm going to call f", " And I'm going to assume that L is a list and that f is a function", " And what I want applyToEach to do is to walk through the list, mutating each element in turn by replacing it by what happens when we call the function f on that element", " So the code doesn't look too bad", " I've got a little loop, where i is walking from 0 up to the length of the list, or 1 less than the length of the list", " It's going to get all of the elements of the list", " And what am I doing? I'm going to get the i-th element of the list", " I'm going to call f on it", " And then I'm going to change that i-th element of the list to be that value", " Let's think for second", " If we think back to our environment model, if I applied this where I passed in for f some function, square, we said that we would bind a local frame, where the variable f would point to the value of that parameter, which, in this case, would be square", " And then, when we executed the body of applyToEach, we would simply be using the value of f, looking it up", " So in essence, we would simply be substituting in for f", " I'm not going to do the example of the environment model", " But what we just described makes sense", " So let's see if that actually works then", " Let's take an example of this", " So I'm going to walk through this in sequence", " I'm going to do applyToEach", " And I'm going to start with a list L that's a set of numbers-- 1, -2, and 3", "4", " And I'm first going to call applyToEach on that list L with the built-in procedure abs called on it", " What happens if I do that? Well, I know-- I'll think again about my environment model", " I'm going to create a frame-- applyToEach is some procedure", " I'm applying it", " So I'm going to create a frame in which L will be bound to this structure and f will be bound to what that points to, which is a procedure object", " And then what am I going to do? I'm just going to walk down the list L, at each point applying f, which is bound to abs, to each element of L and changing the value", " And if I do that, what I get is that when I print out L, it now has that form", " I've mutated L", " And yeah, the 3", "4, because of the way we represent floating point numbers, doesn't quite come out the way you'd like it to", " But we've changed L", " And what's important to see is I've run through a loop, where I'm just applying a particular value of f-- in this case, bound to abs-- to each element of the list", " Now, having changed L, let's do it again", " Let's applyToEach again the list L, now at this form of 1, 2, and 3", "4", " And in this case, I'm going to use int", " And again, what it says is, up here, I'm in essence binding f to int in a local frame so that when I'm evaluating this body, f points to the internal procedure int", " And if I do that, I now get a new version of L", " Actually, that's a poor way of saying it", " L is still there", " I have mutated L so that it now has the values 1, 2, and 3", " How about fact? Let's assume we've got fact", " Factorial is available to us", " We can do the same thing", " And it now gives us the first, second, and third values of a factorial are a fact(1), fact(2), and fact(3) ", " And now that I've changed L again, let's do it one more time", " Let's do it with fib to get the first, second, and sixth Fibonacci number", " And out they come", " What I want you see here is that we can pass in a function as an argument", " We just did a different function each time", " In terms of how things work in that environment model, we're just locally binding in a frame the variable f, that parameter f, to some value, function", " And then, in the body here, we're simply looking up the value of f and using it", " Now, by the way, if f had just been a name for a specific procedure, we would have done the same thing", " If we'd said int instead of f, what would we have done? We would've looked up the binding for int up in the global environment, which points to procedure object", " So here, we're just passing them in as we go along", " That's actually quite nice", " That says we can do a bunch of interesting things with functions", " But we could do it in a different way", " So for example, I said that functions could be elements of lists", " So let's think about one more", " Instead of applying a function to a list of numbers, let's apply a list of functions to a number", " So here's applyFuns", " It assumes that L is a list of functions", " It assumes x is a number", " And what's it going to do? It's going to loop through each of the elements of the list and call that function on the number and then print it out", " And so if I actually run this-- well, let's do it over here", " Let's go check it out", " I've got a version of it over here", " And let me just load this up into my IDLE environment", " And let's call applyFuns", " And we're going to give it with abs, int, fact, and fib, which I've defined in my file here", " And we'll give it the number 4", " Very cool", " That's really neat", " What did it do? It ran through a loop, where it first started off with abs as the binding for f and then applied abs to 4, printed it out", " And then, in the next loop, it got int and applied int to 4, which is pretty boring, printed it out", " And then it took fact and applied fact to 4, printed it out, and then fib, and applied fib to 4 and printed it out", " What we can say is that those functions can also be members of lists", " And we can loop over those, using them in places where we would like them, as well", " Very nice", " Let's take this one more step", " We can generalize these higher order functions a little bit more", " And in fact, Python provides some general purpose higher order procedures for us", " One of the ones it provides for us is the procedure map", " And what does map do? In its simplest form, it takes a unary function-- that is, a function of one argument-- and a collection of suitable arguments", " So function numbers had better be numbers", " And basically, map literally maps this function in turn down each element of that list, giving us back the result of applying each of those elements to that list", " So it's a little bit like applyToEach, but it's basically capturing the same thing", " However, map is even more general", " We can give it an n-ary function-- that is, a function that takes n arguments-- and n collections of arguments", " And map will apply this function in turn to the respective elements of those arguments", " So in the case of min, where min takes two arguments, I can give two lists, L1 and L2, to map", " And it respectively applies min to that pair, then min to that pair, then min to that pair to create this list that it returns", " We're going to come back to this idea of using functions in this way, using higher order procedures, throughout the term", " But you've now got a sense of once I have lists and once I treat functions as first class objects, the kinds of things I can start to do with it", ""], "euWTTA4YPaY": ["NTA"], "XLjNHjfVdhs": ["CHRIS TERMAN: In the next example, we're going to develop a class that represents a grade book, a list of grades for every student in a class", " As you look at the class and the following code that uses the class to actually produce the grade report, look at the interaction between them and think about whether there's other things that should be added to the class in order to make using it more effective", " It's often the case that one doesn't get all the right methods in a class to begin with", " Only in using it will you discover what other functionality needs to be added", " So we're teaching a course, and an obvious application is a grade book", " We'll need to keep track of the grades for all the students in our course", " So let's set out and build one", " We've chosen to organize it as a new class of its own", " A class of Grades, which will turn out to be a grade book", " You can see here are the methods that we've defined", " Let's look through them", " So when we make a grade book, initially, our list of students is empty", " And our grades dictionary is also empty", " And we're going to represent grades by-- we'll put them in the dictionary as a list for each student", " And the students are referenced by their ID number", " So the grades is a dictionary which maps ID number to a list of grades that have been entered for that student", " And finally, we have a little internal helpful helper variable called isSorted, which will be true when the list of students is currently in the correct order", " And of course, with an empty list, it starts off that way", " We have support for adding a student to the grade book, we basically pass in a student object, and if the student is already in our list of students, then we sort of indicate by raising an error, in this case, a value error, that the student is already in the grade book and that this was an incorrect operation", " If the student is not in the grade book, we go ahead and append them to our list of students", " And at the same time, we initialize their entry in the grades dictionary", " So indexed by their ID number, we set up an empty list, because we have yet to enter any grades for the student", " And finally, because we've added a student to the end of the list, we don't know if they're in order", " So we remind ourselves that, at this point, after the addition, the student list is not correctly sorted", " We can go ahead and add a grade for a particular student", " We pass in the student and the grade we want to add", " And we're going to basically reference the grades dictionary, using the student's ID number as a key, and we'll append the grade that were doing to the end of the grades list for that student", " The difficulty comes when we pass in a student who's not actually part of the grade book, what should we do? Should we add them to the grade book? Should we just fail silently and not indicate anything? Well, the correct behavior in this case is to catch the situation where we are providing an index into the dictionary that does not exist", " When that happens, the Python system raises a key error", " We'll capture that error, and, basically, reinterpret that error as a value error with the message, \"Student not in the grade book", "\" So the idea is that the grades dictionary is sort of an internal data structure, and it would be weird for somebody who is adding a grade, who knew nothing about the internal data structure, to get an error associated with dictionaries", " So what we want to do is to take errors that are sort of only because of a particular internal representation and then turn them into an error using the try and accept statement here that will indicate an error the user would understand", " Similarly, we can get a grade for a particular grades list for a particular student by passing in the student to the getGrades method", " Again, we're going to go try indexing into our grades dictionary and returning a copy of the list of grades that we see", " And if, for some reason, the student isn't in the dictionary, we raise the same value error as before", " So why don't we return a copy of that grades list? Well, in general we don't want people corrupting the internal data structures of our grade book", " So when we give them back something, we tend to give them a copy, so they could reorganize the copy or do whatever they want without affecting our own internal representation", " Finally, here the bottom, we have a way to get a complete list of students", " And in this case, we want to return a sorted list", " So if the internal list isn't sorted, we sort it and then remember that we did so", " So we have a huge grade book", " Every time somebody asks for all the students in the grade book, we won't continually be sorting the list", " We'll only be sorting it if it needs sorting", " Finally again, we return a copy of that now-sorted list so that people can manipulate that list in many ways", " None of which will change the actual student list that we have inside the grade book", " Now why don't we choose to organize this is a class instead of just some data structures and a bunch of procedures", " In object oriented programming, what we're trying to do is take advantage of encapsulation", " So that's sort of a big OOP concept that's one of the main strengths of object oriented programming, where what we do is, we collect together all the data for a particular application, and all the procedures for manipulating that data, and encapsulate them together in a single object", " That way, people can use the object without really understanding any of the details of the internal operation", " And the class definition itself sort of gives us a specification for interfacing with their collected data that's inside", " Let's see this in operation", " So here is a little procedure that we've written that produces a grade report", " It sort of works like you expect", " It goes off and gets all the students in the course", " And for each of those students, it's going to first figure out their average grade", " So it runs through their list of grades, so for the grades for that particular student, we're going to go through each grade, adding it to a total, and then keeping track of the number of grades that we run across in the list", " And then we can compute the average by dividing the total by the total number of grades", " And when we're done, we're generating a report, so we're going to keep a list of the report", " And we report the students average grade on that list", " And finally, when all is said and done, we take the individual lines for each student and join them together with new line spacing, and return that as our answer", " Notice that what happens if we run across a student that has no grades, in other words, the grades list is empty for that student", " So numGrades is zero, and this would normally create a divide by zero error", " And again, in an attempt to provide a good interface, we're going to catch the error that might be generated by a divide by zero, and instead put into the report something more sensible, just that that student has no grades", " So to try it out here, we have a bunch of students that we defined", " And again remember, each time I define a student, they're getting IDs in consecutive order", " I then go off and create a grade book for a particular course and add a bunch of students", " And then for each during the course, I give them a particular grade of 75 for the first assignment, and then for a couple of the students, they get some additional grades", " And finally, at the end, just to see what'll happen, we add a student to the grade book and, of course, at this point that student has no grades at all", " So if we come over here and look, we can find out what six00", " Well you can see, it's a grades object", " That make sense", " It was meant to be a grades book", " It's an instance of the grades object", " We can go off and ask for all the students in six00", " So six00", "allStudents", "() Let's just print out their names", " And here they are", " And in fact, even though we entered them higgeldy-piggeldy, you can see when we ask for a list of all the students, they come out sorted by ID number", " Remember that the students, because they're an MITPerson, when we sort them, they're sort of by ID number", " So all that's great", " You might ask yourself, why didn't we just reach inside and knowing that there was a list of students, why don't we just say, for s in six00", "students and just grab the internal data structure", " Well, that's part of the data hiding aspect of Python objects", " We're really trying to provide an interface to the grade book that has a limited number of operations", " So we changed the implementation of the grade book later, people can still use it, and they shouldn't have been relying on any particular internal representation", " So if I'm all done here, what I can do is go ahead and ask to print out a grade report", " And I'll pass in the grade book as the argument to my little report generator", " And there we go", " You can see that we've gotten these five lines, one for each student, and we've calculated their average grade appropriately", " This data hiding aspect has pluses and minuses", " One, it allows us to change the internal representation as we'd like", " But we can also be stuck with the problem that we generate some inefficiencies", " For example, when we wanted to return a list of all the students, we carefully made a copy of the internal list and returned it so that the user could go off and do what he wanted to with a list of students", " The difficulty with that is, if I have a 100,000 students in my big online course, what I'm worried about is, that I've now, every time somebody asks for a complete list of the students, I've generated a copy of that list", " And if the intent is to basically iterate through that list and do something, that's a pretty inefficient operation-- creating an extra 100,000 element list every time you want to look through the grade book", " So we need to think of a strategy for dealing with that inefficiency, but still keep the strengths of data hiding, where the idea is, we don't really want people to know exactly how the internal representations used in the grade book", " So let's think about that for a moment", ""], "dioRzS_GaQE": ["NTA"], "jq5M5Gmf0do": ["the introduction to computer science and programming", " It's odd to have both of those terms in the title, but both of them are important", " This course is going to be not just about teaching you how to program a computer, how to tell the computer instructions that it can understand", " It's also going to be really important to create within you a capability to think computationally", " So our goal is to let you become skillful at not only getting the computer to do something, but to do that thing that you want it to, to get it to solve a problem", " By the end of this course, we hope that your first instinct when faced with any interesting challenge is to first think about how could I capture that challenge, that problem in an algorithmic or mechanical description of steps such that I could get the computer to do the work for me", " If you can do that, it's going to give you a great deal of advantage as you face any kind of problem", " And those are the skills that you're going to see throughout this course", " Now if our goal is to have you learn how to get a computer to do something for you, how to talk to the computer, how to think algorithmically", " 1 of the questions we can ask is, so what's the computer going to do for us? What's it actually good at? That seems like probably an odd question", " After all, we know computers could do a ton of things", " But it's still important to go back to a very fundamental and basic point", " What does a computer do? In fact it does 2 things and 2 things only", " It performs some calculations, and it remembers results so that it can reuse them", " Now you'd say, OK, so it performs calculations", " That seems fine", " But what kinds of calculations", " Well, it turns out that every computer comes with a simple set of primitive calculations, things that we call built in", " They're provided by the manufacturer as the basic elements that a computer could use", " We'll see some examples of that shortly", " If that's all we have, that's pretty limiting", " So a key thing, as we go through the material in this course, is to learn how we can create our own methods for computing something, how we can capture the computational way of thinking about something in a manner that could be used by the computer, and to do it in a way whereby the computer can abstract that", " By that we mean that the computer can figure out how to take what you tell it and turn it into something that it can now treat as if it were a primitive, something that was provided by the manufacturer, and reuse that throughout its computations", " So our computers are going to do calculations for us, using a set of built-in primitives, plus things that we add", " Now you might ask, gee, is that enough? If it turns out that a computer can just perform primitives calculations, it's not sufficient", " Well, as I'm sure you already realize, modern computers can perform most calculations incredibly quickly", " And so one question is if we can do them fast enough is that sufficient to do interesting things? Let's look at both parts of that", " First of all, how quickly does a modern computer actually run? Well, let me give you a simple little thought example", " If I were to take a little gooseneck lamp and put it right here, a foot above my desk, and I were to time things perfectly so that as I hit the switch on the lamp I hit a key on my computer and started them both up at exactly the same time, in the length of time it takes the light to go from the lamp to the desk your computer will execute two operations", " That's amazing", " It does two operations, two of those primitive operations in the amount of time it takes light to go basically a foot", " Unbelievable", " Here's another way of thinking about it", " Imagine I take a simple child's rubber ball and I suspend it about a meter off the ground and I drop it", " If I let it drop, by the time it hits the ground, assuming gravity behaves normally, your computer will have executed 1,000,000,000 operations", " Unbelievable", " 1,000,000,000 operations by the time that ball hits the ground", " Now, that suggests that in fact these computers are incredibly fast", " And even though they're computing very simple things, they're doing incredibly quickly", " They are", " We say computers do simple operations", " We also said that they have some storage", " So how big is the storage inside of a computer? Well, every element of storage is called a byte", " And if we were to assume that a byte weighed 1 ounce -- I know bytes don't really weigh ounces, but assume they weigh 1 ounce", " A typical computer has hundreds of gigabytes of storage", " And that says if each one of those bytes weighs 1 ounce a computer would be able to store the equivalent of 300,000,000 tons of storage", " OK", " They don't really store it that way", " But you get the idea", " Incredible amount of storage, can remember a lot of things, and incredibly quick in terms of doing the computation", " So, that sounds really good", " The question is if they're only primitive operations is that enough? Are these simple calculations sufficient? Well, they're going to do a lot as we see", " But we're also going to see that they're not quite enough to do everything we'd like", " Let me give you 2 examples", " I'm sure all of you have gone to the World Wide Web to look up a piece of information", " You've searched the web to try and find things that you'd like to know about", " The question is if a computer is just doing this the straightforward way how quickly would it search the web? Well, it turns out there are about 45,000,000,000 searchable pages on the web at the moment", " If we assume that it takes about 1,000 words, or there are about 1,000 words per page", " Some, of course, are much more than that, some of less, but about a thousand words per page", " And just for sake of argument, we're going to assume it takes about 100 operations per word to find the word on the page and to decide it's the right thing", " 100 is actually high", " Let's make it a little less", " Let's just assume it's only 10 operations per word", " How long does it take to actually execute that search? Well, we can do the math", " You can grind it through", " You have 45,000,000,000 pages", " You have that many operations", " You know how quickly we're doing these actual operations", " If you put it all together, what you find is it's going to take you about 5", "2 days to find something on the web", " That's a slow browser", " That's not going to work very well", " And that basically is giving us a hint that even with really fast computers we have to be smarter", " Let me give you a second example", " Playing chess, something that's seen as a very difficult task", " It's impressive that about 10 or 15 years ago a computer program actually beat the world champion in a chess match", " And 1 of the questions is, well, OK, is it just because the computers are really fast? Well, we can look at this two ways", " In a typical chess game, there are about 35 moves at any one time", " And so the question you could ask is to say, OK, if I want to have my computer program look ahead 6 moves, 3 moves by me, 3 moves by my opponent, how many different options are there if there are about 35 moves each? And the answer is about 1", "8 billion different sets of the chess board that I'd have to look at", " If I can check each move out in about 100 operations per move, then that says it's going to take me about a half hour to actually look at each move", " That's pretty slow", " And this is pointing to a problem that we want to get at", " And the problem is that, yes, computers are really fast, but we need good algorithmic design as well", " To deal with interesting problems, we need algorithms that are clever, are intelligent, are smart about how they actually do the work", " And that's a lot of what we're going to talk about this during this term", " By the way, we also said space was a big issue", " And we got a lot of space in the computer", " If you go back to the chess example, you can ask the following question: How many different games are there in chess? Experts will tell you there about 10^123 different chess games that are possible", " Is that too big for storing in your computer? Well there are only 10^80 atoms in the observable universe", " So we can't just store away all the games and look them up", " And both of these are pointing to why we're going to use this course to actually learn about thinking algorithmically", " Now this suggests it's just a matter of putting together enough speed and enough smartness", " But one can be a little bit more distinct and say, are there actual limitations to what we can do with the computer? And in fact despite its speed and its size and the cleverness of the algorithm, our computer still has some limitations", " Here are a couple of examples", " First of all, there are some problems that are just too complex", " We don't have enough speed, enough storage", " And they may get tackle as things improve", " But examples here would be things like predicting weather at a very local scale", " I'd love to know what's exactly going to happen outside my window for the next half hour or next hour or next 3 hours", " The size of the problem simply too big for a computer to be able to model well enough and solve in a reasonable amount of time", " It turns out some of these complex problems actually help us", " Modern cryptography, the way in which information is securely transmitted across the net, relies on having some problems that are simply too difficult to compute and, therefore, too difficult to break the code", " So we actually get some benefits about the problems that are too complex", " But as we're also going to see later on the course, there are some problems that are just fundamentally impossible to compute no matter how big the computer is", " And some of those are really heavy", " Here is one example, being able to predict whether a piece of code will always stop with an answer for any input", " By that I don't mean just you run it and see if it stops, being able to write a piece of code and then have some other piece of code inspect it to say, this will always work", " It will always stop, and it will always give us an answer", " This turns out to not be possible to solve", " And this is known as Turing's Halting Problem", " And we'll talk briefly about that later on in the term", " But it says that there are some problems that are simply too hard to solve period", " Nonetheless, in this course, we're going to start talking about how do we think algorithmically and get the computer to do interesting things for us", ""], "hXyXRmJA8RU": ["ERIC GRIMSON: OK", " So we've now seen how to create simple expressions", " We can take objects that are numbers like integers or floats", " We can combine them together with operators, so we say 3 plus 4 or 3 plus 4 all in parentheses times 5", " That gives us a way of doing some simple computations, but it's pretty boring", " It basically says we got a calculator", " So we can type in expressions and get out values", " But we like to obviously do more complicated kinds of things", " One thing we need in order to make that happen is what we call a means of abstraction", " While we can certainly write arbitrary expressions, it would be valuable having written it down and gotten the value of an expression to be able to remember, to save it away by giving it a name, and then using the name to get the value back whenever we needed it", " Fortunately, we have that ability", " It's called assignment", " And in Python, the format of that is shown here", " We type in word or a sequence of characters followed by an equal sign followed by some expression whose value will then be associated with that word", " So if I go over to my Python shell, I can do things like I'm going to say, give the name pi 3", "14159", " And notice when it print it out, it doesn't mean anything", " It simply has done that assignment", " That is it basically-- as we're going to see later on-- created a binding of the name pi to that value", " If I want to see the value of pi, I can simply ask the Python interpreter to give it to me, and it prints it back out", " So I could do another binding", " I can say, I've got a radius of 11", "2", " Again, notice that it doesn't print anything out", " If I want to get the value of radius, I can ask for it", " But I can also now do things like create expressions", " So I'm going to assign the name area to", " And I can now write an expression as I would have before with now not just numbers but names whose values are also numbers", " So the area is pi r squared, where r is my radius", " And I can say, OK, what is the value of area? And it did that computation", " So I have an assignment statement", " And notice here I'm using a single equal sign, which is why we use the double equal sign for comparison", " A word or a name, an equal sign, and expression says, get the value of that expression and bind to it or bind it to if you like the value of the name associated on the left hand side of that expression", " So let's look at that in a little more detail", " We say that we're binding a variable or a name to a value", " And what does that mean? That statement pi equals 3", "14159 literally assigns the name pi to the value of the expression to the right hand side of the equal", " And you can think of this as literally creating a binding between a name and a value stored somewhere in the computer", " So over here are all the values that are stored away in the computer", " And I have somewhere within the computer a listing of all the names whose bindings I have done", " As we just saw, we can retrieve the value associated with the name by simply invoking the name, just asking for what is the value pi or pi", " Now I can change the bindings", " So having the bound a variable name, I can do another assignment statement", " So, for example, if I go back over to my Python shell, I could change the value of radius", " Remember, initially we had radius of 11", "2", " Let's change it to something different", " Let's changes it to in fact-- I'm going to make this 14", "3", " So how do I do that? I say let's have radius be 14", "3", " Now what's my value of radius? There it is", " What that's done in my diagram over here is it's change the binding for radius", " Remember before it was 11", "2", " It has now changed into something else", " But notice that area hasn't changed", " And in fact I can confirm that", " The area is still 3", "94 point a whole bunch of stuff", " And that's because my evaluation of the binding for area having been done earlier has simply stored away that value", " As you can see right here, it doesn't have an expression of value", " And it is the particular value", " So rebinding radius does not change the binding associated with area", " An easy place to make a bug or have a mistake and something that you want to keep an eye out on as you move forward in terms of using these ideas", ""], "G0qUN3eTqlo": ["ERIC GRIMSON: Let's visualize what selection sort does", " The basic idea is that we're going to start with the first point in the list, look at all the remaining ones to find the smallest thing, and then swap those two points and continue on", " So we start by putting a marker at the first spot on the list", " We then start by taking a second marker at the next point in the list, and we keep scanning down, checking to see where is the smallest thing that we've seen in the list, which happens to be here", " When we get to the end of the list, knowing that that's the smallest thing, we swap those two elements", " And then we move the marker up one, start our checking point at the next one, and again, scan down the list, finding the smallest thing we've seen so far, which eventually we find there", " Having found that, we swap those two elements, move on to the next point in the list, move our marker up one, and again scan for the smallest element in the list", " Which happens to be here, so when we get to the end, we swap those two", " And you get the idea", " We move the marker along, the thing that we're going to check along, and we keep scanning until we find the smallest element of the list, which is right there", " Once we've gotten to the end of the list, knowing this is the smallest one, we swap these two, and we can carry on", " I'm not going to do the rest, but you can see how we're selectively finding the next smallest element, and putting it at the front of the list", " You can also see how that notion of having the prefix sorted and the remainder not, but finding the smallest element and adding it to the prefix builds that invariant that lets us guarantee that this works correctly", ""], "Ejy6ILfh_hk": ["NTA"], "xnhi9-ud_vI": ["Eric Grimson: We've been building a lot of code", " We've been starting to think about how to deal with Python", " And this is great", " And it would be fantastic if our code always worked perfectly first time we ran it", " Of course, it would always be nice if I won the lottery every time or my favorite sports team won every game", " Unfortunately, that doesn't happen", " As they say, life ain't perfect", " And so we need to have a way of guiding ourselves as we think about how to both test our code and then fix it", " So we're going to talk about testing methods, which are basically ways of trying code on examples to try and figure out if it's running correctly", " And then once we've, in fact, isolated that there may be a problem, we're going to talk about debugging methods, which are ways of fixing the program that you know does not work as you intended it to", " We're going to talk about both of those throughout this lecture", " Now, let's start by thinking more abstractly about sort of when should we, in fact, do these tasks", " When should you test, and when should you debug? Part of the goal here is it would be really good if we could actually ahead of time, figure out how to design our code to make it easier to do this", " And indeed, all good programmers have that kind of practice", " They break the code up into components that can be tested and debugged independently", " They find natural breaking points between different parts of the computation, places where our computations contain, and a simple result is passed on", " And they write functions to capture each parse", " That's going to allow us to more easily test pieces", " Second thing good programmers will do is they'll write good documentation", " When you've got a problem set, it's often easy to think I'm just going to start working on this", " But in fact, before you jump into code, think about writing down what it is you're trying to do", " What are the expectations on my input? What are the expectations on my outputs? Even if the code doesn't strictly enforce constraints on the inputs by testing for them, this kind of documentation can be really valuable when you're trying to trace down why a piece of code is not behaving as expected", " And finally, good programmers will document assumptions", " I'm assuming certain conditions, both in terms of what's passed into the code and at certain stages throughout the code", " And detailing those assumptions is going to make it easier for us to actually isolate where there may be problems, for example, because an input does not satisfy an assumption", " All right", " Once we've designed our code, we can, in fact, start moving on to testing it", " And to do the testing, basically we need to do 2 things", " The 1st one is we've got to make sure our code actually runs", " So we need to remove any syntax errors", " We need to remove any static semantic errors", " And fortunately, in most modern programming languages, including Python, these things will be handled automatically, indeed, as you probably already seen", " If you write a piece of code that has either a syntax error, you forget a semicolon, or you've got the wrong kind of parentheses, or a static semantic error, when you try and load that into the Python environment, typically, the interpreter, the evaluator will complain", " It will say you got an error and not actually let you run", " That makes it easy to fix those kinds of errors", " Once you have those done, if you're ready to start doing testing, it's often really good to have ahead of time worked out a set of expected results", " What do I expect the output of the program to be on a particular input? Because that's going to form a template for helping us figure out how to find where the bug actually lies", " OK", " With that, we're now ready to start moving on to thinking about testing", ""], "DtPyN40SjaA": ["NTA"], "FylxGyUzB7g": ["NTA"], "pGd3WqZK4Cg": ["NTA"], "Zu0qEdz4Tq8": ["SPEAKER 1: So we now have this notion of iterative algorithms", " Very powerful tool, thinking of things in terms of loops is a natural way of thinking of problems", " But there's another way of thinking about problems, and let's go back to that idea of doing multiplication by successive additions", " Here's a different way of thinking about this computation", " This basically says, a times b-- well, that's the same as taking b copies of a and adding them together", " But I could also think of that as saying, that's the same as taking a and adding it to whatever I get by doing that accumulation of b minus 1 copies of a", " Now you're going, oh come on, this is pretty simple", " You're just playing games here", " But I'm not", " It's a really important point here", " I have just reduced this problem to a simple operation and a simpler version of the same problem", " And in fact, what is this piece here, that is exactly the same as a times b minus 1", " Ah-ha", " That's a simpler version of the same problem", " I've now thought recursively", " Sounds like a highfalutin term", " It's really not", " It says, I have taken a problem, and I've essentially said, let me reduce this problem to a simpler or easier version of the same problem, plus some operations I know how to do", " And so I've reduced the idea of multiplying a times b into a simpler problem", " Add a to whatever I get by multiplying a times b minus 1", " OK", " That sounds nice, but what does it really mean", " Well as I said, this is an idea of a recursive algorithm", " And what we do when we think about something recursively, is we do two things", " We first say, how can we reduce this problem to a simpler or smaller version of the same problem together with some operations I know how to do", " And that's what we call the recursive step", " We just saw that", " Of course we can't keep unwinding that", " Eventually we've got to stop, we've got to ground it out", " And that's the second piece", " And the second piece is, we're going to keep thinking about, how do we reduce this until we reach a case that is simple enough we can just solve it directly", " We call that the base case", " We don't have to do it in this order, we can do it either way", " We can think about, what's the base case and what's the recursive step", " But these two pieces are important", " In my case of thinking about multiplication then, what do I have", " What's the base case", " I got a couple of choices, but an easy one would be to say, if b is equal to 1, then a times 1 is just a", " So my base case is really straightforward", " If b is equal to 1, I'm done", " Otherwise, a recursive case is what I just said", " I'm going to reduce a Mul b into a plus a Mul b minus 1", " OK", " You're being a little skeptical, I'm sure, saying, so what", " So you've played some games here", " But I've just described a wonderful algorithm for a different way of thinking about this computation", " Because I could capture this in a recursive algorithm", " And let's do it", " Here's the code for a recursive version of multiplication", " And notice it just nicely matches what I just described", " This says given two values, a value for a and a value for b, check to see if b is equal to 1", " That's my base case", " There it is, right there, base case", " And if it is, just return the value of a", " Simple computation", " Otherwise, I'm going to call the same function with a simpler argument", " We could do recursive Mul again on a and b minus 1, and when that computation is done, it's going to get me back a value, and I'm going to return that value added to a", " And there's my recursive step", " Nice, simple code", " Let's check it out, make sure it does the right thing", " I go over to idle, I've got a definition of that right here, and I load it up", " And let's try the same thing", " So if I do recurMul-- if I can type, which I will-- Mul three and five", " OK, and if I do recurMul on 26 and 35, it's giving me back the same answer", " And notice it's also giving me an answer", " Which may be worrying you as you look at this definition of the code", " So in the next segment, let's look to see why does this do what it does", " But the key thing to see here is this idea that given a computation, I'm going to break it down into a simpler version of the same computation, plus some things I know how to do, and I'm going to keep unwinding that computation until I get to a base case-- something I can solve directly", " We'll do that in the next segment", ""], "g4uT2pXnwxc": ["NTA"], "EE910ZBFlCg": ["ERIC GRIMSON: We just showed you a recursive algorithm", " You may be a little worried about it", " You may be going, OK, but how does it know which values of the variables to use? Because I'm not seeing any explicit changes to those values", " How does it make sure it really stops? Why doesn't it just keep unwinding? Didn't your high school geometry teacher never to use definitions where you defined a term in terms of itself", " Good news is not to worry", " And we've got a tool to help us understand that", " Let's go back and simply look at a simple call to recurMul, recursive multiplication, using that set of environments to see how computation flows", " So here's my code, I've just got a copy of it here", " And in particular, if I evaluate this, or load this if you like, into a Python environment, a shell, we know what's going to happen", " Which is we're going to create a frame over here, in which that name, recurMul, is bound to a procedure object", " And it's got inside of it both the parameter list and the body, the set of things it's supposed to do", " OK, let's see what would happen if we actually called it", " So let's call it", " Calling it says, I am going to evaluate this expression down here", " And I'm going to first get the value of recurMul", " I know what that is", " It's given by that pointer there", " It's a procedure object", " And so I know that calling it says I'm going to create a new environment", " It's going to inherit, or have as a parent, the same environment that the procedure has, the environment that was in place when we defined the procedure", " So it was going to point to that frame", " And inside of there, first I'm going to get the values of these two expressions, and I'm going to then bind the parameters of the procedure to those values", " All right", " I'm saying it in a long winded way, but you've seen this before", " We've now created a new environment in which a is bound to 2 and b is bound to 3", " And relative to that environment we're going to evaluate the body of this procedure", " OK", " Let's start evaluating the body", " The body says is b equal to 1", " No it isn't", " It's 3", " So it's going to go to the else clause", " And the else clause says, I'm going to return a value", " Great", " I'm going to get a value back", " And it says the value is going to be the value of a", " Remember I'm doing it relative to this frame here so I know the value of a", " It's 2", " And I'm going to add to a the value of the recursive call, another call to recurMul, with different arguments", " Now think of this very straightforwardly", " This is Python", " This is an interpreter", " That's an expression", " It says to get the value of that expression, what do I need to do? You need to get the value of recurMul, oh that's it up here", " OK", " Now, I need to get the value of a", " And remember I'm doing it all with respect to this, and in fact I should have done that better", " To get the value of recurMul with respect to this environment, I'm going to go up and find it there since it's not bound down here", " I need to get the value of a", " There it is", " And I need to get the value of b minus 1", " Well that's easy", " There's b, and subtract 1 from it", " And since recurMul is a procedure, what am I going to do? I'm going to create a new frame", " Cool", " That's exactly what I want", " Because now I've got a computation that's taking place with respect to this frame", " And how did I set that up? Well I got the value of a", " I got the value of b minus 1 from here", " I've bound those in this procedure because that's what it tells me to do", " And I'm now saying, evaluate this procedure in this frame", " Remember, when I get the value of this I'm going to give it back to this frame to complete that addition", " But I've now reduced this to simpler computation", " Notice something else really nice", " You may have been saying, well, how do I keep track of my iteration variable? It's not really iteration, it's recursion", " But notice I've reduced b", " And that's exactly what's going to happen", " I'm going to keep unwinding this computation until I ground that out", " OK", " We're now in pretty good shape", " Because what do we want to do? It says I need to get the value of this procedure, this body, this body here, with respect to this environment", " What do I do? Well, let's say is b in this environment equal to 1? No it is not", " So I'm going to return the value of a from this environment, which is right there, to another procedure call", " I'm doing another procedure call on recurMul", " What do I do? From here, I get the value of recurMul", " And I trace up that chain to say, there it is, it's that procedure", " I need to get the value of a in this environment", " That's easy", " And I need to get b minus 1 in this environment", " Well, that's easy, as well", " B here is 2, I subtract 1, and that leads naturally to yet another recursive call", " Now, you're going to be glad I only did this with 2 and 3, and not 2 and 57", " But you get the idea", " I am now evaluating the body of this procedure with respect to this environment", " What do I do? I say, OK, is b equal to 1? Thank God, it is", " But if b is equal to 1, what do I do? I return the value of a from this environment", " So that computation gives me back a 2", " That's really nice", " Because what does that say? It says, gee, here's where I am", " I'm now returning the value of a because I was in that recursive call", " It says the value of this recursive call is 2", " I'm going to give it back to the place that was waiting for it, which was up here", " And what was I doing? I was waiting to get the recursive value", " I want to add that to a", " So the 2 is returned", " It gets passed back up here", " It gets added to that a", " Those two pieces come to there", " And what was that doing? That was saying, give me a return of those two values to the computation that was waiting here", " So, in fact, the 4 and the 2 get added together to give me 6", " And what was that doing? It says, I'm now done because that procedure said return that value as the overall value", " And that's going to get passed back up as the final value", " Cool", " A little slow in our computation but really cool", " And, in particular, let's see what we can deduce from this", " Each recursive call of a function creates its own environment, with a local scoping of variables", " So evaluating the body of the function in that environment is going to be very clear as to which value of a and b it's using, or any other variable that it's using", " Secondly, the bindings for variables in each frame are distinct", " And you saw that", " I had a different frame for each one of them", " And those bindings are not changed when we're doing the recursive call", " They are set up as we make the call", " That is, I'm going to compute a new value of b, making it in this case b minus 1, in order to bind it in the frame", " But I'm not changing bindings in other frames when I'm within one frame", " I don't have access to them", " And finally we can see that the flow of control can naturally pass back to an earlier frame once the function call returns its value", " So, finally, you can also see that inherently this recursive call to a function, if done right, has the equivalent of reducing a state variable", " We saw how each instance, each frame, had a different value of b, that got smaller and smaller until we got down to the base case", " So we know that this is, in fact, going to ground out", " It's going to complete its computation", " That's great", " So hopefully this gives you a better sense of how, in fact, the rules of evaluation allow a recursive thinking of a problem to create a very nice version of the code", ""], "jGQZlWWXBQQ": ["the introduction to computer science and programming", " It's odd to have both of those terms in the title, but both of them are important", " This course is going to be not just about teaching you how to program a computer, how to tell the computer instructions that it can understand", " It's also going to be really important to create within you a capability to think computationally", " So our goal is to let you become skillful at not only getting the computer to do something, but to do that thing that you want it to, to get it to solve a problem", " By the end of this course, we hope that your first instinct when faced with any interesting challenge is to first think about how could I capture that challenge, that problem in an algorithmic or mechanical description of steps such that I could get the computer to do the work for me", " If you can do that, it's going to give you a great deal of advantage as you face any kind of problem", " And those are the skills that you're going to see throughout this course", " Now if our goal is to have you learn how to get a computer to do something for you, how to talk to the computer, how to think algorithmically", " 1 of the questions we can ask is, so what's the computer going to do for us? What's it actually good at? That seems like probably an odd question", " After all, we know computers could do a ton of things", " But it's still important to go back to a very fundamental and basic point", " What does a computer do? In fact it does 2 things and 2 things only", " It performs some calculations, and it remembers results so that it can reuse them", " Now you'd say, OK, so it performs calculations", " That seems fine", " But what kinds of calculations", " Well, it turns out that every computer comes with a simple set of primitive calculations, things that we call built in", " They're provided by the manufacturer as the basic elements that a computer could use", " We'll see some examples of that shortly", " If that's all we have, that's pretty limiting", " So a key thing, as we go through the material in this course, is to learn how we can create our own methods for computing something, how we can capture the computational way of thinking about something in a manner that could be used by the computer, and to do it in a way whereby the computer can abstract that", " By that we mean that the computer can figure out how to take what you tell it and turn it into something that it can now treat as if it were a primitive, something that was provided by the manufacturer, and reuse that throughout its computations", " So our computers are going to do calculations for us, using a set of built-in primitives, plus things that we add", " Now you might ask, gee, is that enough? If it turns out that a computer can just perform primitives calculations, it's not sufficient", " Well, as I'm sure you already realize, modern computers can perform most calculations incredibly quickly", " And so one question is if we can do them fast enough is that sufficient to do interesting things? Let's look at both parts of that", " First of all, how quickly does a modern computer actually run? Well, let me give you a simple little thought example", " If I were to take a little gooseneck lamp and put it right here, a foot above my desk, and I were to time things perfectly so that as I hit the switch on the lamp I hit a key on my computer and started them both up at exactly the same time, in the length of time it takes the light to go from the lamp to the desk your computer will execute two operations", " That's amazing", " It does two operations, two of those primitive operations in the amount of time it takes light to go basically a foot", " Unbelievable", " Here's another way of thinking about it", " Imagine I take a simple child's rubber ball and I suspend it about a meter off the ground and I drop it", " If I let it drop, by the time it hits the ground, assuming gravity behaves normally, your computer will have executed 1,000,000,000 operations", " Unbelievable", " 1,000,000,000 operations by the time that ball hits the ground", " Now, that suggests that in fact these computers are incredibly fast", " And even though they're computing very simple things, they're doing incredibly quickly", " They are", " We say computers do simple operations", " We also said that they have some storage", " So how big is the storage inside of a computer? Well, every element of storage is called a byte", " And if we were to assume that a byte weighed 1 ounce -- I know bytes don't really weigh ounces, but assume they weigh 1 ounce", " A typical computer has hundreds of gigabytes of storage", " And that says if each one of those bytes weighs 1 ounce a computer would be able to store the equivalent of 300,000,000 tons of storage", " OK", " They don't really store it that way", " But you get the idea", " Incredible amount of storage, can remember a lot of things, and incredibly quick in terms of doing the computation", " So, that sounds really good", " The question is if they're only primitive operations is that enough? Are these simple calculations sufficient? Well, they're going to do a lot as we see", " But we're also going to see that they're not quite enough to do everything we'd like", " Let me give you 2 examples", " I'm sure all of you have gone to the World Wide Web to look up a piece of information", " You've searched the web to try and find things that you'd like to know about", " The question is if a computer is just doing this the straightforward way how quickly would it search the web? Well, it turns out there are about 45,000,000,000 searchable pages on the web at the moment", " If we assume that it takes about 1,000 words, or there are about 1,000 words per page", " Some, of course, are much more than that, some of less, but about a thousand words per page", " And just for sake of argument, we're going to assume it takes about 100 operations per word to find the word on the page and to decide it's the right thing", " 100 is actually high", " Let's make it a little less", " Let's just assume it's only 10 operations per word", " How long does it take to actually execute that search? Well, we can do the math", " You can grind it through", " You have 45,000,000,000 pages", " You have that many operations", " You know how quickly we're doing these actual operations", " If you put it all together, what you find is it's going to take you about 5", "2 days to find something on the web", " That's a slow browser", " That's not going to work very well", " And that basically is giving us a hint that even with really fast computers we have to be smarter", " Let me give you a second example", " Playing chess, something that's seen as a very difficult task", " It's impressive that about 10 or 15 years ago a computer program actually beat the world champion in a chess match", " And 1 of the questions is, well, OK, is it just because the computers are really fast? Well, we can look at this two ways", " In a typical chess game, there are about 35 moves at any one time", " And so the question you could ask is to say, OK, if I want to have my computer program look ahead 6 moves, 3 moves by me, 3 moves by my opponent, how many different options are there if there are about 35 moves each? And the answer is about 1", "8 billion different sets of the chess board that I'd have to look at", " If I can check each move out in about 100 operations per move, then that says it's going to take me about a half hour to actually look at each move", " That's pretty slow", " And this is pointing to a problem that we want to get at", " And the problem is that, yes, computers are really fast, but we need good algorithmic design as well", " To deal with interesting problems, we need algorithms that are clever, are intelligent, are smart about how they actually do the work", " And that's a lot of what we're going to talk about this during this term", " By the way, we also said space was a big issue", " And we got a lot of space in the computer", " If you go back to the chess example, you can ask the following question: How many different games are there in chess? Experts will tell you there about 10^123 different chess games that are possible", " Is that too big for storing in your computer? Well there are only 10^80 atoms in the observable universe", " So we can't just store away all the games and look them up", " And both of these are pointing to why we're going to use this course to actually learn about thinking algorithmically", " Now this suggests it's just a matter of putting together enough speed and enough smartness", " But one can be a little bit more distinct and say, are there actual limitations to what we can do with the computer? And in fact despite its speed and its size and the cleverness of the algorithm, our computer still has some limitations", " Here are a couple of examples", " First of all, there are some problems that are just too complex", " We don't have enough speed, enough storage", " And they may get tackle as things improve", " But examples here would be things like predicting weather at a very local scale", " I'd love to know what's exactly going to happen outside my window for the next half hour or next hour or next 3 hours", " The size of the problem simply too big for a computer to be able to model well enough and solve in a reasonable amount of time", " It turns out some of these complex problems actually help us", " Modern cryptography, the way in which information is securely transmitted across the net, relies on having some problems that are simply too difficult to compute and, therefore, too difficult to break the code", " So we actually get some benefits about the problems that are too complex", " But as we're also going to see later on the course, there are some problems that are just fundamentally impossible to compute no matter how big the computer is", " And some of those are really heavy", " Here is one example, being able to predict whether a piece of code will always stop with an answer for any input", " By that I don't mean just you run it and see if it stops, being able to write a piece of code and then have some other piece of code inspect it to say, this will always work", " It will always stop, and it will always give us an answer", " This turns out to not be possible to solve", " And this is known as Turing's Halting Problem", " And we'll talk briefly about that later on in the term", " But it says that there are some problems that are simply too hard to solve period", " Nonetheless, in this course, we're going to start talking about how do we think algorithmically and get the computer to do interesting things for us", ""], "Q-rY8DIwYgg": ["The social standards on the discussion forum are going to vary from class to class", " But there are a few common trends", " First of all, before you start a new discussion, make sure that there is not already a thread talking about the issue that you wanted to address", " If you are trying to be polite in conventional conversation, you wouldn't walk into a crowded room and expect everyone to repeat and summarize the conversations that had already taken place for your benefit", " Instead, you would listen to people talk, get an understanding of what has already been said, and then participate in context", " Similarly when you come into the discussion forum, you should search for what people are already saying and make sure that what you are saying fits in context", " Also, please bear in mind that the discussion forum contains people of many different educational backgrounds, nationalities, races, genders, and sexual orientations", " We would love for you to get to know each other, but please keep your tone respectful", " We don't restrict access to the forum very often, but we do reserve that right for extreme cases of people who are causing the forums to become unuseful", ""], "NJ-Dw7uiitE": ["NTA"], "twvmnuMYTQk": ["ERIC GRIMSON: Now, we've seen recursive functions", " We've seen this idea of inductions, a way of showing that these functions work", " And we've seen this notion of recursion as breaking a problem down into a simpler version of the problem plus some other work", " We're going to use that tool a lot", " It's a powerful tool for taking complex problems and capturing them in a way that is easy to think about", " So let's look at some examples", " In the classic example to start with is to compute factorial", " Factorial in math is written as n followed by an exclamation point, said verbally as n bang", " And factorial is basically the product of the integers from 1 times 2 times 3 all the way up to n", " How would we think about solving this recursively? Well that's pretty straightforward, right? I need a base case", " A simple case is if n is equal to 1", " 1 multiplied by itself, or just 1 is 1", " That's simple", " To get the recursive case, let's use that same thinking", " To get the recursive case, what do I have? I want a simpler version of the same problem", " In effect, right there that is n minus 1 factorial", " So recursively I would say if I can get n minus 1 factorial, then to get n factorial I'd simply take that value and multiply it by n", " And that gives me that reduction exactly like I saw before", " Fantastic", " There's a recursive definition factorial", " Let's capture it in some code", " And, in fact, to do it let's do both an iterative version and a recursive version", " So the iterative version of factorial has the form we'd expect", " I need some state variables", " One of them is going to be just the parameter n that I'm passing in", " And the other one I'm going to call result", " I need to keep track of the computation as I go along", " I'm going to set a result initially to 1 because I'm going to do successive multiplications", " And then the iterative version basically says if you start off with n that's bigger than my base case, or the stopping point, rather, what do I want to do? I'm going to take my current value result, which is 1, multiply it by n, and store it away", " And then I'm going to reduce n by 1", " There are those update equations that are updating the state variables", " I go around again, n is now one smaller", " And again, I take the current value result, which at this point was n", " I multiply it by the new value of n, which is n minus 1", " And I update it", " I reduce n by 1", " And I keep doing this", " And you can see that I want to start by taking n, n times n minus 1, n times n minus 2, and I'll keep doing that until I get down to a place where n is zero, in which case I stop and I return the result", " Great", " What about the factorial version recursively? Well, factR is nice and crisp", " Here it is", " It just says, if n is equal to 1, if you're in the base case, just return that value", " Here I said return n, I could have said return 1, because I know it's going to be the same thing", " Otherwise, get the solution to a slightly smaller problem by just recursively calling factR, multiply it by n, and just return that result", " Beautiful code", " Nice and clean and crisp", " And you can see that it gives you a very clear sense of exactly the stages-- my base case, my recursive case", " My recursive case is a recursive call plus one other operation, which is to do multiplication", " Let's see if it does the right thing", " So in IDLE, I've got a version of both pieces of code, then let's try first theater diversion of factorial", " And just to be careful, let's make sure it does the right thing on the base case, or n is equal to 1", " If it does then let's give it the bigger one-- I happen to know that 3 times 2 times 1 ought to be 6", " So there we go", " And if I give something a little bit bigger, wow, it actually computes factorial of 25", " Pretty quickly", " What about recursive version? Well let's test the same ones", " On 1 it does the right thing", " On 3 it does the right thing", " On 25 it does the right thing", " And you may notice this funny little form on the screen there where it's got an L at the end", " This is just telling us that Python's got such a big number, it's representing it in what's called a large format", " Don't worry about it", " It just says, I got a really big number", " I gave it back to you", " So we didn't look at stepping through it", " You can go do that", " But you can see that the recursive version stops, computes the right answer, and the code itself is nice and crisp", " OK, let's look at another example", ""], "WqKqfr_tX0Y": ["ERIC GRIMSON: So we've convinced ourselves that linear search really is linear", " It says using indirection, If I've got a list of elements, even if they're arbitrarily complex, because of indirection I can get to any element in constant time", " And therefore the search is linear because at worst, I've got to look at every element once", " Still kind of annoying if list is long", " So can I do better than O(len(L)) or linear search for search? Well, the answer is if I don't know anything about the values of the elements, no", " If they're arbitrary elements and I have no structure to the list, I'm going to have to look at every element at least once in the worst case, in order to determine that something's there", " So I'm stuck with this", " But in some cases I can do better", " And in particular, what if the list were ordered? Suppose that the elements were sorted in ascending order", " Or a simple way to think about it is they're numbers, but they could be more complex things", " I've got some way of deciding how to order them in sequence", " In that case, I could improve things", " And here's a simple search algorithm", " It says given a list L and an element e, I'm going to walk through the list", " So for i going from 0 all the way up to the end of the list, and I'll check to see is the i-th element equal to e? If it is, I can stop and return True", " If it isn't I'll keep going", " But I can be clever", " In particular, if the i-th element is greater than e, remember I said they're sorted in ascending order", " So if I get to a point in the list where that thing is bigger than the thing I'm looking for, I know it can't be in the rest of the list, because they're all bigger than that point", " So I can stop right there and return False", " If I get all the way through the list and I haven't found it, again I'll return False because it wasn't there", " Nice little trick", " What does it do to the complexity? Well, it improves the average complexity, but it doesn't improve the worst case", " Because in the worst case, I still will go all the way through the loop until I get to this clause down here, and I return False", " But even though I haven't improved the complexity right here, I can use that idea in a slightly better way", " Notice what I did here is I used the idea that I knew the ordering of the list to be able to cut off some computation right there", " Once I got to a point where the element was bigger than the thing I'm looking for, I knew it wasn't in the last half of the list", " Let's use the same idea, but more effectively", " And in fact, we've already seen this idea when we did bisection search", " So we can use this idea of binary search much more effectively", " In particular, we would say the following", " Let's pick a point", " An index into the list that divides the list in half", " And let's ask right there, is that the thing I'm looking for? If I am right, I'm done", " But if not, then I can ask the same question I just did before, which is, is that element of the list either larger or smaller than e? But depending on that answer, I can reduce the search", " So what this says is if I've got a big, long list here, I'm going to look at the middle element", " If it's the one I'm looking for, great, I'm done", " But let's assume that in fact, that middle element is bigger than the thing I'm looking for", " Then I can throw away this entire list, and focus on now just searching in this remaining list", " And I can do the same thing", " Let's look at the middle one of those and say, is that the thing I'm looking for? If it's right, and if it is, great, I'm done", " If not, for example in this case, let's assume that that element is smaller than the thing I'm looking for", " Then I can throw away all of this portion of the list and refocus here", " We've seen this trick before", " We're going to narrow down the range of things we're looking for, cutting in half at each stage what we have to look at", " Then we're taking advantage of the ordering of the list here", " So this now is a new version of a divide and conquer algorithm", " I'm going to break up into smaller versions of the problem, a smaller list plus some simple operations, and the nice thing I know is that the answer to the smaller version is the answer to the original problem", " That is if I find the list or the element in a smaller list, that means I found it, and it was in the bigger list", " If I don't find it in the smaller list, it means it wasn't in the bigger list, and I'm done as well", " OK, let's build some code to do this", " Here is a very nice little algorithm for searching a list using binary search", " I've got an internal piece of code here that I'm going to use, and let's look at what that does", " It says basically, given a list, an element, and a low and a high point in that list, a low index and a high index, what am I going to do? If high is equal to low, it says I've got a list of length 1", " So I just return the Boolean value of whether that element is the thing I'm looking for or not", " That's all I've got to do", " If, however, I don't have just 1 element in the list, I've got more than that, I'm going to find a midpoint", " And in particular, I'm going to calculate the midpoint by taking the value of the low end of the list, or low end of the range in the list, and the difference between high and low divided by 2", " So I'm taking the range that's left, cutting it in half, and adding it to the index of the starting point", " That gives me a new midpoint right there", " And then what do I do? I check that point", " If it's what I'm looking for, I'm done", " Otherwise, I check to see is the value of the list bigger than the thing I'm looking for? And if it is, I'm going to call recursively search again with the same low point, but a reduced high point", " And that was what I just diagrammed earlier", " It says if in fact the thing I'm looking for is less than the thing I just checked, I can throw away the entire right half of that list", " On the other hand, if it's less than, then I throw away the lower half of the list, and I compute a new low point", " And I just keep calling recursively until I either run out of things, or I find the thing I'm looking for", " To start this up, I'm going to check to make sure that in fact I have a non empty list", " If the list is empty, nothing's there, the element can't be in it, I return False", " Otherwise I'll call binary search", " Notice one little subtlety here", " I'm reducing midpoint by 1 there, and increasing midpoint by 1 there to make sure that I don't look at the same element every time", " It's a minor nuance, but it's going to improve things", " Here's my binary search", " It's cutting down the list in half at each stage by either taking the upper half or the lower half based on this test right here", " OK, I want to answer two questions", " The first one is does this actually work? Does the recursion halt? We've talked about this before when we talked about recursive functions, and I want to remind you a nice way to deal with this is to create what's called a decrementing function", " So what does that mean? This is a function that maps the values of the formal parameters to a non-negative integer", " In some sense, this is giving us the size of the problem", " And if I can find a decrementing function, something that says, given the values of the parameters, I will take those values and map it into an integer, that decrementing function has to have two other properties", " First is, when the value of that function is less than or equal to 0, the recursion's going to terminate", " And the second one is, for each recursive call, the value of that function is strictly less than the value on entry to the instance of the function", " In other words, the decrementing function will have some value when I start the recursive call, and when I return from the recursive call, it's smaller", " Said very simply, this decrementing function should capture the size of the problem, and I want it to be the case that that function is smaller on the recursive call, and smaller on the next recursive call, and when it gets down to or below 0, the recursion terminates", " Again, a lot of words", " For this particular case, the function's very simple", " It's just high - low, right there", " high - low is telling us the range of the list still to be searched", " And let's check it out", " It's at least 0 the first time it's called", " OK, that's good", " So it's going to be something that's a non-negative integer", " When it gets down to being exactly 0, when high is equal to low, oh, that said I have no recursive call, and I just return a value, OK, so that's done", " And otherwise, what's happening? Well, it's going to either halt or recursively call with the value halved each time because at each case, either high is decreased by half or low is increased by half, And so it's going to reduce the value in each time", " So by finding that decrementing function, I've just proved that my recursive procedure actually terminates", " Great", " So I've got something that does the search properly", " Again, another way of thinking about this is this is just the range left", " That's why I'm reducing it each time", " So I've got something that actually works", " What's the complexity? Well, how many recursive calls are there? Why do I ask that? Well, we know that the work within each call is constant, which is doing an access to a list and comparing it, and we're doing some computations of some simple arithmetic values", " So, how many recursive calls do I have? Well, that can be answered by saying how many times can I divide high - low in half before it reaches 0", " And why is that important? high - low is the range of the problem left", " On each recursive call, I'm splitting it in half, and I'm splitting it in half, and I'm splitting it in half", " How many times can I keep splitting something in half until I get down to something that's basically of size 1? And that, we already have seen before", " That's log", " Log base 2", " Basically, at each step, I'm dividing by 2", " So after log base 2 calls, I'm done", " So the complexity here is O(log(len(L))), and that's nice", " We know that's a very efficient algorithm", " So this is much better than linear is going as the log of linear", ""], "xP87Epe8_5Y": ["NTA"], "yml22-pGOc4": ["NTA"], "la7qhtQ2QKQ": ["NTA"], "-4Uvn-JUksI": ["NTA"], "11z8XCDvC3Q": ["Eric Grimson: OK, so we want to think about computational problem solving", " We want to understand, what does it mean to think computationally? That leads to the philosophical question, so what's computation? And like a good philosophical question, that leads to another, deeper philosophical question", " To answer that question of what's computation, let's start by asking the question, what is knowledge? And, as we're going to see, we can divide knowledge up into 2 parts", " There's declarative knowledge, which we can think of the statements of fact", " And there's imperative knowledge, or how to's methods", " Statements of facts give us true, but, as we'll see, they don't necessarily help us think about how to find new information", " Imperative knowledge, how to methods or recipes, give us ways of finding new information, and that's going to be really valuable to us", " Now, to look at this, let's look at an example", " So, what do we mean by declarative knowledge? Well, here's a piece of declarative knowledge", " That first statement says, the square root of a number x is a number y such that y * y = x ", " You know that's true from high school algebra", " It's a statement of truth", " It tells us something about how to decide whether a particular number is a square root or not, but can we use this to actually find a square root? And the answer is no", " If we have a number x equal to 25 and we're trying to find the square root of that, and somebody gives us a guess y = 5, we can use this statement to test to see if 5 * 5 = 25 , which it does", " But it doesn't tell us how to find the guess", " So declarative knowledge, which is what much of knowledge is based on, isn't what we need", " We want a different kind of knowledge, and for that, fortunately, we have imperative knowledge", " As we said, imperative knowledge is how to kinds of knowledge, or methods or recipes for finding something, and here's a recipe for deducing square root", " It's actually attributed to Heron of Alexandria, although there's some debate as to whether he was the original creator of this algorithm, but it dates from the first century AD", " And you can see the description here", " Description says if I want to find the square root of some number x, I'm going to start with a guess", " I'll call it g", " I'm going to take g and multiply it by itself and look if that result is close enough to x", " If it is, I'm going to stop, and say that g is the answer", " Otherwise, I'm going to make a new guess by averaging g and x/g , and using this new guess, which I will call g again, I'm going to repeat the process until we get something that's close enough", " Notice, this is a mechanical set of steps and it has some basic forms", " Right here there's a test", " It's going to let us know when we're done, when we're close enough", " If that test isn't satisfied, then there's some simple calculations, like here, that tells us what to do", " And then, finally, there's a flow of control, or a loop, that tells us how to keep executing the same sequence of operations until we get, in fact, to a place where we're done", " This is something that tells us how to find a square root", " This is imperative knowledge and this is what we want", " OK, let's try it out", " Here's a little description of that", " Let's see what happens if we were actually to do it", " So I'm going to do a simple little simulation", " I want to find the square root of 25", " And, yeah, I know the answer is 5, but let's think about what might happen here", " I'm going to start with a guess and I'm just going to initially guess 3", " Heron of Alexandria's algorithm says multiply 3 by itself", " That, of course, gives me 9", " Is 9 close enough to 25? I don't think so, so let's get x/g , which is about 8", "33", " And now, let's take the average of x/g and g", " So we add g and x/g , take the average of that, and we get 5", "67", " And then our little recipe says take that and do it again", " So this now becomes my new guess, 5", "67", " I multiply those together", " I happen to know that comes out to be about 32", "5", " I've gotten closer to 25, but it ain't there yet, so that's not close enough", " Again, let's take x divided by this g which turns out to be about 4", "41, and then I take g and x/g and I average them, and I get 5", "04", " And my algorithm says, my recipe says, take this and do it again", " 5", "04 multiplied by itself is about 25", "4, and I'm going to say, you know what, that's close enough, so my little recipe says there's the answer", " Not perfect, but close enough", " So, Heron had it right", " This looks like a pretty good algorithm", " This is a way of describing a method for doing something, and that idea, that notion of a recipe, is something we're going to use a lot", " So we can think of algorithms as being recipes, sequences of mechanical steps for doing something", " We put that analogy to a little bit more use, we can see that recipes have much of the same form, real recipes", " Imagine I want to make some custard", " Here's my recipe", " I'm going to take all the ingredients of the custard, that mixture, put it into a pot over some heat, and I'm going to stir it", " As I stir it, every once in a while, I'll dip a spoon into the custard, pull it out, and run my finger across the back of the spoon", " If the spoon is clear, then I'm done and I'm going to remove the custard from the heat and let it cool", " If not, I'm going to repeat", " And notice what we have here", " Again, we've got a test, right there", " And we've got a way of, in fact, changing the flow of control", " So, normally, the flow runs this way, but based on that test, we have a way of going back up and continuing the path", " And this pattern is something we're going to repeat a lot", " So, you want to capture recipes and we need to figure out how to get the computer to do that for us, which is what we're going to talk about next", ""], "1jnF2wBDvHg": ["PROFESSOR: We've now built an abstraction for a graph-- set of nodes, set of edges, particular representation for capturing them, especially that idea for every node, the edges basically tell us what are all the children of that node-- nodes that we can reach in one step", " And we built a simple little graph with nodes labeled zero through five", " Our real goal is to understand how do we find paths through the graph? How do we find solutions? Suppose in my simple little graph, I'd like to find the shortest path from node zero to node five", " First of all, I'd have to say what \"shortest\" means", " It could just mean the fewest number of steps, the fewest number of edges I have to walk through to get from zero to five", " If I've got weights on the edges though, I might want to actually use those", " They might be the minimizing the sum of the weights-- the cost if you like-- to get from zero to five", " The question is how do I find that graph, or rather how do I find that path through that graph? Well there are a lot of techniques for this", " And a very common one is something known as depth-first search", " We're going to talk about the words on this slide in a second", " But let me give you the intuition, the visualization for you", " I'm going to start off at some root node", " I could be node zero", " I want to get to a goal node-- node five down here somewhere", " From that root node, I know the children", " That is I know in one step what other nodes I can get to, what are the edges that lead from there", " So it might go from zero to one, zero to two, maybe to some others", " I think yours just goes from zero to one and zero to two", " So the idea is I'm going to start at the root node, and I'm going to look at what are the paths that lead out of there", " I've got two of them-- going to one and two", " I'm going to take the first of those-- the path that goes from zero to one", " And I'm going to say what are the children of one? It might be zero and two", " And I'm going to say OK, let me take that first path and extend it by adding from this node all these steps that I can go in one place to get to a new set of paths", " So now I've got a set of paths", " I'm going to keep doing that", " Take the first one, take that end node, say what are the children I can reach in one step, and keep extending the set of possible paths", " Hopefully, eventually, I'm going to get to the goal node", " When I do, I'm done", " And I know exactly the path that got me there", " If I get to a node and there aren't any additional children, well I just throw that away and I backtrack to the previous place I was and look at the next set of options", " OK, we can capture that in words", " The idea is we're going to start at the root node", " This set up paths, initially, are basically just where I am, just starting at the root node", " I haven't taken any steps", " From that node, I then do the following", " I take the path that got me there", " In the case of root node is nothing", " And I extend that path by one step, going to each of the possible children of the current node", " So I take the current path", " Then I replace it in my set with this set of new paths, that each go one step further", " So I add these paths to the set of paths at the front of the set", " I then take that first path at front of the set and I do the same thing, and recursively repeat that", " And I'm going to keep doing that until hopefully, I get to the goal node", " If I get to the node in a path which has no children, then I just go on to the next path", " And I'll keep doing that until I either reach the goal, or I run out of paths", " So there's a description", " We're going to build code in a second", " But let me give you a visualization of this", " I'm going to do that visualization using that simple graph I built in the last lecture segment", " I'm going to go from a root node of zero", " And I'm going to build a different kind of graph called a tree that's going to let me explore the paths through the graph", " So from node zero, I've got two possibilities", " I can either go to node one or to node two", " So I'm going to add two new paths to my set-- that path and this path", " And I'm going to take the first one, which goes from zero to one", " I'm not at my goal of five", " So I'm going to say what are the children of one? Turns out it's got zero and two as children", " So I'm going to replace this path with two paths-- that one and that one", " I can go from zero to one to zero, or zero to one to two", " And now I've got three possible paths to explore", " I'll take the first of those", " It goes from zero to one to zero", " And I could say what are the children of zero? It's one and two", " So I'm going to replace this path with two paths-- going zero-one-zero-one or zero-one-zero-two", " Now I could keep taking the first path", " I'm doing this depth first, the exploration of this space as solutions", " I could keep doing that", " But if I do, I'm in trouble", " Because what is this path saying? It says go from node zero, to node one, to node zero, to node zero, to node one, to-- oh my goodness I'm just caught in an infinite loop", " So I need to be just a little bit more careful about this", " In a particular, I can see that by looking at the following set of steps", " Let's walk through it", " I started off with node zero", " That's my initial path", " I said I can replace that path with a path that goes to each of the children of node zero", " That's one and two", " Now I can look at this path and say let me replace that with the path that goes from one to its children, which are either zero or two", " I now have three paths I can explore", " I'm going to replace this first path", " Because I'm doing the first one as my option always", " I say I'm not at the goal, so zero has two children", " Zero, one, two-- so I'm going to replace that with that set of paths", " But you can see that I'm now caught in this problem", " And I really want to get out of that problem", " How do I deal with it? Well, I simply want to avoid visiting a node more than once in a particular path", " And I want to add that in a particular path", " If I'm walking down a path and I'm about to go to a node that I've already seen, that says I'm about to create a loop in my path", " And that doesn't make any sense", " I don't want to backtrack or retrace my steps in this particular path", " So as long as I avoid visiting a node more than once in a particular path, I'm set", " And I added that phrase because of course, different paths may go through the same node", " That's fine", " I just don't want to create a loop or a cycle in terms of what I'm going to do", ""], "kH_icrqrRzs": ["JOHN GUTTAG: Hello", " My name is John Guttag, and I will be delivering the next series of lectures in 6", "00X", " I have some good news", " We're pretty much done with introducing new aspects of Python", " You now know everything you need to know to write beautiful Python programs that do cool things", " That, of course, raises the question, what are we going to do for the rest of the course? Mostly, we are going to look at how you can use your programming skills to write programs that shed some light on complex situations", " The first series of lecture segments are about the visual presentation of data", " We will introduce you to a Python library, PyLab, that provides features that make it relatively easy to analyze data and present the results as plots", " We will cover only a small subset of what PyLab has to offer", " Other features will be introduced later in the course", ""], "OHsF77_yufc": ["NTA"], "AG8_Qw5kS_0": ["NTA"], "ZP_Q0vU-wU8": ["NTA"], "O1Is56hu4EU": ["Eric Grimson: We've just shown that if we have a sorted list, we can search it much more efficiently than just linear searching, and that's great", " But wait a minute", " How do I get a sorted list? What if my list is not sorted? What's the cost of sorting? Have I just kind of played a slick game on you here? So the question we want to ask is gee, is it better to actually sort a list, and then use the binary search to find things, or should I stick with linear search? So let's assume that the complexity of sorting a list is just something we'll call order of sort L", " We don't know what it is here in a second, but we'll come back to it", " So then what we're really asking is, if we sort and search, we want to know is the cost of both sorting and binary search, which is great, is that less than just doing straightforward linear search? In other words, is it better to sort and search, or should we just stick with the linear search? Well, if we don't know anything more, unfortunately the answer is it can't be better", " Because we can't possibly sort in less than linear time", " Why do we know that? Well, we've got to look at least each element of the list in order to sort them", " That says we've got to look at at least the length of the list", " So sort has to be at least linear", " And if that's the case, then sounds like it isn't better to do sorting before we do the search", " But that seems disappointing", " And in fact, it is because we're not completely taking into account everything that we want to do", " Suppose we want to actually search a list more than once", " We want to search it say, let's just say k times for some value k", " Then the question we want to ask is is the cost of sorting plus k searches less than the cost of just k linear searches? And you can already see it's going to depend on k and it's going to depend on sort, but one expects that if the sort can be done efficiently, then it is going to be better to sort first, and then search", " This is what we refer to as amortizing, or spreading out the cost", " We're spreading out the cost of sorting over multiple searches", " And doing something may well make this worthwhile", " So now the question is how efficiently can we sort? Because if we can do it well, we really may be better off using binary search", " And that takes us back to where we started, which is to say then we can reduce a lot of search problems just to a known solution, which is binary search", " OK, so let's look at sorting", " And we're going to look at two examples", " The first example is shown with a piece of code", " It's called selection sort", " And the idea behind it is pretty simple", " Given a list, we're going to find the smallest element in the list and swap it with the first element", " And then we're going to take the remainder of the list, find the smallest element of that, and swap it with the second element", " And just keep doing that until we've done the overall search", " So you can see that here", " I'm running a loop over the range of the list", " I start off saying that the location of the smallest thing is at i", " The minimum index is i, and the minimum value is the value of that point", " I'm going to start j at 1 more than i, and then I'm going to run a loop where I walk through the right hand side of the list, and I find basically the smallest element", " If the value at right here, at j is smaller than the smallest thing I've seen so far, which includes the thing I'm about to swap with initially, then I just change those things", " So this basically says find the smallest value in the right of i, or to the right of i, I should really say", " And when I've done that, I'll go ahead and run through that entire loop, then down here I just do a switch", " I'll have to be careful", " I'm going to temporarily hold onto the value at the ith location of the list using temp right there, So that I can take the thing at the minimum location, put it into i, and then take a temporary thing and put it there", " So this is a standard way of doing a switch", " I temporarily hold onto something, so I move into that location, and then the temporary thing and put it into that spot", " So you can see this is doing what's called selection search", " I find the smallest thing, I move it to the front, I find the next smallest thing, I move it to the next location, and I keep doing it", " OK, let's look at this", " First of all, let's analyze this selection sort", " And one of the things again, I'd like to know is to be able to determine does it really do the right thing? And I can do that by identifying what we'll call a looping variant, something we've seen before", " And the looping variant basically says here's a property that holds true at each stage through the loop", " And if I can do that, then I can reason about does it satisfy the base case, and does it satisfy that induction step of if it's true for a smaller version of the problem, is it true for the next version of the problem? And if I do that, then I can show that I'm done", " The loop invariant here is pretty straightforward", " It says given a prefix of the list, the first half of the list, and a suffix of the list, everything after the ith location, then the looping variant is going to be that every time I go through this loop, I'm going to claim that the prefix is sorted, and that there's no element in the prefix that's larger than the smallest element in the suffix", " That everything in the prefix is smaller than everything in the suffix", " OK, that's my looping variant", " Let's see if that holds true", " Well, in the base case, the prefix is just empty", " So it's trivially sorted", " The suffix is the whole list, and it's trivially the case that everything in the prefix is smaller than the smallest thing in the suffix", " OK, now what about the induction step? This basically says when I enter the recursive call, I'm assuming, or I know that the prefix is sorted", " So what does this say? The induction step says we're going to find the smallest element of the suffix and move it to the end of the prefix", " If the prefix was sorted beforehand, putting something that's larger than everything in it at the end, says the prefix is still sorted, and since I moved the smallest element, it says that there's nothing in the suffix that is smaller than anything in the prefix", " So the invariant was true before the move, the prefix was sorted after the move, and I've guaranteed that in fact, I've done the right move-in", " And when I exit, when I've gone all the way through all of this, what do I have? The prefix is the entire list, suffix is empty, so I'm guaranteed that the list is sorted", " Nice little induction proof that shows that I'm actually doing the right thing", " Great", " Now, what's the complexity? Well, what have I got? I've got two loops", " This inner loop down here, we already know from earlier versions how to estimate them", " The complexity of that is on the order of the length of the list", " Yes, the list gets smaller each time through, but basically it's the order of the length of the list, OK? So that's the inner loop", " What's the outer loop? Well, I go through the outer loop", " Basically order of the length of the list times", " So I'm doing something of order length of L, and I'm doing that order length of L times", " So the overall complexity here is quadratic", " It's length of the list squared, because I've got to through the list at least once, and I've got to do that the length of the list times", " And unfortunately, we know this is expensive", " It's not what we would like", " But it gives us a simple kind of sorting algorithm", " Now the question is, all right, if I just use selection sort, would I really want to use this compared to linear search? And the answer's probably not", " If it's quadratic to do the sort, and then I'm going to order log to do the search, the search is nice, but in general it's going to be way too expensive to do a quadratic thing as compared to a linear thing", " I need to know, can I do better?"], "bGWgqvhUfPU": ["NTA"], "LxI8Mko_MKs": ["In this seventh lecture, we're going to talk about testing and debugging", " While it would be great if we could always write correct code that ran the first time we tested it, things usually don't work out that well", " So we're going to talk about how to tests code to determine if it might have a bug", " Focusing on black box testing, where we exercise paths through the specification, and glass box testing where we exercise paths through the code", " We will also talk about techniques for debugging", " That is, isolating the location of bugs in our code", " In particular we will talk about treating debugging as a search process, and use the ideas of binary search to help isolate and detect bug sources", ""], "oNn-NRjBP2U": ["NTA"], "hX1aUXnDwgA": ["PROFESSOR: We've been looking at the idea of exhaustive search", " And we just saw, when we want to do this on things that don't have a finite number of choices, real value to floating point numbers, for example, we've got a problem", " We need to make the step size small in terms of how many different things we sample", " But as we keep making it smaller, it's going to make the search take longer and longer", " Because if we're going to do it, we're going to put a lot of effort into trying to find the right answer", " So we'd really like to have a way of having things still be very efficient, yet, find the answer we want", " And it turns out, for a lot of problems, we can do that using a wonderful idea called bisection search", " So what do we know? Let's go back to the idea of trying to find the square root", " We know that the square root of x lies somewhere between 0 and x", " We're assuming x is positive just to make life a little easier for us", " That's a mathematical fact", " Now, what we did was we said let's start with 0", " Then, 0 plus a little bit", " Then, 0 plus 2 times a little bit, and then 0 times 3 times a little bit, trying all of those examples, until we got to something that was close enough to the answer we wanted", " That's exhaustive", " Rather than doing that, suppose instead we say, look, we know that the square root of x is somewhere between 0 and x", " So let's just pick a guess right here in the middle", " Let's call that g", " Let's just pick the midpoint between 0 and x and try it", " Now, if we're lucky, the answer is close enough and then we're done", " That's unlikely", " But even if that is not the case, we have a good situation", " Even if we're not close enough, we can now ask was that guess g too big or too small? Well, if g^2 is bigger than x, then we know that it's too big", " We know that the square root has to lie somewhere between 0 and g", " And that says we can now instantly just focus on this portion", " Doing that, we can, again, take the midpoint of that", " Let's call it another version of g", " A new g", " And again, we can say, is that close enough? If not, is it too big or too small? For example, in this case let's assume that g^2 is less than x", " That says g is too small, and what does that say? It says, we know that the actual value has to lie somewhere between my new g and the previous g that I guessed", " And again, we can pick the midpoint and guess again", " If this works, and it does, this is really cool", " Because it says, at each stage of this bisection search I'm cutting in half the size of the range of values I have to look at", " We're bisecting them, which is why it's called that", " At each stage we reduce the range of values that we have to search by half", " And that is going to be really powerful", " Rather than just at each stage throwing away a little bit, we're cutting down the problem, a big portion, each time through", " So can we capture that idea? The answer is, sure, and it's not that hard to do", " Again, there's some code", " It looks a little bit daunting, but it's really not as bad as you think", " What does it say? It says, I'm going to have some value of x I'm going to start with", " OK, I'm going to pick an epsilon which is going to tell me how close I am, and I'm going to keep track of how many guesses I did as well", " I'm going to set up, initially, a low and high value, which are to start with 0 and the value of x", " That's my range where which I want to be trying to do the computation", " My answer is initially going to be the midpoint halfway between low and high", " And then, what do I do? I run through one of these little loops where, again, I basically say, am I close enough? If this is true, then I'm too far apart", " I'm not close enough", " And in that case, well, I'll print out some information that tells me where I currently am", " I'll change the number of guesses and I'm about to make a new guess", " And if I'm not close enough, what does it say to do? It says, if my current answer squared is less than x, I'm too small, and I'm going to change the lower end to be that guess", " I'm moving up the lower end", " On the other hand, if answered squared is bigger than x, then I'm too high and I'm going to reduce the high down to the answer", " And I'm just going to keep doing that", " If I keep doing that I'm going to keep chunking this thing in half, and having done either of those two pieces I then change my answer to gain the midpoint", " And I do this one more time", " So I'll just keep cycling through this, cutting in half each time, the size of the problem until I get to something that's close enough", " We hope", " OK, let's see what happens if we do it", " Here's some code in my IDLE system that has it", " It has exactly that", " Let's do this, basically, let's start with something simple which we said was going to be 25", " And let's see what happens if we evaluate that", " Oh, look what happens", " I start off, and let's look at that, I start off with a range between 0 and 25", " And the answers is the midpoint", " I then, cut down the high end", " I then, cut down the high end again", " I then, cut down the low end", " I then, cut down the low end", " And you can see at each stage it's reducing the range", " And after only 13 guesses I get a pretty good guess for what the square root of 25 is", " It's not exact", " I happen to know it's 5, but in only 13 guesses I got it", " Remember, last time we did 50,000 guesses to get to something that wasn't, in fact, much better", " In fact, it wasn't even as good as this guess", " So notice how it's cutting down the problem at each stage", " All right, let's go try this other version of this, right? 12345", " Let's see what happens if we find, using by section first, the square root of that", " We see it cranking along", " Wow, in 26 steps, it got to something that took a million steps the last time around", " In 26 steps it gets to a pretty good approximation", " Let's try something even bigger", " Let's see what happens if we do that one", " All right", " Again, you can see if you look at these numbers how quickly it's zeroing in", " In only 36 steps, it got to the square root of a pretty big number", " So in fact, this does it really well", " What can we observe out of this? Well, here are some things that we see", " First of all, bisection search radically reduces the computation time", " And this is part of that original message that it's not just having a fast computer", " It's being smart about how we think about solving the problem", " And in this case, being smart about how we generate the guess is going to be really important", " So when does this idea of bisection search work? Well, it should work well on problems where there's a sort of ordering property", " Meaning, that the value of the function being solved varies monotonically with the input value", " Another way of saying it is here the value I'm looking for is g**2", " Then, it grows as g grows", " And that says that there's this nice ordering of the solutions or the potential solutions, and so picking a midpoint gives me a good way of cutting the problem in half at each stage", " We're going to come back to this idea of bisection search throughout the term", " It's a really powerful tool, but you can already see how dramatically it reduces the computational cost", ""], "CqeyFtxCqqE": ["CHRIS TERMAN: Early programming languages didn't offer much support for structuring complex programs", " They gave local variables and global variables and not much else", " As programs became more complex, we needed to find a way to control which procedures could access which data", " Procedures that willy-nilly made access to whatever data they could get their hands on lead to hard to find bugs", " So we needed a more organized way", " And we came up with the idea of bundling data and the associated procedures into an object with a well defined interface", " Early object-oriented programming languages started appearing in the '60s and '70s", " And by the '90s, most programmers had adopted the object-oriented programming style because it was an efficient way to write and debug complex programming systems", " Over the next two lectures, we're going to explore Python support for object-oriented programming", " Python supports many different kinds of data", " There's integers, and floating point numbers, and strings, and lists, and dictionaries", " And you've been using these data structures as you've been writing your programs", " From a Python point of view, each of these is an object", " What, you ask, is an object? Well, objects have a type", " And a particular object is said to be an instance of a type", " So here's the type of all the objects above", " And one, two, three, four is an instance of type integer", " Why we introduce the notion of types is to that the behavior of an object is actually associated with the type", " In other words, how integers work when you add them together-- use the plus operator on them-- that's actually different with integers than it is for floats, or strings, or lists", " And so, associated with each type is the information that's needed to say how do I do a plus operation, for example? Associated with each object is an internal data representation", " Some objects, like integers and floats and strings, are primitive", " In other words, they hold some data and that's it", " They don't have much in the way of internal structure", " Other objects like lists and dictionaries are composite objects", " They actually are a collection of other objects in the system", " And they organize that collection in particularly convenient ways", " Finally, each object has a set of procedures for interacting with the object", " So for example, ints have a procedure for dealing with adding two ints together, and lists have a separate procedure for adding two lists together", " In the case of lists that means to concatenate them", " Let's look at this more closely", " So here's an example data object-- the list, one, two, three, four", " So the Python type of that data object is list", " There's an internal data representation", " And we have some choices to make as an implementer of list", " For example, we could store the components of a list in a little, sequential array of memory locations, each of which holds a pointer to an object and associate with that array, a particular length, l of the list", " In our particular example, the length would be four", " And so long as there's enough room in the array to store four elements, we're all set to go", " Alternatively, we might choose to store a list as a linked list of individual cells", " So we'd have a cell holding one, and a cell holding two, and a cell holding three, and a cell holding four", " And the other half of each cell would be a pointer to the next cell, so a little daisy chain of these cells, one for each element of the list", " Why would you choose one implementation over the other? Well, one of the considerations is what operations do you want to be efficient? For instance, suppose you wanted to take the length of the list", " Well in the top representation, the length is explicit", " It's actually stored as an integer as part of the internal data", " And when a user asks for the length of a list, just look up that integer and return it", " Very quick, very efficient", " If you ask for the length of the link list, you'd actually have to go down that list, counting as you go, to count the number of cells that have been linked together", " So the linked operation is very inexpensive with the top representation", " And more expensive with the bottom representation", " But now suppose that an important operation is inserting something at the beginning of a list", " With the array, we'd actually have to spend the time to copy all the elements in the array up one index", " And then we'd have room to drop the new object at the beginning of the array", " That is potentially an expensive operation", " We actually have to move everything around inside the internal data representation", " With a link list, we simply have to create a new cell and make the pointer in that first cell now point to the rest of the list", " So inserting at the beginning of a list is actually very simple with the second representation", " There's a struggle implementers go through when they choose internal representations", " They have to think about what they want to be efficient and what things they want to be easy", " The internal representation is meant to be private in the sense that users of the object shouldn't rely on any particular details", " So for example, a user should use some sort of procedure that's associated with a list to get its link", " They shouldn't assume that can reach in and grab an internal integer and simply use that as the length", " And so correct behavior of the objects might be compromised if you actually make some assumptions about the internal data", " Lists have a lot of procedures associated with them", " There's procedures for indexing into a list, or creating sub-lists for concatenating or replicating the list", " That's the plus and the star", " We can ask many things about the list", " We can find the minimum element", " We can search for a particular element", " We can ask for the length of the list", " We can remove elements from the list, so forth and so on", " So all the behaviors that are available to the programmer are really described by this list of procedures", " And the procedures know about the internal data representation", " But a user of lists should restrict themselves to the functionality provided by the operators and procedures", " Let's pop up a level and talk about object-oriented programming in general", " Object-oriented programming is sort of affectionately known as OOP", " Oop", " First off, in an object-oriented programming view of the world, everything is an object and has a type", " For example, the presentation that you're watching would be represented as an object", " And somewhere inside of its internal representation would be a list of slide objects, one for each slide in the presentation", " And each slide object would have internally, perhaps, a list of text boxes that represent each of the little groups of text on the slide, so forth and so on", " So what we've done is to break a fairly complicated idea of a presentation down into this hierarchy of objects, which sort of makes it a little simpler to, sort of, think about how to actually organize the program that produces presentations", " Objects are a data abstraction that encapsulate an internal representation in an interface for interacting with the object", " So remember that the interface defines behaviors", " For instance, length or display on screen, or something like that", " But the details are hidden inside the actual implementation that lies behind the interface", " The way you interact with the object is simply to ask the appropriate piece of the interface to perform the desired operation", " In Python, the interface is actually represented as a set of attributes", " And there's a data attributes and procedural attributes, which we give the special name to of methods", " Some languages have support for data hiding, which prevents access to private attributes", " So in implementing behavior, some of the attributes may be intended for public consumption and other attributes may actually only be for the internal use of the implementation", " In some languages, you can declare some attributes private and others public", " Python doesn't have that distinction", " So when you read a particular type of object, you will get a list of things that you're allowed to do-- attributes you're allowed to use", " And so, you're just expected to play by the rules, even if you know something more about other attributes that might be available", " Of course, one can create new instances of objects, either explicitly-- and we'll show you how to do that in a minute-- or often using literals", " So when I typed in the text, one, two, three, four, in my Python program, the Python interpreter knows how to take those characters and convert them into an integer object", " And we can destroy objects", " We can destroy them explicitly using the delete operation in Python, or we can just forget about them", " We can sort of lose our handle to them", " So if we say a equals some list, and then later, on we say a equals some other list, that first list disappeared", " In other words, it used to be the value of a and that's how it got to it", " But now that the value of a has changed, we can no longer get to that old list", " So Python system will actually reclaim destroyed or inaccessible objects", " It will go take that first list and return it back to its storage pool since no one can actually access it anymore", " And that process, quite appropriately, is called garbage collection", " What are the advantages of object-oriented programming? I suggest you actually Google for advantages of OOP", " You'll find a bunch of very interesting articles that describe why object-oriented programming has taken the programming world by storm", " Here's some thoughts that I have", " It provides a way of doing divide and conquer development", " What I can do is to go off and implement and test the behavior of each of my classes of objects individually", " So I can think about when I, for instance, implementing presentation program, I can think about as the presentation as a collection of slides", " And I'll think of making an actual slide show as sort of going through and displaying each slide individually, one at a time", " And then, each slide, when it's asked to display itself, might go through and say to each text box, please display yourself at your location on the screen", " What I can do is work, sort of, from the bottom up of implementing the display of text boxes, and then a display of slides, and finally the display of the entire presentation", " And I can work on each of those behaviors separately, assuming that the other behaviors have been implemented correctly", " So this increases the modularity and really reduces the complexity", " The complexity of doing a slide show from the presentation point of view really is as simple as individually presenting each of the slides in turn", " So classes make it easy to reuse code", " And, in fact, many of the Python modules you've been using, really the way they deliver the functionality is they define new classes, and all the methods, and internal data that they have, and you basically, interface with those classes to access the functionality implemented by the module", " Each class has a separate name space", " So there's no collision on function names", " I don't have to have a separate procedure called integer plus and list plus", " I can basically look inside a class and say please use your plus procedure", " And that's completely a unique way of specifying which plus I need", " And finally, inheritance allowed sub-classes-- which we'll meet in a minute-- to refine or extend a selected subset of a superclass' behavior", " What I'll be able to do is to say, look, I want to design a special MIT presentation, which is just like a normal presentation but has a little MIT symbol in the bottom left-hand corner", " So I can change one aspect of, for instance, the display routine to build that extra piece of functionality in", " But I can inherit all the functionality that's inherent in the base presentation code to do slide shows, so forth and so on", ""], "oGvdcAgHYxA": ["JOHN GUTTAG: At the end of the previous segment, I promised that in this segment we would address the question of how much is enough", " Now, I know that's a deep philosophical question, and I hope you're not going to be disappointed when I tell you that's really not what I want to talk about", " Instead, I want to talk about a much simpler question", " How many samples do we need to look at in order to have a justified confidence that something that is true about the samples is also true about the population from which the samples were drawn? This is always an important question when we look at any statistical measure because, as we've seen before, the samples might or might not be representative of the entire population", " The number of samples we need will depend upon the underlying variance in the distribution from which we are drawing the samples", " Now, of course, unfortunately, we don't get to see the underlying distribution", " We only get to see the samples", " So we have to turn this into a question about the samples", " So let's look at the variance that we can measure by looking at the samples", " Essentially, what we do is we run multiple trials getting different outcomes", " And then we look at the variance in the outcomes of those trials", " That's the reason that when we started looking at these simulations we always ran multiple trials, rather than say, in the case of coin flipping, just flip more coins", " Actually, we did just flip more coins, but that really wasn't the right thing to do when we did it", " All right", " Now, let's look at how we can formalize this notion of variance in the outcomes", " We do that using a notion you've all seen before", " Anyone who's taken an exam has been told, here is the average, here is the standard deviation", " And effectively, what the standard deviation is telling us is how many values are close to the mean", " If many values are close to the mean, then the standard deviation is small", " If the values are far from the mean, the standard deviation will be large", " Looking at this a bit more carefully, we can define the standard deviation, typically written as sigma, of some set of results, written in this case as big X, as the square root of 1 over the cardinality of X-- that's the number of samples we've drawn or the number of trials-- multiplied by the summation over all the little x's in the big X of (x - mu)^2 , where mu is equal to the mean", " So if you think of it, this make sense", " We take the differences between the samples in the mean, square them", " And that means that we don't have to care whether the differences are negative or positive", " And then divide them by the number of trials, and then take the square root of the result", " For those of you who prefer code to formulas, here's a simple implementation of standard deviation", " We take the mean by summing X, divide it by the float of the length of X, and then we simply iterate through X summing up the squares, the differences, and then dividing it by the length and taking the square root", " Exactly what the formula said", " We can use the notion of standard deviation to think about the relationship between the number of samples we've looked at and how much confidence we should have in the answer we've computed", " Let's now look at some code that does that", " And we'll look at it only very briefly because it's so similar to code we've looked at before", " Once again, I have something called flip-flop", " Whoop! I always say flip-flop", " I should say, once again we have something called flipPlot ", " As before, it will take a minimum and a maximum exponent", " But this time, since we want to look at the standard deviation over multiple trials, we also pass in a number of trials", " And just to emphasize the fact that we're doing multiple trials, I've factored a single trial out into a separate function of the number of flips", " Other than that, there's really nothing very interesting to look at in this code", " It looks almost exactly the same as the code we've looked at before", " So let's run it and see what we get", " Once again, we'll vary the exponents from 4 to 20", " And then we'll also do 20 trials", " OK, let's go over to the PowerPoint here now and look at the results", " First of all, we're plotting the mean of the number of heads over the tails, the head/tails ratio, for the 20 trials", " As before, we can see we have some variations with a small number of flips, and then it stabilizes right around 1", " Now we're going to see something that we didn't look at before, the standard deviations", " Notice here as we increase the number of flips, the standard deviations drops dramatically", " In fact, it's dropping linearly", " Notice that both the x and the y-axis are logarithmic", " So the fact that this is almost a straight line suggests that in fact they're dropping linearly", " And by the time we get to 10 to the 6th flips, the standard deviation of the 20 trials is about 10 ^ -3", " Since we know that the ratio is around 1, we see that standard deviation is considerably smaller than the mean", " That gives us every reason to believe that the result we have is a good one", " Now let's look at the main differences we've looked at before", " But again, we're looking at the mean of the 20 trials", " As expected, the absolute difference between the numbers of heads and tails grows with the number of flips", " However, since we're averaging the results over 20 trials, this is considerably smoother than the plot we looked at before when we only did one trial", " Now let's look at the standard deviation of the absolute difference", " Well, this might seem a little puzzling, because it looks like, as we increase the number of flips, the standard deviation of the absolute difference is increasing", " Well, it not only looks like it is, but it is", " Does this mean that as the number flips increases, we should have less rather than more confidence in the estimate of the expected value of the difference between heads and tails? No, it doesn't", " What's going on is the standard deviation should always be viewed in the context of the mean", " After all, if the mean were a billion and the standard deviation 100, we would view the dispersion of the data as small", " On the other hand, if the mean were 100 and the standard deviation were 100, we would view the dispersion as enormous", " So you'll recall that as we increase the number of flips, the number of absolute difference got much larger", " Again, it's a logarithmic axis here", " And so it's not at all surprising that the standard deviation should get larger", " The lesson here is that we really should not be using standard deviation to compare different tests where the means are very different", " There's another statistical measure we use for that, and we'll cover that measure in the next segment", ""], "YdT6gL3Cpss": ["PROFESSOR: One of our motivations for developing a mathematical model of the phenomenon we're studying is so we can make predictions", " Often they're experiments that are either very difficult to do or even dangerous", " Suppose you wanted to know what will happen if a nuclear reactor lost all of its coolant", " Well that's not an experiment we really want to run, so instead we want to develop models that will let us make predictions of what will happen so that we can do the appropriate engineering", " Suppose someone came to you, as an expert, now, in the trajectory of arrows, and said, how thick a shield would I need in order to protect myself from an archery attack? Let's see if we can use the measurements that we took in the previous segment and help answer that question", " So how would we use the model in order to make a prediction of the thickness of the shield? And it's nice to use the model because there are times when experiments are sort of impractical or inadvisable", " So standing up with a thin shield and having somebody shoot arrows at you might be a very bad idea because the shield might not do what it should", " And somebody says, aha, it needs to be thicker, but it might be too late for the participants in the experiment", " So what we want to do is to figure out how to use our model, now, that we have for the trajectory of an arrow, and see if we can deduce the information we need", " So we want to know the speed of the arrow as it reaches the target because a combination of the speed of the arrow and the mass should tell us a little bit about how thick the shield really needs to be", " Well, sadly, we didn't measure-- did we measure it? So no, unfortunately we didn't measure the speed", " But can we deduce it from the model? So what we want to do is, using the data that we got from curve fitting, can we deduce the speed is the arrow as it reaches the target? So I modified the code a little bit to print out the values for a, b, and c for the parabolic fit", " And these are the values that polyfit gave us back that describe the parabola that match the-- was able to predict the trajectory so well", " And so I've written that out as an equation here that gives us the height above the launch point as a function of the distance", " So this is the distance, x, and this is the height, y, here", " OK, so can we deduce the speed of the arrow? So that's our task here", " So the first thing I'm going to do is to determine the highest point in the trajectory", " So I want to determine the peak value of y", " And what I notice is that the peak value of y sort of happens midway through the trajectory from the bow down to the target", " And so this guy is at 1080 inches", " And so that means that the midpoint here, ypeak, so this is going to be ypeak here", " The midpoint occurs at distance equal to 504 inches, which is exactly halfway between the bow and the target", " So I can actually plug that in here", " So if I can go use my mathematical model now to compute ypeak, and plugging in x equals 504, and doing the arithmetic I'm going to end up with ypeak being 21 inches, which is 0", "53 meters", " OK", " So my next step is to figure out the time it takes the arrow to fall from its peak all the way down to the target", " So as the arrow is falling here, as the arrow is falling from its peak down to the target, the thing I'll observe is that's completely-- that the acceleration in that direction is happening completely because of the force of gravity on the arrow", " And so time for arrow to fall from ypeak down to 0", " And so we know from sort of our Newtonian physics that distance equals one half at squared", " And using that, I can sort of solve for t", " And that's going to be the square root of twice the distance-- so twice ypeak", " And the acceleration due to gravity is g", " And so if I go off and do that computation I discovered it t equals 0", "326 seconds", " So that's the amount of time it takes the arrow to travel from here to here in terms of time", " So this time is equal to 0", "326 seconds", " And the distance I'm traveling is from here to here, which is 504 inches from the midpoint to the target", " So, let's see", " So the speed now-- so now we can just quickly do the speed", " OK", " And so that's 540 inches is the distance in 0", "326 seconds", " And so if I do a little arithmetic that's 138", "2 feet per second", " Well, I'm a little nervous about the-- I can compute with lots of precision", " I can do the arithmetic to lots and lots of decimal places, not clear how accurate that is given the errors in the measurements and stuff", " So maybe it would be safer to say it's somewhere around 135 feet per second", " And we'll leave it at that", " So what we've done here is to show with a bunch of-- once we have a curve fitted model, we can actually derive implications of that model and help us with some measure-- determine some measurements, predict some measurements that we didn't actually need to go take", " This brings us to the end of our brief glimpse about how to use computation to process and understand our data", " If data crunching is in your future, you might want to learn much more about statistics", " It's the study of how to correctly process data and learn what it has to tell us", " I encourage you to learn more about the statistical tools that are available in Pylab", ""], "CZ-pBiV9c1c": ["NTA"], "wq8v7M3Szr0": ["We've now seen a lot of things dealing with functions", " They're going to be a really powerful tool for us", " And let's deal with one last topic", " We'll come back to it in more detail later on, but it's useful to highlight now", " And that builds on the idea that if functions help capture modularity, they help capture computations that are useful in multiple places, this also suggests that it can be useful to group functions together that share a common theme", " To capture them in something that sort of builds them into an element that has a lot of coherence to it", " And one way we can do that is to put functions dealing with a common theme into a single Python file, a ", "py file", " And if we do that, then we can import those functions, that file, into computations using the Import command", " And let me show you an example of that", " Here's some code that I could write that deals with some simple geometry", " So I've got a value for pi", " I've got a way of computing the area of a circle, circumference of a circle", " I could do the same thing with surfaces of spheres and volumes of spheres", " These computations that kind of mash together with one another", " And imagine I saved this away into a file that I call circle", "py", " And I've in fact got it loaded up ready to go", " What I'd like to do is to say, so how would I use this? And the way I use it is that I simply, whether in a Python shell or in another file, say, let me import things in", " So in particular, I'm going to go over here and start up my Python", " And I am going to type in Import Circle", " And that has now brought in the functions that I've defined there", " So I can define pi to have a really simple value, which I know is not true", " And if I say what's the value of pi, it prints out that", " But if I say, so what is the value of pi that is stored in the circle file? Aha! And so this notation right here, this dot notation, helps me specify that", " The dot basically says from the context circle, import the variable pi", " Or similarly, from the context circle, import that variable area, which is a function, and use it", " So I can, for example, say, give me circle", "area of, I don't know, three", " And it brings in from the circle context the definition of area that I created when I actually stored it away inside of that file", " So we'll come back to the dot notation, but it in essence lets us create modules with commonality to them and import things from them in a way that lets us use them very nicely", " One way to do it is to simply say Import from circle", " And every time I want to use something from that file, I need to specify it using that kind of a definition", " There's another way I can do it, which is to say from circle, from that context, just import everything", " Let's see what happens if I do that", " So I'm going to go back over here and I'm going to say From circle, Import everything", " I'm going to define pi again to be something simple, like 3", "0", " Actually, I'll make it even dumber", " Let's say it's 0", "0", " And if I say, what's the value of pi? Ah, now I've gotten it in terms of that version", " But if I say give me the area, it will get the area that was created from circle", " If I say I want the value of pi from circle, I can specify it", " So this version of Import basically says bring into my environment all the things from circle", " If there is no binding in my environment, I will look it up from circle, but I don't have to specify it, which is why I could just say area", " But I can also make changes in this environment, overriding what I saw in circle, such as this one, where I defined pi to have the particular value that I said I wanted to have", " That tool basically gives us a way to bring modules captured together into our computation", " And we're going to come back to that later on in the term", ""], "FQI929r5TTs": ["NTA"], "sLycGWeSwPE": ["NTA"], "NnWd5_X3n5s": ["ERIC GRIMSON: We just showed you a recursive algorithm", " You may be a little worried about it", " You may be going, OK, but how does it know which values of the variables to use? Because I'm not seeing any explicit changes to those values", " How does it make sure it really stops? Why doesn't it just keep unwinding? Didn't your high school geometry teacher never to use definitions where you defined a term in terms of itself", " Good news is not to worry", " And we've got a tool to help us understand that", " Let's go back and simply look at a simple call to recurMul, recursive multiplication, using that set of environments to see how computation flows", " So here's my code, I've just got a copy of it here", " And in particular, if I evaluate this, or load this if you like, into a Python environment, a shell, we know what's going to happen", " Which is we're going to create a frame over here, in which that name, recurMul, is bound to a procedure object", " And it's got inside of it both the parameter list and the body, the set of things it's supposed to do", " OK, let's see what would happen if we actually called it", " So let's call it", " Calling it says, I am going to evaluate this expression down here", " And I'm going to first get the value of recurMul", " I know what that is", " It's given by that pointer there", " It's a procedure object", " And so I know that calling it says I'm going to create a new environment", " It's going to inherit, or have as a parent, the same environment that the procedure has, the environment that was in place when we defined the procedure", " So it was going to point to that frame", " And inside of there, first I'm going to get the values of these two expressions, and I'm going to then bind the parameters of the procedure to those values", " All right", " I'm saying it in a long winded way, but you've seen this before", " We've now created a new environment in which a is bound to 2 and b is bound to 3", " And relative to that environment we're going to evaluate the body of this procedure", " OK", " Let's start evaluating the body", " The body says is b equal to 1", " No it isn't", " It's 3", " So it's going to go to the else clause", " And the else clause says, I'm going to return a value", " Great", " I'm going to get a value back", " And it says the value is going to be the value of a", " Remember I'm doing it relative to this frame here so I know the value of a", " It's 2", " And I'm going to add to a the value of the recursive call, another call to recurMul, with different arguments", " Now think of this very straightforwardly", " This is Python", " This is an interpreter", " That's an expression", " It says to get the value of that expression, what do I need to do? You need to get the value of recurMul, oh that's it up here", " OK", " Now, I need to get the value of a", " And remember I'm doing it all with respect to this, and in fact I should have done that better", " To get the value of recurMul with respect to this environment, I'm going to go up and find it there since it's not bound down here", " I need to get the value of a", " There it is", " And I need to get the value of b minus 1", " Well that's easy", " There's b, and subtract 1 from it", " And since recurMul is a procedure, what am I going to do? I'm going to create a new frame", " Cool", " That's exactly what I want", " Because now I've got a computation that's taking place with respect to this frame", " And how did I set that up? Well I got the value of a", " I got the value of b minus 1 from here", " I've bound those in this procedure because that's what it tells me to do", " And I'm now saying, evaluate this procedure in this frame", " Remember, when I get the value of this I'm going to give it back to this frame to complete that addition", " But I've now reduced this to simpler computation", " Notice something else really nice", " You may have been saying, well, how do I keep track of my iteration variable? It's not really iteration, it's recursion", " But notice I've reduced b", " And that's exactly what's going to happen", " I'm going to keep unwinding this computation until I ground that out", " OK", " We're now in pretty good shape", " Because what do we want to do? It says I need to get the value of this procedure, this body, this body here, with respect to this environment", " What do I do? Well, let's say is b in this environment equal to 1? No it is not", " So I'm going to return the value of a from this environment, which is right there, to another procedure call", " I'm doing another procedure call on recurMul", " What do I do? From here, I get the value of recurMul", " And I trace up that chain to say, there it is, it's that procedure", " I need to get the value of a in this environment", " That's easy", " And I need to get b minus 1 in this environment", " Well, that's easy, as well", " B here is 2, I subtract 1, and that leads naturally to yet another recursive call", " Now, you're going to be glad I only did this with 2 and 3, and not 2 and 57", " But you get the idea", " I am now evaluating the body of this procedure with respect to this environment", " What do I do? I say, OK, is b equal to 1? Thank God, it is", " But if b is equal to 1, what do I do? I return the value of a from this environment", " So that computation gives me back a 2", " That's really nice", " Because what does that say? It says, gee, here's where I am", " I'm now returning the value of a because I was in that recursive call", " It says the value of this recursive call is 2", " I'm going to give it back to the place that was waiting for it, which was up here", " And what was I doing? I was waiting to get the recursive value", " I want to add that to a", " So the 2 is returned", " It gets passed back up here", " It gets added to that a", " Those two pieces come to there", " And what was that doing? That was saying, give me a return of those two values to the computation that was waiting here", " So, in fact, the 4 and the 2 get added together to give me 6", " And what was that doing? It says, I'm now done because that procedure said return that value as the overall value", " And that's going to get passed back up as the final value", " Cool", " A little slow in our computation but really cool", " And, in particular, let's see what we can deduce from this", " Each recursive call of a function creates its own environment, with a local scoping of variables", " So evaluating the body of the function in that environment is going to be very clear as to which value of a and b it's using, or any other variable that it's using", " Secondly, the bindings for variables in each frame are distinct", " And you saw that", " I had a different frame for each one of them", " And those bindings are not changed when we're doing the recursive call", " They are set up as we make the call", " That is, I'm going to compute a new value of b, making it in this case b minus 1, in order to bind it in the frame", " But I'm not changing bindings in other frames when I'm within one frame", " I don't have access to them", " And finally we can see that the flow of control can naturally pass back to an earlier frame once the function call returns its value", " So, finally, you can also see that inherently this recursive call to a function, if done right, has the equivalent of reducing a state variable", " We saw how each instance, each frame, had a different value of b, that got smaller and smaller until we got down to the base case", " So we know that this is, in fact, going to ground out", " It's going to complete its computation", " That's great", " So hopefully this gives you a better sense of how, in fact, the rules of evaluation allow a recursive thinking of a problem to create a very nice version of the code", ""], "oMr9PpDodl8": ["does different types of mortgage calculations", " Our goal isn't so much to teach you about mortgages, but to show you how to structure the code, and in particular, to try to take advantage of earlier code that we write", " So for example, after we've written the code that supports the calculations for a fixed-rate mortgage, the code that does the calculation for a fixed-rate mortgage with upfront points is very similar, and we want to build on the code that we wrote", " Classes are a convenient way to tackle many programming problems", " For example, let's do a mortgage calculation", " Suppose I want to borrow $200,000 from the bank and pay it back over 30 years", " The bank has given me three options", " A 30-year fixed rate mortgage of 7% per year, or they will let me pay some amount of upfront money, called points-- in this case $7,000-- in which case, they'll give me a 30-year fixed rate mortgage of 5%", " Or for four years, they'll let me pay a low interest rate, but then their rate will almost double for the remaining 26 years of the mortgage", " What I'd like to do is figure out, what's the best deal for me? Let's write a program to tackle that idea", " Here's our program", " We went out to the web to find the formula we can use to compute the monthly payment for a mortgage of size loan at a monthly rate of r for n months", " So we embedded that in a little formula that we'll use below", " We created a base class that we're going to use for all the mortgages", " What the base class does is support the basic operation of a mortgage, and then the details of the exact interest rates and payments and things like that will describe it for each mortgage separately", " So the mortgage base class remembers the principal amount of the loan, and it computes the monthly percentage rate from the annual interest rate that was passed in", " It remembers the total number of months for the loan", " It keeps a list of all the payments that have been made", " And initially, nothing has been made", " The amount that's owed is computed each month", " So we start off owing the entire amount of the loan", " We precompute the monthly payment using the formula from above", " And we define a legend which we'll be using down here when the mortgage is asked to print itself off", " And we'll define that instance variable now in each of the particular subclasses that we'll define", " The mortgage supports the basic operation of making a monthly payment", " So what we do is we take the precomputed monthly payment and we add it to the end of the list of payments that we've made", " We then have to compute the amount of the payment, which is going towards reducing the principal amount of the loan", " So we take the principal amount that's currently outstanding and multiply it by the current monthly interest rate", " That tells us how much of our payment is owed in interest", " The remainder of that payment, then, is used to reduce the outstanding principal", " So at the end of each month, after we've made our payment, we can compute the new amount owed by taking the old amount owed and subtracting from it the reduction in principle from our payment", " Finally, we support the notion of figuring out what the mortgage has cost us through all the currently made monthly payments by summing up all the payments that we've made to date", " OK", " So here are the three types of mortgages we want to do", " One is a fixed mortgage, which is really exactly what the mortgage base class implements", " So we simply make a subclass of the mortgage base class and go off and initialize it with the parameters of the fixed rate loan, and provide a legend that describes the loan", " A fixed with points-- so that's where we did an upfront payment-- really is just like fixed", " So in fact we've made it a subclass of the fixed rate mortgage", " And the only distinction is that we have an initial payment up front that is some percentage of the loan", " In this case, we pass in the number of points-- in this case, 3", "5 which we used to calculate the initial payment", " And then after that, the mortgage works just as before, except hopefully the interest rate here will be lower", " And we have a different legend here which starts off with whatever value was defined for the legend by the fixed rate superclass", " And then we add to that an annotation indicating the number of upfront points", " And finally we have a two-rate mortgage, where the mortgage changes rates from the teaser rate after a certain number of months", " It will actually then increase to a larger rate", " So what we do is remember all the different parameters", " We have two mortgage rates in the initial term of the cheaper rate", " We have a more complicated legend explaining the mortgage name", " And then finally we look at the makePayment thing", " And so what we've done is we override the makePayment method of the Mortgage base class, because we have a more complicated thing we need to do", " So initially, we're going to go off and set up the mortgage to be being paid off at the teaser rate, as if we had gotten a 5% loan", " So we'll have a low monthly payment because the teaser rate is lower than the final long-term rate", " So once we've paid that number of monthly payments-- the number of teaser months, in this case 48-- what we're going to do is to say, aha, now we're going to up the rate to this new higher percentage rate, and we'll recalculate the payment based on the amount of the outstanding principal that's still left", " And at that point, once we've made that adjustment, which we do at the 49th month, we go off and now just use the standard payment algorithm", " It's just that the payment algorithm works with different parameters from the 49th month and beyond", " So now we're in a position to actually do some comparisons", " And again, we've gone off and embedded our little mortgage reporting thing inside a function, so that we can actually try many different experiments with the different options", " So what we do is we create some alternative mortgages", " We create a fixed rate mortgage, the fixed rate with points, and the two-rate mortgage based on the parameters that get passed in", " And finally we run the experiment, where we're going to make 30 years worth of payments on a monthly basis", " And for each of the mortgages in our little list of sample mortgages-- so the fixed rate, the fixed rate with points, and the two-rate mortgage-- we're going to make a monthly payment", " In this case, a total of 30 years of payments on each of the mortgages", " And finally, when we're done, we're going to report back the results", " So the advantage, instead of filling a couple napkins full of calculations-- by putting it into a program, we'll get to run many experiments in a row", " All right", " So this is the experiment that we want to run", " We actually have the description of the problem we were facing", " So I'm going to come over here and paste that in, and then ask Python to print out the answers", " And we can see that if we have a fixed rate mortgage, we pay a total of about $479,000", " A fixed rate with the upfront points was about a little over $390,000", " And then the two-rate mortgage, or the adjustable rate mortgage-- you can see here the total is $551,000", " So the best deal by almost $100,000 is the fixed-rate with points", " Well, we're not so much trying to teach you about mortgages", " Our real goal in going through this example was to sort of point out that we can do a lot of code reuse here in describing the operation of the different mortgages, by starting with a mortgage base class which describes the operation of a fixed rate mortgage, and then elaborating on that either with an upfront payment, and hopefully a lower interest rate, or a fixed rate mortgage where the rate changes some number of months into the thing", " And so we've basically encapsulated the distinctions of our different mortgages from a regular base fixed rate mortgage in each of our different classes", ""], "0bdP3Muy_kU": ["It's a technique for finding solutions to graph optimization problems, finding shortest paths through a graph or anything that we can represent as a graph", " And it's one way of, in fact, exploring the space", " There's an alternative also very common called breadth first search", " And the difference is very simple", " In depth first search, if you think of the tree of possibilities we're always exploring things as deeply as we can, taking any path and trying to extend it before we go back and look at other paths", " Instead of always going down the first branch of the tree, we could, instead, explore all the children of a node first before moving on", " So, for example, we can look at all of the paths of length 1 and then all of the paths of length 2", " And that idea is very simple", " It says, given a node, we're going to look at each of its children and look at all of those paths", " So, going here then there then there then there", " If none of those work, then we'll go over here and look at all of the extensions", " So, we're going to explore this tree if you like breadth first rather than depth first", " In the simple case of having no weight where we're simply looking for the shortest path in terms of number of steps, we can stop as soon as we find a solution since it's guaranteed to be a shortest path", " Great", " How might this look? Well, the overall description is much the same", " We start at the root node as before", " In this case, a set of possible paths is just that node", " If we're not already at the solution, we're going to take the current path, and we're going to look at extending it by adding each child of that note to the path, unless the child is already in the path, we'll avoid the loops", " The only difference is that we're going to add these new paths, but we're going to put them at the end of the set of options rather than at the beginning, very simple difference", " In fact, we're using a different data structure, a data structure called the queue", " But with that simple difference, the rest of this works exactly as before", " So, the difference is we take the next option, we look at all the plausible paths that extend it to its children, avoiding loops", " But rather than putting those onto the front of what was a stack, we're going to put them at the end of what we now call a queue", " So, quickly, about a queue then", " Again, it's a different kind of data structure", " It has what we call the first in, first out behavior", " The first thing we put in is the first thing we take out or another way of saying is we're always going to put things in at the end of the queue and take them off the front", " Which means that things get looked at in the order in which they were placed into that data structure", " We refer to things as being pushed to the end of the queue and popping off the front of the queue", " Very simple change", " Let's just sort of conceptionally look at the difference now in what happens with my search if I'm now doing breadth first search", " Here, I start off at node 0 from node 0, I know there are two possible extensions", " So, let's just look at the nodes we visit", " We're going to go first to node 01 and then to node 02", " Since neither of those has found the solution, we've now explored all the paths of length 1, we're going to go back to this node and look at extensions there avoiding loops so we cut that off but now looking at the path 012", " Since there are no more paths of length 2 off of node 1, we'll carry on and look at 023 and then 024", " And, again, having now explored all the paths of length 2, we'll go back to the beginning and look at extensions of length 3, letting us look at 0123 and 124", " Then moving on to 0234 and, nice, to 0235, we've now found the solution", " And we know we can stop because any other solution is either at this level, meaning of the same length, or deeper down in the tree, meaning it's longer", " So, we can stop", " Great", " Let's just look then at, going back to our search, how that data structure of the queue deals with it", " We start off with the queue just being of the element 0", " We pop it off and insert into it the two extensions which were 01 and 02", " They get put at the back of the queue, but in this case, the queue was empty", " And then we pop this off", " And we take its extension which is 012, and notice, we put it at the back of the queue", " That's different from what we had before", " We then examine this", " We pop that off", " It's got two extensions and, notice, those get put at the back of the queue", " So that this now moves up to the front of queue", " And we keep going", " And that extension, or that variation, rather, of putting things at the end of the data structure rather than at the beginning gives us a different exploration of the space", " What does the code look like? A little bit different, but still fairly easy to follow", " Again, we're going to give it a graph, a start node, an end node", " And we're going to give it a data structure, we're just going to, out of a bad pun kind of sense, call it a queue", " Our first path just is the path from the node's start", " And we're going to put that onto the queue", " And since we're representing the queue in this case as a list, we're just going to append it, put it at the end", " Great", " Now what we do? We say well, if there's still something in the queue to look at, I can keep going", " If there isn't, then I'm done, and I'm stuck, I'm going to return no answer", " If there is still something in the queue, I'm going to get the first thing off of the queue", " There's a pop operation, and it just takes it from element 0 and moves it out", " And I'm going to call that 10 path", " That's the path at the beginning of the queue", " I'm going to get the last node in that path by just indexing into it to get the last element of the path", " I'm going to print out some information here, which is no big deal", " And then what do I do? I say look, if that node is the thing I'm looking for, I'm done", " Just return the path", " Wonderful", " If it's not, if I've still got something to go, so, I've got a node up here, and I'm down to this node, and it's still not to the goal node that I want, what do I do? I'm going to take the node I'm currently at, this one", " I'm going to get all of its children, and for each one of those, I'm first going to make sure that it's in fact something I can keep exploring", " It's not already in the path", " And if it's not in the path, I'm going to create a new path that says go from there to each of the children in turn", " And, oh, just put those at the end of the queue", " Wonderful", " With that change that has added those new paths into the queue and having done that, I'm going to be able to cycle back around because notice that I'm not yet done", " And I'm going to pick up the next element of the queue and keep going", " Straightforward algorithm, you could run it yourself to try", " But it leads to a different exploration of the space", " And that's a really valuable thing", ""], "5DgYyaBb21k": ["NTA"], "lTnTlmM33dA": ["NTA"], "--7OF8BOElA": ["ERIC GRIMSON: Before we leave the topic of complexity, I want to do one last thing", " I want to give you a visual way of getting a sense of how different these different complexity classes are", " Because you might say, does it really matter if our code is quadratic verses linear, or log-linear versus linear, or linear versus log? And of course it depends on the size of the problem, of the particular instance of the problem", " But for large-scale problems, the complexity of the worst case can make a really big difference, and I want to give you a sense of that", " So just to do that, let's take a look", " What's the difference between a constant logarithm and a logarithmic one? So what I've graphed here is the amount of time it takes for an algorithm and this is constant that has 20 steps, versus a logarithmic algorithm that has only 1 step within its loop", " And notice, it takes an argument of size almost 1,000,000 before the logarithmic algorithm actually catches up to the constant one", " Of course, if the log algorithm had 20 steps, it would scale up beyond this", " But this is really a way of saying, log algorithms grow incredibly slowly in complexity, and therefore they are really powerful", " And in many cases, they're almost as good as a constant time algorithm", " Log grows slowly", " Log algorithms are great things if you can find them", " They're not easy to find, but when they are, they are really great", " OK", " Now let's move up that chain", " What about the difference between a logarithmic algorithm and a linear one? Well, this difference is big", " That blue line at the bottom is a logarithmic algorithm, or a logarithmic function, if you like, and the green line, of course, is the linear one", " And you can see that the linear one starts to very rapidly outstrip the logarithmic one", " And again, the obvious observation here is that logarithmic clearly is better for large-scale problems than linear ones", " Doesn't imply linear is bad-- it just says that log grows so much more slowly", " If we can find a log algorithm, we would really like one", " Let's move up the chain", " Linear verses log-linear ", " And of course, we know that they're going to get worse, But here you can see that it doesn't grow as badly as you might have expected", " There's the linear algorithm in blue, down here, this one", " Here's log linear one", " And it's growing, but the growth isn't horrible", " And as a consequence, what this says is that while log n may grow slowly, when it's multiplied by linear factors, the growth is much more than just the pure linear, but they're still quite valuable, because the growth isn't getting badly out of hand", " All right", " So we're seeing each one of these things has a little bit more of a growth", " Let's look at another one here", " Log-linear versus quadratic", " Here you can see that the growth is actually going up much more rapidly", " Quadratic is really starting to skyrocket", " And again, the log-linear one looks like it's almost flat compared to it", " And again, the observation here is that quadratic is often a problem", " Some problems are inherently quadratic, but if it's possible, we always want to look for a more efficient solution", " And we're going to see that we're going to regularly see quadratic problems, so this is an issue", " If we can find a log-linear one, we'd like that solution", " And then the final comparison kind of is mind-blowing", " Exponential algorithms are incredibly expensive", " In fact, here's a plot over here of an exponential versus a quadratic one, and you can't even see the graph because the exponential one is tucked right along this graph here, blown up really fast", " So if I replot this on a log scale which makes the exponential one now linear, you can see how much better the quadratic one is", " And this is why that's a big difference", " As I said earlier, there's a big difference between n^2 and 2^n", " 2^n grows really fast compared to n^2 ", " And this is just a visual way of reminding you of that", " If you can, you want to avoid an exponential class algorithm", " Even a quadratic one is going to be better by a long shot for any reasonable-size problem", " So these little graphs just give you a way of visualizing the differences between the different classes of algorithms", " And throughout the rest of the subject, we're going to come back to talk about different classes of algorithms and what their costs are", ""], "CsQrTLde-dM": ["NTA"]}